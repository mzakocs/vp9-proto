// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vp9.proto

#include "vp9.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
PROTOBUF_CONSTEXPR VP9SignedInteger::VP9SignedInteger(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sign_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VP9SignedIntegerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VP9SignedIntegerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VP9SignedIntegerDefaultTypeInternal() {}
  union {
    VP9SignedInteger _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VP9SignedIntegerDefaultTypeInternal _VP9SignedInteger_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_ColorConfig::UncompressedHeader_ColorConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ten_or_twelve_bit_)*/0u
  , /*decltype(_impl_.color_space_)*/0u
  , /*decltype(_impl_.color_range_)*/0u
  , /*decltype(_impl_.subsampling_x_)*/0u
  , /*decltype(_impl_.subsampling_y_)*/0u
  , /*decltype(_impl_.reserved_zero_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_ColorConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_ColorConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_ColorConfigDefaultTypeInternal() {}
  union {
    UncompressedHeader_ColorConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_ColorConfigDefaultTypeInternal _UncompressedHeader_ColorConfig_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_FrameSize::UncompressedHeader_FrameSize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.frame_width_minus_1_)*/0u
  , /*decltype(_impl_.frame_height_minus_1_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_FrameSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_FrameSizeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_FrameSizeDefaultTypeInternal() {}
  union {
    UncompressedHeader_FrameSize _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_FrameSizeDefaultTypeInternal _UncompressedHeader_FrameSize_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_RenderSize::UncompressedHeader_RenderSize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.render_and_frame_size_different_)*/0u
  , /*decltype(_impl_.render_width_minus_1_)*/0u
  , /*decltype(_impl_.render_height_minus_1_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_RenderSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_RenderSizeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_RenderSizeDefaultTypeInternal() {}
  union {
    UncompressedHeader_RenderSize _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_RenderSizeDefaultTypeInternal _UncompressedHeader_RenderSize_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_ReadInterpolationFilter::UncompressedHeader_ReadInterpolationFilter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.is_filter_switchable_)*/0u
  , /*decltype(_impl_.raw_interpolation_filter_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal() {}
  union {
    UncompressedHeader_ReadInterpolationFilter _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal _UncompressedHeader_ReadInterpolationFilter_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_LoopFilterParams::UncompressedHeader_LoopFilterParams(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.loop_filter_ref_deltas_)*/nullptr
  , /*decltype(_impl_.loop_filter_mode_deltas_)*/nullptr
  , /*decltype(_impl_.loop_filter_level_)*/0u
  , /*decltype(_impl_.loop_filter_sharpness_)*/0u
  , /*decltype(_impl_.loop_filter_delta_enabled_)*/0u
  , /*decltype(_impl_.loop_filter_delta_update_)*/0u
  , /*decltype(_impl_.update_ref_delta_)*/0u
  , /*decltype(_impl_.update_mode_delta_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_LoopFilterParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_LoopFilterParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_LoopFilterParamsDefaultTypeInternal() {}
  union {
    UncompressedHeader_LoopFilterParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_LoopFilterParamsDefaultTypeInternal _UncompressedHeader_LoopFilterParams_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_QuantizationParams::UncompressedHeader_QuantizationParams(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_q_idx_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_QuantizationParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_QuantizationParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_QuantizationParamsDefaultTypeInternal() {}
  union {
    UncompressedHeader_QuantizationParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_QuantizationParamsDefaultTypeInternal _UncompressedHeader_QuantizationParams_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_SegmentationParams::UncompressedHeader_SegmentationParams(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.feature_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.segmentation_enabled_)*/0u
  , /*decltype(_impl_.segmentation_update_map_)*/0u
  , /*decltype(_impl_.segmentation_temporal_update_)*/0u
  , /*decltype(_impl_.segmentation_update_data_)*/0u
  , /*decltype(_impl_.segmentation_abs_or_delta_update_)*/0u
  , /*decltype(_impl_.feature_enabled_)*/0u
  , /*decltype(_impl_.feature_sign_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_SegmentationParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_SegmentationParamsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_SegmentationParamsDefaultTypeInternal() {}
  union {
    UncompressedHeader_SegmentationParams _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_SegmentationParamsDefaultTypeInternal _UncompressedHeader_SegmentationParams_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader_TileInfo::UncompressedHeader_TileInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.increment_tile_cols_log2_)*/0u
  , /*decltype(_impl_.tile_rows_log2_)*/0u
  , /*decltype(_impl_.increment_tile_rows_log2_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeader_TileInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeader_TileInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeader_TileInfoDefaultTypeInternal() {}
  union {
    UncompressedHeader_TileInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeader_TileInfoDefaultTypeInternal _UncompressedHeader_TileInfo_default_instance_;
PROTOBUF_CONSTEXPR UncompressedHeader::UncompressedHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_config_)*/nullptr
  , /*decltype(_impl_.frame_size_)*/nullptr
  , /*decltype(_impl_.render_size_)*/nullptr
  , /*decltype(_impl_.read_interpolation_filter_)*/nullptr
  , /*decltype(_impl_.loop_filter_params_)*/nullptr
  , /*decltype(_impl_.quantization_params_)*/nullptr
  , /*decltype(_impl_.segmentation_params_)*/nullptr
  , /*decltype(_impl_.tile_info_)*/nullptr
  , /*decltype(_impl_.marker_)*/0u
  , /*decltype(_impl_.profile_)*/0u
  , /*decltype(_impl_.reserved_zero_)*/0u
  , /*decltype(_impl_.show_existing_frame_)*/0u
  , /*decltype(_impl_.frame_to_show_map_idx_)*/0u
  , /*decltype(_impl_.frame_type_)*/0u
  , /*decltype(_impl_.show_frame_)*/0u
  , /*decltype(_impl_.error_resilient_mode_)*/0u
  , /*decltype(_impl_.frame_sync_code_)*/0u
  , /*decltype(_impl_.frame_size_found_ref_)*/0u
  , /*decltype(_impl_.intra_only_)*/0u
  , /*decltype(_impl_.reset_frame_context_)*/0u
  , /*decltype(_impl_.refresh_frame_flags_)*/0u
  , /*decltype(_impl_.ref_frame_idx_)*/0u
  , /*decltype(_impl_.ref_frame_sign_bias_)*/0u
  , /*decltype(_impl_.allow_high_precision_mv_)*/0u
  , /*decltype(_impl_.frame_parallel_decoding_mode_)*/0u
  , /*decltype(_impl_.frame_context_idx_)*/0u
  , /*decltype(_impl_.header_size_in_bytes_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UncompressedHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UncompressedHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UncompressedHeaderDefaultTypeInternal() {}
  union {
    UncompressedHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UncompressedHeaderDefaultTypeInternal _UncompressedHeader_default_instance_;
PROTOBUF_CONSTEXPR CompressedHeader::CompressedHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.read_tx_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_mode_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_coef_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_skip_prob_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_inter_mode_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_interp_filter_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_is_inter_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.frame_reference_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.frame_reference_mode_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_y_mode_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_partition_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mv_probs_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CompressedHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompressedHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompressedHeaderDefaultTypeInternal() {}
  union {
    CompressedHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompressedHeaderDefaultTypeInternal _CompressedHeader_default_instance_;
PROTOBUF_CONSTEXPR Block_IntraFrameModeInfo::Block_IntraFrameModeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.segment_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.skip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_size_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default_intra_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default_uv_mode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Block_IntraFrameModeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Block_IntraFrameModeInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Block_IntraFrameModeInfoDefaultTypeInternal() {}
  union {
    Block_IntraFrameModeInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Block_IntraFrameModeInfoDefaultTypeInternal _Block_IntraFrameModeInfo_default_instance_;
PROTOBUF_CONSTEXPR Block_InterFrameModeInfo::Block_InterFrameModeInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.segment_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.skip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_inter_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tx_size_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.next_frame_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct Block_InterFrameModeInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Block_InterFrameModeInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Block_InterFrameModeInfoDefaultTypeInternal() {}
  union {
    Block_InterFrameModeInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Block_InterFrameModeInfoDefaultTypeInternal _Block_InterFrameModeInfo_default_instance_;
PROTOBUF_CONSTEXPR Block::Block(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.residual_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mode_info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct BlockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockDefaultTypeInternal() {}
  union {
    Block _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockDefaultTypeInternal _Block_default_instance_;
PROTOBUF_CONSTEXPR Partition::Partition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.partition_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PartitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartitionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartitionDefaultTypeInternal() {}
  union {
    Partition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartitionDefaultTypeInternal _Partition_default_instance_;
PROTOBUF_CONSTEXPR Tile::Tile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.partition_)*/nullptr
  , /*decltype(_impl_.tile_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TileDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TileDefaultTypeInternal() {}
  union {
    Tile _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TileDefaultTypeInternal _Tile_default_instance_;
PROTOBUF_CONSTEXPR VP9Frame::VP9Frame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tiles_)*/{}
  , /*decltype(_impl_.uncompressed_header_)*/nullptr
  , /*decltype(_impl_.compressed_header_)*/nullptr
  , /*decltype(_impl_.trailing_bits_)*/0u
  , /*decltype(_impl_.padding_bit_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VP9FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VP9FrameDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VP9FrameDefaultTypeInternal() {}
  union {
    VP9Frame _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VP9FrameDefaultTypeInternal _VP9Frame_default_instance_;
static ::_pb::Metadata file_level_metadata_vp9_2eproto[17];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_vp9_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_vp9_2eproto = nullptr;
const uint32_t TableStruct_vp9_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::VP9SignedInteger, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::VP9SignedInteger, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::VP9SignedInteger, _impl_.sign_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _impl_.ten_or_twelve_bit_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _impl_.color_space_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _impl_.color_range_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _impl_.subsampling_x_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _impl_.subsampling_y_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ColorConfig, _impl_.reserved_zero_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_FrameSize, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_FrameSize, _impl_.frame_width_minus_1_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_FrameSize, _impl_.frame_height_minus_1_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_RenderSize, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_RenderSize, _impl_.render_and_frame_size_different_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_RenderSize, _impl_.render_width_minus_1_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_RenderSize, _impl_.render_height_minus_1_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ReadInterpolationFilter, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ReadInterpolationFilter, _impl_.is_filter_switchable_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_ReadInterpolationFilter, _impl_.raw_interpolation_filter_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.loop_filter_level_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.loop_filter_sharpness_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.loop_filter_delta_enabled_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.loop_filter_delta_update_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.update_ref_delta_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.loop_filter_ref_deltas_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.update_mode_delta_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_LoopFilterParams, _impl_.loop_filter_mode_deltas_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_QuantizationParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_QuantizationParams, _impl_.base_q_idx_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.segmentation_enabled_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.segmentation_update_map_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.segmentation_temporal_update_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.segmentation_update_data_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.segmentation_abs_or_delta_update_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.feature_enabled_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.feature_value_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_SegmentationParams, _impl_.feature_sign_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_TileInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_TileInfo, _impl_.increment_tile_cols_log2_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_TileInfo, _impl_.tile_rows_log2_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader_TileInfo, _impl_.increment_tile_rows_log2_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.marker_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.profile_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.reserved_zero_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.show_existing_frame_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_to_show_map_idx_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_type_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.show_frame_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.error_resilient_mode_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_sync_code_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.color_config_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_size_found_ref_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_size_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.render_size_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.intra_only_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.reset_frame_context_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.refresh_frame_flags_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.ref_frame_idx_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.ref_frame_sign_bias_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.allow_high_precision_mv_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.read_interpolation_filter_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_parallel_decoding_mode_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.frame_context_idx_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.loop_filter_params_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.quantization_params_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.segmentation_params_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.tile_info_),
    PROTOBUF_FIELD_OFFSET(::UncompressedHeader, _impl_.header_size_in_bytes_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_tx_mode_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.tx_mode_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_coef_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_skip_prob_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_inter_mode_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_interp_filter_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_is_inter_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.frame_reference_mode_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.frame_reference_mode_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_y_mode_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.read_partition_probs_),
    PROTOBUF_FIELD_OFFSET(::CompressedHeader, _impl_.mv_probs_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::Block_IntraFrameModeInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::Block_IntraFrameModeInfo, _impl_.segment_id_),
    PROTOBUF_FIELD_OFFSET(::Block_IntraFrameModeInfo, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::Block_IntraFrameModeInfo, _impl_.tx_size_),
    PROTOBUF_FIELD_OFFSET(::Block_IntraFrameModeInfo, _impl_.default_intra_mode_),
    PROTOBUF_FIELD_OFFSET(::Block_IntraFrameModeInfo, _impl_.default_uv_mode_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_.segment_id_),
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_.skip_),
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_.is_inter_),
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_.tx_size_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_.next_frame_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::Block, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::Block, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::Block, _impl_.residual_),
    PROTOBUF_FIELD_OFFSET(::Block, _impl_.mode_info_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::Partition, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::Partition, _impl_.partition_),
    PROTOBUF_FIELD_OFFSET(::Partition, _impl_.block_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::Tile, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::Tile, _impl_.tile_size_),
    PROTOBUF_FIELD_OFFSET(::Tile, _impl_.partition_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::VP9Frame, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::VP9Frame, _impl_.uncompressed_header_),
    PROTOBUF_FIELD_OFFSET(::VP9Frame, _impl_.trailing_bits_),
    PROTOBUF_FIELD_OFFSET(::VP9Frame, _impl_.padding_bit_),
    PROTOBUF_FIELD_OFFSET(::VP9Frame, _impl_.compressed_header_),
    PROTOBUF_FIELD_OFFSET(::VP9Frame, _impl_.tiles_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::VP9SignedInteger)},
        { 10, -1, -1, sizeof(::UncompressedHeader_ColorConfig)},
        { 24, -1, -1, sizeof(::UncompressedHeader_FrameSize)},
        { 34, -1, -1, sizeof(::UncompressedHeader_RenderSize)},
        { 45, -1, -1, sizeof(::UncompressedHeader_ReadInterpolationFilter)},
        { 55, -1, -1, sizeof(::UncompressedHeader_LoopFilterParams)},
        { 71, -1, -1, sizeof(::UncompressedHeader_QuantizationParams)},
        { 80, -1, -1, sizeof(::UncompressedHeader_SegmentationParams)},
        { 96, -1, -1, sizeof(::UncompressedHeader_TileInfo)},
        { 107, -1, -1, sizeof(::UncompressedHeader)},
        { 142, -1, -1, sizeof(::CompressedHeader)},
        { 162, -1, -1, sizeof(::Block_IntraFrameModeInfo)},
        { 175, -1, -1, sizeof(::Block_InterFrameModeInfo)},
        { 190, -1, -1, sizeof(::Block)},
        { 202, -1, -1, sizeof(::Partition)},
        { 212, -1, -1, sizeof(::Tile)},
        { 222, -1, -1, sizeof(::VP9Frame)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::_VP9SignedInteger_default_instance_._instance,
    &::_UncompressedHeader_ColorConfig_default_instance_._instance,
    &::_UncompressedHeader_FrameSize_default_instance_._instance,
    &::_UncompressedHeader_RenderSize_default_instance_._instance,
    &::_UncompressedHeader_ReadInterpolationFilter_default_instance_._instance,
    &::_UncompressedHeader_LoopFilterParams_default_instance_._instance,
    &::_UncompressedHeader_QuantizationParams_default_instance_._instance,
    &::_UncompressedHeader_SegmentationParams_default_instance_._instance,
    &::_UncompressedHeader_TileInfo_default_instance_._instance,
    &::_UncompressedHeader_default_instance_._instance,
    &::_CompressedHeader_default_instance_._instance,
    &::_Block_IntraFrameModeInfo_default_instance_._instance,
    &::_Block_InterFrameModeInfo_default_instance_._instance,
    &::_Block_default_instance_._instance,
    &::_Partition_default_instance_._instance,
    &::_Tile_default_instance_._instance,
    &::_VP9Frame_default_instance_._instance,
};
const char descriptor_table_protodef_vp9_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\tvp9.proto\"/\n\020VP9SignedInteger\022\r\n\005value"
    "\030\001 \001(\014\022\014\n\004sign\030\002 \001(\r\"\364\020\n\022UncompressedHea"
    "der\022\016\n\006marker\030\001 \001(\r\022\017\n\007profile\030\002 \001(\r\022\025\n\r"
    "reserved_zero\030\003 \001(\r\022\033\n\023show_existing_fra"
    "me\030\004 \001(\r\022\035\n\025frame_to_show_map_idx\030\005 \001(\r\022"
    "\022\n\nframe_type\030\006 \001(\r\022\022\n\nshow_frame\030\007 \001(\r\022"
    "\034\n\024error_resilient_mode\030\010 \001(\r\022\027\n\017frame_s"
    "ync_code\030\t \001(\r\0225\n\014color_config\030\n \001(\0132\037.U"
    "ncompressedHeader.ColorConfig\022\034\n\024frame_s"
    "ize_found_ref\030\013 \001(\r\0221\n\nframe_size\030\014 \001(\0132"
    "\035.UncompressedHeader.FrameSize\0223\n\013render"
    "_size\030\r \001(\0132\036.UncompressedHeader.RenderS"
    "ize\022\022\n\nintra_only\030\016 \001(\r\022\033\n\023reset_frame_c"
    "ontext\030\017 \001(\r\022\033\n\023refresh_frame_flags\030\020 \001("
    "\r\022\025\n\rref_frame_idx\030\021 \001(\r\022\033\n\023ref_frame_si"
    "gn_bias\030\022 \001(\r\022\037\n\027allow_high_precision_mv"
    "\030\023 \001(\r\022N\n\031read_interpolation_filter\030\024 \001("
    "\0132+.UncompressedHeader.ReadInterpolation"
    "Filter\022$\n\034frame_parallel_decoding_mode\030\025"
    " \001(\r\022\031\n\021frame_context_idx\030\026 \001(\r\022@\n\022loop_"
    "filter_params\030\027 \001(\0132$.UncompressedHeader"
    ".LoopFilterParams\022C\n\023quantization_params"
    "\030\030 \001(\0132&.UncompressedHeader.Quantization"
    "Params\022C\n\023segmentation_params\030\031 \001(\0132&.Un"
    "compressedHeader.SegmentationParams\022/\n\tt"
    "ile_info\030\032 \001(\0132\034.UncompressedHeader.Tile"
    "Info\022\034\n\024header_size_in_bytes\030\033 \001(\r\032\227\001\n\013C"
    "olorConfig\022\031\n\021ten_or_twelve_bit\030\001 \001(\r\022\023\n"
    "\013color_space\030\002 \001(\r\022\023\n\013color_range\030\003 \001(\r\022"
    "\025\n\rsubsampling_x\030\004 \001(\r\022\025\n\rsubsampling_y\030"
    "\005 \001(\r\022\025\n\rreserved_zero\030\006 \001(\r\032F\n\tFrameSiz"
    "e\022\033\n\023frame_width_minus_1\030\001 \001(\r\022\034\n\024frame_"
    "height_minus_1\030\002 \001(\r\032r\n\nRenderSize\022\'\n\037re"
    "nder_and_frame_size_different\030\001 \001(\r\022\034\n\024r"
    "ender_width_minus_1\030\002 \001(\r\022\035\n\025render_heig"
    "ht_minus_1\030\003 \001(\r\032Y\n\027ReadInterpolationFil"
    "ter\022\034\n\024is_filter_switchable\030\001 \001(\r\022 \n\030raw"
    "_interpolation_filter\030\002 \001(\r\032\255\002\n\020LoopFilt"
    "erParams\022\031\n\021loop_filter_level\030\001 \001(\r\022\035\n\025l"
    "oop_filter_sharpness\030\002 \001(\r\022!\n\031loop_filte"
    "r_delta_enabled\030\003 \001(\r\022 \n\030loop_filter_del"
    "ta_update\030\004 \001(\r\022\030\n\020update_ref_delta\030\005 \001("
    "\r\0221\n\026loop_filter_ref_deltas\030\006 \001(\0132\021.VP9S"
    "ignedInteger\022\031\n\021update_mode_delta\030\007 \001(\r\022"
    "2\n\027loop_filter_mode_deltas\030\010 \001(\0132\021.VP9Si"
    "gnedInteger\032(\n\022QuantizationParams\022\022\n\nbas"
    "e_q_idx\030\001 \001(\r\032\213\002\n\022SegmentationParams\022\034\n\024"
    "segmentation_enabled\030\001 \001(\r\022\037\n\027segmentati"
    "on_update_map\030\002 \001(\r\022$\n\034segmentation_temp"
    "oral_update\030\003 \001(\r\022 \n\030segmentation_update"
    "_data\030\004 \001(\r\022(\n segmentation_abs_or_delta"
    "_update\030\005 \001(\r\022\027\n\017feature_enabled\030\006 \001(\r\022\025"
    "\n\rfeature_value\030\007 \001(\014\022\024\n\014feature_sign\030\010 "
    "\001(\r\032f\n\010TileInfo\022 \n\030increment_tile_cols_l"
    "og2\030\001 \001(\r\022\026\n\016tile_rows_log2\030\002 \001(\r\022 \n\030inc"
    "rement_tile_rows_Log2\030\003 \001(\r\"\333\002\n\020Compress"
    "edHeader\022\024\n\014read_tx_mode\030\001 \001(\014\022\025\n\rtx_mod"
    "e_probs\030\002 \001(\014\022\027\n\017read_coef_probs\030\003 \001(\014\022\026"
    "\n\016read_skip_prob\030\004 \001(\014\022\035\n\025read_inter_mod"
    "e_probs\030\005 \001(\014\022 \n\030read_interp_filter_prob"
    "s\030\006 \001(\014\022\033\n\023read_is_inter_probs\030\007 \001(\014\022\034\n\024"
    "frame_reference_mode\030\010 \001(\014\022\"\n\032frame_refe"
    "rence_mode_probs\030\t \001(\014\022\031\n\021read_y_mode_pr"
    "obs\030\n \001(\014\022\034\n\024read_partition_probs\030\013 \001(\014\022"
    "\020\n\010mv_probs\030\014 \001(\014\"\326\003\n\005Block\0220\n\013intra_fra"
    "me\030\001 \001(\0132\031.Block.IntraFrameModeInfoH\000\0220\n"
    "\013inter_frame\030\002 \001(\0132\031.Block.InterFrameMod"
    "eInfoH\000\022\020\n\010residual\030\003 \001(\014\032|\n\022IntraFrameM"
    "odeInfo\022\022\n\nsegment_id\030\001 \001(\014\022\014\n\004skip\030\002 \001("
    "\014\022\017\n\007tx_size\030\003 \001(\014\022\032\n\022default_intra_mode"
    "\030\004 \001(\014\022\027\n\017default_uv_mode\030\005 \001(\014\032\313\001\n\022Inte"
    "rFrameModeInfo\022\022\n\nsegment_id\030\001 \001(\014\022\014\n\004sk"
    "ip\030\002 \001(\014\022\020\n\010is_inter\030\003 \001(\014\022\017\n\007tx_size\030\004 "
    "\001(\014\0220\n\013intra_frame\030\005 \001(\0132\031.Block.IntraFr"
    "ameModeInfoH\000\0220\n\013inter_frame\030\006 \001(\0132\031.Blo"
    "ck.InterFrameModeInfoH\000B\014\n\nnext_frameB\013\n"
    "\tmode_info\"5\n\tPartition\022\021\n\tpartition\030\001 \001"
    "(\014\022\025\n\005block\030\002 \001(\0132\006.Block\"8\n\004Tile\022\021\n\ttil"
    "e_size\030\001 \001(\r\022\035\n\tpartition\030\002 \001(\0132\n.Partit"
    "ion\"\254\001\n\010VP9Frame\0220\n\023uncompressed_header\030"
    "\001 \001(\0132\023.UncompressedHeader\022\025\n\rtrailing_b"
    "its\030\002 \001(\r\022\023\n\013padding_bit\030\003 \001(\r\022,\n\021compre"
    "ssed_header\030\004 \001(\0132\021.CompressedHeader\022\024\n\005"
    "tiles\030\005 \003(\0132\005.Tileb\006proto3"
};
static ::absl::once_flag descriptor_table_vp9_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_vp9_2eproto = {
    false,
    false,
    3346,
    descriptor_table_protodef_vp9_2eproto,
    "vp9.proto",
    &descriptor_table_vp9_2eproto_once,
    nullptr,
    0,
    17,
    schemas,
    file_default_instances,
    TableStruct_vp9_2eproto::offsets,
    file_level_metadata_vp9_2eproto,
    file_level_enum_descriptors_vp9_2eproto,
    file_level_service_descriptors_vp9_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_vp9_2eproto_getter() {
  return &descriptor_table_vp9_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_vp9_2eproto(&descriptor_table_vp9_2eproto);
// ===================================================================

class VP9SignedInteger::_Internal {
 public:
};

VP9SignedInteger::VP9SignedInteger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VP9SignedInteger)
}
VP9SignedInteger::VP9SignedInteger(const VP9SignedInteger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VP9SignedInteger* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.sign_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.sign_ = from._impl_.sign_;
  // @@protoc_insertion_point(copy_constructor:VP9SignedInteger)
}

inline void VP9SignedInteger::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){}
    , decltype(_impl_.sign_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VP9SignedInteger::~VP9SignedInteger() {
  // @@protoc_insertion_point(destructor:VP9SignedInteger)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VP9SignedInteger::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void VP9SignedInteger::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VP9SignedInteger::Clear() {
// @@protoc_insertion_point(message_clear_start:VP9SignedInteger)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_.ClearToEmpty();
  _impl_.sign_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VP9SignedInteger::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sign = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VP9SignedInteger::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VP9SignedInteger)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes value = 1;
  if (!this->_internal_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_value(), target);
  }

  // uint32 sign = 2;
  if (this->_internal_sign() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sign(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VP9SignedInteger)
  return target;
}

size_t VP9SignedInteger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VP9SignedInteger)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes value = 1;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_value());
  }

  // uint32 sign = 2;
  if (this->_internal_sign() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sign());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VP9SignedInteger::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VP9SignedInteger::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VP9SignedInteger::GetClassData() const { return &_class_data_; }


void VP9SignedInteger::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VP9SignedInteger*>(&to_msg);
  auto& from = static_cast<const VP9SignedInteger&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VP9SignedInteger)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_sign() != 0) {
    _this->_internal_set_sign(from._internal_sign());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VP9SignedInteger::CopyFrom(const VP9SignedInteger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VP9SignedInteger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VP9SignedInteger::IsInitialized() const {
  return true;
}

void VP9SignedInteger::InternalSwap(VP9SignedInteger* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.sign_, other->_impl_.sign_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VP9SignedInteger::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[0]);
}
// ===================================================================

class UncompressedHeader_ColorConfig::_Internal {
 public:
};

UncompressedHeader_ColorConfig::UncompressedHeader_ColorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.ColorConfig)
}
UncompressedHeader_ColorConfig::UncompressedHeader_ColorConfig(const UncompressedHeader_ColorConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_ColorConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ten_or_twelve_bit_){}
    , decltype(_impl_.color_space_){}
    , decltype(_impl_.color_range_){}
    , decltype(_impl_.subsampling_x_){}
    , decltype(_impl_.subsampling_y_){}
    , decltype(_impl_.reserved_zero_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ten_or_twelve_bit_, &from._impl_.ten_or_twelve_bit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reserved_zero_) -
    reinterpret_cast<char*>(&_impl_.ten_or_twelve_bit_)) + sizeof(_impl_.reserved_zero_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.ColorConfig)
}

inline void UncompressedHeader_ColorConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ten_or_twelve_bit_){0u}
    , decltype(_impl_.color_space_){0u}
    , decltype(_impl_.color_range_){0u}
    , decltype(_impl_.subsampling_x_){0u}
    , decltype(_impl_.subsampling_y_){0u}
    , decltype(_impl_.reserved_zero_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_ColorConfig::~UncompressedHeader_ColorConfig() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.ColorConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_ColorConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UncompressedHeader_ColorConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_ColorConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.ColorConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.ten_or_twelve_bit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.reserved_zero_) -
      reinterpret_cast<char*>(&_impl_.ten_or_twelve_bit_)) + sizeof(_impl_.reserved_zero_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_ColorConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 ten_or_twelve_bit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ten_or_twelve_bit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 color_space = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.color_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 color_range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.color_range_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 subsampling_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.subsampling_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 subsampling_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.subsampling_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reserved_zero = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.reserved_zero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_ColorConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.ColorConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ten_or_twelve_bit = 1;
  if (this->_internal_ten_or_twelve_bit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ten_or_twelve_bit(), target);
  }

  // uint32 color_space = 2;
  if (this->_internal_color_space() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_color_space(), target);
  }

  // uint32 color_range = 3;
  if (this->_internal_color_range() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_color_range(), target);
  }

  // uint32 subsampling_x = 4;
  if (this->_internal_subsampling_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_subsampling_x(), target);
  }

  // uint32 subsampling_y = 5;
  if (this->_internal_subsampling_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_subsampling_y(), target);
  }

  // uint32 reserved_zero = 6;
  if (this->_internal_reserved_zero() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_reserved_zero(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.ColorConfig)
  return target;
}

size_t UncompressedHeader_ColorConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.ColorConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 ten_or_twelve_bit = 1;
  if (this->_internal_ten_or_twelve_bit() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ten_or_twelve_bit());
  }

  // uint32 color_space = 2;
  if (this->_internal_color_space() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color_space());
  }

  // uint32 color_range = 3;
  if (this->_internal_color_range() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color_range());
  }

  // uint32 subsampling_x = 4;
  if (this->_internal_subsampling_x() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_subsampling_x());
  }

  // uint32 subsampling_y = 5;
  if (this->_internal_subsampling_y() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_subsampling_y());
  }

  // uint32 reserved_zero = 6;
  if (this->_internal_reserved_zero() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reserved_zero());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_ColorConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_ColorConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_ColorConfig::GetClassData() const { return &_class_data_; }


void UncompressedHeader_ColorConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_ColorConfig*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_ColorConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.ColorConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ten_or_twelve_bit() != 0) {
    _this->_internal_set_ten_or_twelve_bit(from._internal_ten_or_twelve_bit());
  }
  if (from._internal_color_space() != 0) {
    _this->_internal_set_color_space(from._internal_color_space());
  }
  if (from._internal_color_range() != 0) {
    _this->_internal_set_color_range(from._internal_color_range());
  }
  if (from._internal_subsampling_x() != 0) {
    _this->_internal_set_subsampling_x(from._internal_subsampling_x());
  }
  if (from._internal_subsampling_y() != 0) {
    _this->_internal_set_subsampling_y(from._internal_subsampling_y());
  }
  if (from._internal_reserved_zero() != 0) {
    _this->_internal_set_reserved_zero(from._internal_reserved_zero());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_ColorConfig::CopyFrom(const UncompressedHeader_ColorConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.ColorConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_ColorConfig::IsInitialized() const {
  return true;
}

void UncompressedHeader_ColorConfig::InternalSwap(UncompressedHeader_ColorConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_ColorConfig, _impl_.reserved_zero_)
      + sizeof(UncompressedHeader_ColorConfig::_impl_.reserved_zero_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_ColorConfig, _impl_.ten_or_twelve_bit_)>(
          reinterpret_cast<char*>(&_impl_.ten_or_twelve_bit_),
          reinterpret_cast<char*>(&other->_impl_.ten_or_twelve_bit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_ColorConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[1]);
}
// ===================================================================

class UncompressedHeader_FrameSize::_Internal {
 public:
};

UncompressedHeader_FrameSize::UncompressedHeader_FrameSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.FrameSize)
}
UncompressedHeader_FrameSize::UncompressedHeader_FrameSize(const UncompressedHeader_FrameSize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_FrameSize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.frame_width_minus_1_){}
    , decltype(_impl_.frame_height_minus_1_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.frame_width_minus_1_, &from._impl_.frame_width_minus_1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.frame_height_minus_1_) -
    reinterpret_cast<char*>(&_impl_.frame_width_minus_1_)) + sizeof(_impl_.frame_height_minus_1_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.FrameSize)
}

inline void UncompressedHeader_FrameSize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.frame_width_minus_1_){0u}
    , decltype(_impl_.frame_height_minus_1_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_FrameSize::~UncompressedHeader_FrameSize() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.FrameSize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_FrameSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UncompressedHeader_FrameSize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_FrameSize::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.FrameSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.frame_width_minus_1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.frame_height_minus_1_) -
      reinterpret_cast<char*>(&_impl_.frame_width_minus_1_)) + sizeof(_impl_.frame_height_minus_1_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_FrameSize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 frame_width_minus_1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.frame_width_minus_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_height_minus_1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.frame_height_minus_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_FrameSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.FrameSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 frame_width_minus_1 = 1;
  if (this->_internal_frame_width_minus_1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_frame_width_minus_1(), target);
  }

  // uint32 frame_height_minus_1 = 2;
  if (this->_internal_frame_height_minus_1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_frame_height_minus_1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.FrameSize)
  return target;
}

size_t UncompressedHeader_FrameSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.FrameSize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 frame_width_minus_1 = 1;
  if (this->_internal_frame_width_minus_1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_width_minus_1());
  }

  // uint32 frame_height_minus_1 = 2;
  if (this->_internal_frame_height_minus_1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_height_minus_1());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_FrameSize::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_FrameSize::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_FrameSize::GetClassData() const { return &_class_data_; }


void UncompressedHeader_FrameSize::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_FrameSize*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_FrameSize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.FrameSize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_frame_width_minus_1() != 0) {
    _this->_internal_set_frame_width_minus_1(from._internal_frame_width_minus_1());
  }
  if (from._internal_frame_height_minus_1() != 0) {
    _this->_internal_set_frame_height_minus_1(from._internal_frame_height_minus_1());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_FrameSize::CopyFrom(const UncompressedHeader_FrameSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.FrameSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_FrameSize::IsInitialized() const {
  return true;
}

void UncompressedHeader_FrameSize::InternalSwap(UncompressedHeader_FrameSize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_FrameSize, _impl_.frame_height_minus_1_)
      + sizeof(UncompressedHeader_FrameSize::_impl_.frame_height_minus_1_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_FrameSize, _impl_.frame_width_minus_1_)>(
          reinterpret_cast<char*>(&_impl_.frame_width_minus_1_),
          reinterpret_cast<char*>(&other->_impl_.frame_width_minus_1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_FrameSize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[2]);
}
// ===================================================================

class UncompressedHeader_RenderSize::_Internal {
 public:
};

UncompressedHeader_RenderSize::UncompressedHeader_RenderSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.RenderSize)
}
UncompressedHeader_RenderSize::UncompressedHeader_RenderSize(const UncompressedHeader_RenderSize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_RenderSize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.render_and_frame_size_different_){}
    , decltype(_impl_.render_width_minus_1_){}
    , decltype(_impl_.render_height_minus_1_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.render_and_frame_size_different_, &from._impl_.render_and_frame_size_different_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.render_height_minus_1_) -
    reinterpret_cast<char*>(&_impl_.render_and_frame_size_different_)) + sizeof(_impl_.render_height_minus_1_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.RenderSize)
}

inline void UncompressedHeader_RenderSize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.render_and_frame_size_different_){0u}
    , decltype(_impl_.render_width_minus_1_){0u}
    , decltype(_impl_.render_height_minus_1_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_RenderSize::~UncompressedHeader_RenderSize() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.RenderSize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_RenderSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UncompressedHeader_RenderSize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_RenderSize::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.RenderSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.render_and_frame_size_different_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.render_height_minus_1_) -
      reinterpret_cast<char*>(&_impl_.render_and_frame_size_different_)) + sizeof(_impl_.render_height_minus_1_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_RenderSize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 render_and_frame_size_different = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.render_and_frame_size_different_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 render_width_minus_1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.render_width_minus_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 render_height_minus_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.render_height_minus_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_RenderSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.RenderSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 render_and_frame_size_different = 1;
  if (this->_internal_render_and_frame_size_different() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_render_and_frame_size_different(), target);
  }

  // uint32 render_width_minus_1 = 2;
  if (this->_internal_render_width_minus_1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_render_width_minus_1(), target);
  }

  // uint32 render_height_minus_1 = 3;
  if (this->_internal_render_height_minus_1() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_render_height_minus_1(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.RenderSize)
  return target;
}

size_t UncompressedHeader_RenderSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.RenderSize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 render_and_frame_size_different = 1;
  if (this->_internal_render_and_frame_size_different() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_render_and_frame_size_different());
  }

  // uint32 render_width_minus_1 = 2;
  if (this->_internal_render_width_minus_1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_render_width_minus_1());
  }

  // uint32 render_height_minus_1 = 3;
  if (this->_internal_render_height_minus_1() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_render_height_minus_1());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_RenderSize::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_RenderSize::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_RenderSize::GetClassData() const { return &_class_data_; }


void UncompressedHeader_RenderSize::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_RenderSize*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_RenderSize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.RenderSize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_render_and_frame_size_different() != 0) {
    _this->_internal_set_render_and_frame_size_different(from._internal_render_and_frame_size_different());
  }
  if (from._internal_render_width_minus_1() != 0) {
    _this->_internal_set_render_width_minus_1(from._internal_render_width_minus_1());
  }
  if (from._internal_render_height_minus_1() != 0) {
    _this->_internal_set_render_height_minus_1(from._internal_render_height_minus_1());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_RenderSize::CopyFrom(const UncompressedHeader_RenderSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.RenderSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_RenderSize::IsInitialized() const {
  return true;
}

void UncompressedHeader_RenderSize::InternalSwap(UncompressedHeader_RenderSize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_RenderSize, _impl_.render_height_minus_1_)
      + sizeof(UncompressedHeader_RenderSize::_impl_.render_height_minus_1_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_RenderSize, _impl_.render_and_frame_size_different_)>(
          reinterpret_cast<char*>(&_impl_.render_and_frame_size_different_),
          reinterpret_cast<char*>(&other->_impl_.render_and_frame_size_different_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_RenderSize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[3]);
}
// ===================================================================

class UncompressedHeader_ReadInterpolationFilter::_Internal {
 public:
};

UncompressedHeader_ReadInterpolationFilter::UncompressedHeader_ReadInterpolationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.ReadInterpolationFilter)
}
UncompressedHeader_ReadInterpolationFilter::UncompressedHeader_ReadInterpolationFilter(const UncompressedHeader_ReadInterpolationFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_ReadInterpolationFilter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.is_filter_switchable_){}
    , decltype(_impl_.raw_interpolation_filter_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.is_filter_switchable_, &from._impl_.is_filter_switchable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.raw_interpolation_filter_) -
    reinterpret_cast<char*>(&_impl_.is_filter_switchable_)) + sizeof(_impl_.raw_interpolation_filter_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.ReadInterpolationFilter)
}

inline void UncompressedHeader_ReadInterpolationFilter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.is_filter_switchable_){0u}
    , decltype(_impl_.raw_interpolation_filter_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_ReadInterpolationFilter::~UncompressedHeader_ReadInterpolationFilter() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.ReadInterpolationFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_ReadInterpolationFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UncompressedHeader_ReadInterpolationFilter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_ReadInterpolationFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.ReadInterpolationFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.is_filter_switchable_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.raw_interpolation_filter_) -
      reinterpret_cast<char*>(&_impl_.is_filter_switchable_)) + sizeof(_impl_.raw_interpolation_filter_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_ReadInterpolationFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 is_filter_switchable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.is_filter_switchable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 raw_interpolation_filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.raw_interpolation_filter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_ReadInterpolationFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.ReadInterpolationFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 is_filter_switchable = 1;
  if (this->_internal_is_filter_switchable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_is_filter_switchable(), target);
  }

  // uint32 raw_interpolation_filter = 2;
  if (this->_internal_raw_interpolation_filter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_raw_interpolation_filter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.ReadInterpolationFilter)
  return target;
}

size_t UncompressedHeader_ReadInterpolationFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.ReadInterpolationFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 is_filter_switchable = 1;
  if (this->_internal_is_filter_switchable() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_is_filter_switchable());
  }

  // uint32 raw_interpolation_filter = 2;
  if (this->_internal_raw_interpolation_filter() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_raw_interpolation_filter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_ReadInterpolationFilter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_ReadInterpolationFilter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_ReadInterpolationFilter::GetClassData() const { return &_class_data_; }


void UncompressedHeader_ReadInterpolationFilter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_ReadInterpolationFilter*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_ReadInterpolationFilter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.ReadInterpolationFilter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_is_filter_switchable() != 0) {
    _this->_internal_set_is_filter_switchable(from._internal_is_filter_switchable());
  }
  if (from._internal_raw_interpolation_filter() != 0) {
    _this->_internal_set_raw_interpolation_filter(from._internal_raw_interpolation_filter());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_ReadInterpolationFilter::CopyFrom(const UncompressedHeader_ReadInterpolationFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.ReadInterpolationFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_ReadInterpolationFilter::IsInitialized() const {
  return true;
}

void UncompressedHeader_ReadInterpolationFilter::InternalSwap(UncompressedHeader_ReadInterpolationFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_ReadInterpolationFilter, _impl_.raw_interpolation_filter_)
      + sizeof(UncompressedHeader_ReadInterpolationFilter::_impl_.raw_interpolation_filter_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_ReadInterpolationFilter, _impl_.is_filter_switchable_)>(
          reinterpret_cast<char*>(&_impl_.is_filter_switchable_),
          reinterpret_cast<char*>(&other->_impl_.is_filter_switchable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_ReadInterpolationFilter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[4]);
}
// ===================================================================

class UncompressedHeader_LoopFilterParams::_Internal {
 public:
  static const ::VP9SignedInteger& loop_filter_ref_deltas(const UncompressedHeader_LoopFilterParams* msg);
  static const ::VP9SignedInteger& loop_filter_mode_deltas(const UncompressedHeader_LoopFilterParams* msg);
};

const ::VP9SignedInteger&
UncompressedHeader_LoopFilterParams::_Internal::loop_filter_ref_deltas(const UncompressedHeader_LoopFilterParams* msg) {
  return *msg->_impl_.loop_filter_ref_deltas_;
}
const ::VP9SignedInteger&
UncompressedHeader_LoopFilterParams::_Internal::loop_filter_mode_deltas(const UncompressedHeader_LoopFilterParams* msg) {
  return *msg->_impl_.loop_filter_mode_deltas_;
}
UncompressedHeader_LoopFilterParams::UncompressedHeader_LoopFilterParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.LoopFilterParams)
}
UncompressedHeader_LoopFilterParams::UncompressedHeader_LoopFilterParams(const UncompressedHeader_LoopFilterParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_LoopFilterParams* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.loop_filter_ref_deltas_){nullptr}
    , decltype(_impl_.loop_filter_mode_deltas_){nullptr}
    , decltype(_impl_.loop_filter_level_){}
    , decltype(_impl_.loop_filter_sharpness_){}
    , decltype(_impl_.loop_filter_delta_enabled_){}
    , decltype(_impl_.loop_filter_delta_update_){}
    , decltype(_impl_.update_ref_delta_){}
    , decltype(_impl_.update_mode_delta_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_loop_filter_ref_deltas()) {
    _this->_impl_.loop_filter_ref_deltas_ = new ::VP9SignedInteger(*from._impl_.loop_filter_ref_deltas_);
  }
  if (from._internal_has_loop_filter_mode_deltas()) {
    _this->_impl_.loop_filter_mode_deltas_ = new ::VP9SignedInteger(*from._impl_.loop_filter_mode_deltas_);
  }
  ::memcpy(&_impl_.loop_filter_level_, &from._impl_.loop_filter_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.update_mode_delta_) -
    reinterpret_cast<char*>(&_impl_.loop_filter_level_)) + sizeof(_impl_.update_mode_delta_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.LoopFilterParams)
}

inline void UncompressedHeader_LoopFilterParams::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.loop_filter_ref_deltas_){nullptr}
    , decltype(_impl_.loop_filter_mode_deltas_){nullptr}
    , decltype(_impl_.loop_filter_level_){0u}
    , decltype(_impl_.loop_filter_sharpness_){0u}
    , decltype(_impl_.loop_filter_delta_enabled_){0u}
    , decltype(_impl_.loop_filter_delta_update_){0u}
    , decltype(_impl_.update_ref_delta_){0u}
    , decltype(_impl_.update_mode_delta_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_LoopFilterParams::~UncompressedHeader_LoopFilterParams() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.LoopFilterParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_LoopFilterParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.loop_filter_ref_deltas_;
  if (this != internal_default_instance()) delete _impl_.loop_filter_mode_deltas_;
}

void UncompressedHeader_LoopFilterParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_LoopFilterParams::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.LoopFilterParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_ref_deltas_ != nullptr) {
    delete _impl_.loop_filter_ref_deltas_;
  }
  _impl_.loop_filter_ref_deltas_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_mode_deltas_ != nullptr) {
    delete _impl_.loop_filter_mode_deltas_;
  }
  _impl_.loop_filter_mode_deltas_ = nullptr;
  ::memset(&_impl_.loop_filter_level_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.update_mode_delta_) -
      reinterpret_cast<char*>(&_impl_.loop_filter_level_)) + sizeof(_impl_.update_mode_delta_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_LoopFilterParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 loop_filter_level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.loop_filter_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 loop_filter_sharpness = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.loop_filter_sharpness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 loop_filter_delta_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.loop_filter_delta_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 loop_filter_delta_update = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.loop_filter_delta_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 update_ref_delta = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.update_ref_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VP9SignedInteger loop_filter_ref_deltas = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_loop_filter_ref_deltas(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 update_mode_delta = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.update_mode_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .VP9SignedInteger loop_filter_mode_deltas = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_loop_filter_mode_deltas(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_LoopFilterParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.LoopFilterParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 loop_filter_level = 1;
  if (this->_internal_loop_filter_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_loop_filter_level(), target);
  }

  // uint32 loop_filter_sharpness = 2;
  if (this->_internal_loop_filter_sharpness() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_loop_filter_sharpness(), target);
  }

  // uint32 loop_filter_delta_enabled = 3;
  if (this->_internal_loop_filter_delta_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_loop_filter_delta_enabled(), target);
  }

  // uint32 loop_filter_delta_update = 4;
  if (this->_internal_loop_filter_delta_update() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_loop_filter_delta_update(), target);
  }

  // uint32 update_ref_delta = 5;
  if (this->_internal_update_ref_delta() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_update_ref_delta(), target);
  }

  // .VP9SignedInteger loop_filter_ref_deltas = 6;
  if (this->_internal_has_loop_filter_ref_deltas()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::loop_filter_ref_deltas(this),
        _Internal::loop_filter_ref_deltas(this).GetCachedSize(), target, stream);
  }

  // uint32 update_mode_delta = 7;
  if (this->_internal_update_mode_delta() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_update_mode_delta(), target);
  }

  // .VP9SignedInteger loop_filter_mode_deltas = 8;
  if (this->_internal_has_loop_filter_mode_deltas()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::loop_filter_mode_deltas(this),
        _Internal::loop_filter_mode_deltas(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.LoopFilterParams)
  return target;
}

size_t UncompressedHeader_LoopFilterParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.LoopFilterParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .VP9SignedInteger loop_filter_ref_deltas = 6;
  if (this->_internal_has_loop_filter_ref_deltas()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loop_filter_ref_deltas_);
  }

  // .VP9SignedInteger loop_filter_mode_deltas = 8;
  if (this->_internal_has_loop_filter_mode_deltas()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loop_filter_mode_deltas_);
  }

  // uint32 loop_filter_level = 1;
  if (this->_internal_loop_filter_level() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_loop_filter_level());
  }

  // uint32 loop_filter_sharpness = 2;
  if (this->_internal_loop_filter_sharpness() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_loop_filter_sharpness());
  }

  // uint32 loop_filter_delta_enabled = 3;
  if (this->_internal_loop_filter_delta_enabled() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_loop_filter_delta_enabled());
  }

  // uint32 loop_filter_delta_update = 4;
  if (this->_internal_loop_filter_delta_update() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_loop_filter_delta_update());
  }

  // uint32 update_ref_delta = 5;
  if (this->_internal_update_ref_delta() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_update_ref_delta());
  }

  // uint32 update_mode_delta = 7;
  if (this->_internal_update_mode_delta() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_update_mode_delta());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_LoopFilterParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_LoopFilterParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_LoopFilterParams::GetClassData() const { return &_class_data_; }


void UncompressedHeader_LoopFilterParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_LoopFilterParams*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_LoopFilterParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.LoopFilterParams)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_loop_filter_ref_deltas()) {
    _this->_internal_mutable_loop_filter_ref_deltas()->::VP9SignedInteger::MergeFrom(
        from._internal_loop_filter_ref_deltas());
  }
  if (from._internal_has_loop_filter_mode_deltas()) {
    _this->_internal_mutable_loop_filter_mode_deltas()->::VP9SignedInteger::MergeFrom(
        from._internal_loop_filter_mode_deltas());
  }
  if (from._internal_loop_filter_level() != 0) {
    _this->_internal_set_loop_filter_level(from._internal_loop_filter_level());
  }
  if (from._internal_loop_filter_sharpness() != 0) {
    _this->_internal_set_loop_filter_sharpness(from._internal_loop_filter_sharpness());
  }
  if (from._internal_loop_filter_delta_enabled() != 0) {
    _this->_internal_set_loop_filter_delta_enabled(from._internal_loop_filter_delta_enabled());
  }
  if (from._internal_loop_filter_delta_update() != 0) {
    _this->_internal_set_loop_filter_delta_update(from._internal_loop_filter_delta_update());
  }
  if (from._internal_update_ref_delta() != 0) {
    _this->_internal_set_update_ref_delta(from._internal_update_ref_delta());
  }
  if (from._internal_update_mode_delta() != 0) {
    _this->_internal_set_update_mode_delta(from._internal_update_mode_delta());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_LoopFilterParams::CopyFrom(const UncompressedHeader_LoopFilterParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.LoopFilterParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_LoopFilterParams::IsInitialized() const {
  return true;
}

void UncompressedHeader_LoopFilterParams::InternalSwap(UncompressedHeader_LoopFilterParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_LoopFilterParams, _impl_.update_mode_delta_)
      + sizeof(UncompressedHeader_LoopFilterParams::_impl_.update_mode_delta_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_LoopFilterParams, _impl_.loop_filter_ref_deltas_)>(
          reinterpret_cast<char*>(&_impl_.loop_filter_ref_deltas_),
          reinterpret_cast<char*>(&other->_impl_.loop_filter_ref_deltas_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_LoopFilterParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[5]);
}
// ===================================================================

class UncompressedHeader_QuantizationParams::_Internal {
 public:
};

UncompressedHeader_QuantizationParams::UncompressedHeader_QuantizationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.QuantizationParams)
}
UncompressedHeader_QuantizationParams::UncompressedHeader_QuantizationParams(const UncompressedHeader_QuantizationParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_QuantizationParams* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_q_idx_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.base_q_idx_ = from._impl_.base_q_idx_;
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.QuantizationParams)
}

inline void UncompressedHeader_QuantizationParams::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.base_q_idx_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_QuantizationParams::~UncompressedHeader_QuantizationParams() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.QuantizationParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_QuantizationParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UncompressedHeader_QuantizationParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_QuantizationParams::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.QuantizationParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.base_q_idx_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_QuantizationParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 base_q_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.base_q_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_QuantizationParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.QuantizationParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 base_q_idx = 1;
  if (this->_internal_base_q_idx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_base_q_idx(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.QuantizationParams)
  return target;
}

size_t UncompressedHeader_QuantizationParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.QuantizationParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 base_q_idx = 1;
  if (this->_internal_base_q_idx() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_q_idx());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_QuantizationParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_QuantizationParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_QuantizationParams::GetClassData() const { return &_class_data_; }


void UncompressedHeader_QuantizationParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_QuantizationParams*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_QuantizationParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.QuantizationParams)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_base_q_idx() != 0) {
    _this->_internal_set_base_q_idx(from._internal_base_q_idx());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_QuantizationParams::CopyFrom(const UncompressedHeader_QuantizationParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.QuantizationParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_QuantizationParams::IsInitialized() const {
  return true;
}

void UncompressedHeader_QuantizationParams::InternalSwap(UncompressedHeader_QuantizationParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.base_q_idx_, other->_impl_.base_q_idx_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_QuantizationParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[6]);
}
// ===================================================================

class UncompressedHeader_SegmentationParams::_Internal {
 public:
};

UncompressedHeader_SegmentationParams::UncompressedHeader_SegmentationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.SegmentationParams)
}
UncompressedHeader_SegmentationParams::UncompressedHeader_SegmentationParams(const UncompressedHeader_SegmentationParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_SegmentationParams* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.feature_value_){}
    , decltype(_impl_.segmentation_enabled_){}
    , decltype(_impl_.segmentation_update_map_){}
    , decltype(_impl_.segmentation_temporal_update_){}
    , decltype(_impl_.segmentation_update_data_){}
    , decltype(_impl_.segmentation_abs_or_delta_update_){}
    , decltype(_impl_.feature_enabled_){}
    , decltype(_impl_.feature_sign_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.feature_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.feature_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_feature_value().empty()) {
    _this->_impl_.feature_value_.Set(from._internal_feature_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.segmentation_enabled_, &from._impl_.segmentation_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.feature_sign_) -
    reinterpret_cast<char*>(&_impl_.segmentation_enabled_)) + sizeof(_impl_.feature_sign_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.SegmentationParams)
}

inline void UncompressedHeader_SegmentationParams::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.feature_value_){}
    , decltype(_impl_.segmentation_enabled_){0u}
    , decltype(_impl_.segmentation_update_map_){0u}
    , decltype(_impl_.segmentation_temporal_update_){0u}
    , decltype(_impl_.segmentation_update_data_){0u}
    , decltype(_impl_.segmentation_abs_or_delta_update_){0u}
    , decltype(_impl_.feature_enabled_){0u}
    , decltype(_impl_.feature_sign_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.feature_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.feature_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UncompressedHeader_SegmentationParams::~UncompressedHeader_SegmentationParams() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.SegmentationParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_SegmentationParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feature_value_.Destroy();
}

void UncompressedHeader_SegmentationParams::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_SegmentationParams::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.SegmentationParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.feature_value_.ClearToEmpty();
  ::memset(&_impl_.segmentation_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.feature_sign_) -
      reinterpret_cast<char*>(&_impl_.segmentation_enabled_)) + sizeof(_impl_.feature_sign_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_SegmentationParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 segmentation_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.segmentation_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 segmentation_update_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.segmentation_update_map_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 segmentation_temporal_update = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.segmentation_temporal_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 segmentation_update_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.segmentation_update_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 segmentation_abs_or_delta_update = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.segmentation_abs_or_delta_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 feature_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.feature_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes feature_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_feature_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 feature_sign = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.feature_sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_SegmentationParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.SegmentationParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 segmentation_enabled = 1;
  if (this->_internal_segmentation_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_segmentation_enabled(), target);
  }

  // uint32 segmentation_update_map = 2;
  if (this->_internal_segmentation_update_map() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_segmentation_update_map(), target);
  }

  // uint32 segmentation_temporal_update = 3;
  if (this->_internal_segmentation_temporal_update() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_segmentation_temporal_update(), target);
  }

  // uint32 segmentation_update_data = 4;
  if (this->_internal_segmentation_update_data() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_segmentation_update_data(), target);
  }

  // uint32 segmentation_abs_or_delta_update = 5;
  if (this->_internal_segmentation_abs_or_delta_update() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_segmentation_abs_or_delta_update(), target);
  }

  // uint32 feature_enabled = 6;
  if (this->_internal_feature_enabled() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_feature_enabled(), target);
  }

  // bytes feature_value = 7;
  if (!this->_internal_feature_value().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_feature_value(), target);
  }

  // uint32 feature_sign = 8;
  if (this->_internal_feature_sign() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_feature_sign(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.SegmentationParams)
  return target;
}

size_t UncompressedHeader_SegmentationParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.SegmentationParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes feature_value = 7;
  if (!this->_internal_feature_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_feature_value());
  }

  // uint32 segmentation_enabled = 1;
  if (this->_internal_segmentation_enabled() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_segmentation_enabled());
  }

  // uint32 segmentation_update_map = 2;
  if (this->_internal_segmentation_update_map() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_segmentation_update_map());
  }

  // uint32 segmentation_temporal_update = 3;
  if (this->_internal_segmentation_temporal_update() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_segmentation_temporal_update());
  }

  // uint32 segmentation_update_data = 4;
  if (this->_internal_segmentation_update_data() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_segmentation_update_data());
  }

  // uint32 segmentation_abs_or_delta_update = 5;
  if (this->_internal_segmentation_abs_or_delta_update() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_segmentation_abs_or_delta_update());
  }

  // uint32 feature_enabled = 6;
  if (this->_internal_feature_enabled() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_feature_enabled());
  }

  // uint32 feature_sign = 8;
  if (this->_internal_feature_sign() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_feature_sign());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_SegmentationParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_SegmentationParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_SegmentationParams::GetClassData() const { return &_class_data_; }


void UncompressedHeader_SegmentationParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_SegmentationParams*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_SegmentationParams&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.SegmentationParams)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_feature_value().empty()) {
    _this->_internal_set_feature_value(from._internal_feature_value());
  }
  if (from._internal_segmentation_enabled() != 0) {
    _this->_internal_set_segmentation_enabled(from._internal_segmentation_enabled());
  }
  if (from._internal_segmentation_update_map() != 0) {
    _this->_internal_set_segmentation_update_map(from._internal_segmentation_update_map());
  }
  if (from._internal_segmentation_temporal_update() != 0) {
    _this->_internal_set_segmentation_temporal_update(from._internal_segmentation_temporal_update());
  }
  if (from._internal_segmentation_update_data() != 0) {
    _this->_internal_set_segmentation_update_data(from._internal_segmentation_update_data());
  }
  if (from._internal_segmentation_abs_or_delta_update() != 0) {
    _this->_internal_set_segmentation_abs_or_delta_update(from._internal_segmentation_abs_or_delta_update());
  }
  if (from._internal_feature_enabled() != 0) {
    _this->_internal_set_feature_enabled(from._internal_feature_enabled());
  }
  if (from._internal_feature_sign() != 0) {
    _this->_internal_set_feature_sign(from._internal_feature_sign());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_SegmentationParams::CopyFrom(const UncompressedHeader_SegmentationParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.SegmentationParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_SegmentationParams::IsInitialized() const {
  return true;
}

void UncompressedHeader_SegmentationParams::InternalSwap(UncompressedHeader_SegmentationParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.feature_value_, lhs_arena,
      &other->_impl_.feature_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_SegmentationParams, _impl_.feature_sign_)
      + sizeof(UncompressedHeader_SegmentationParams::_impl_.feature_sign_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_SegmentationParams, _impl_.segmentation_enabled_)>(
          reinterpret_cast<char*>(&_impl_.segmentation_enabled_),
          reinterpret_cast<char*>(&other->_impl_.segmentation_enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_SegmentationParams::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[7]);
}
// ===================================================================

class UncompressedHeader_TileInfo::_Internal {
 public:
};

UncompressedHeader_TileInfo::UncompressedHeader_TileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader.TileInfo)
}
UncompressedHeader_TileInfo::UncompressedHeader_TileInfo(const UncompressedHeader_TileInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader_TileInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.increment_tile_cols_log2_){}
    , decltype(_impl_.tile_rows_log2_){}
    , decltype(_impl_.increment_tile_rows_log2_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.increment_tile_cols_log2_, &from._impl_.increment_tile_cols_log2_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.increment_tile_rows_log2_) -
    reinterpret_cast<char*>(&_impl_.increment_tile_cols_log2_)) + sizeof(_impl_.increment_tile_rows_log2_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader.TileInfo)
}

inline void UncompressedHeader_TileInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.increment_tile_cols_log2_){0u}
    , decltype(_impl_.tile_rows_log2_){0u}
    , decltype(_impl_.increment_tile_rows_log2_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader_TileInfo::~UncompressedHeader_TileInfo() {
  // @@protoc_insertion_point(destructor:UncompressedHeader.TileInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader_TileInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UncompressedHeader_TileInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader_TileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader.TileInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.increment_tile_cols_log2_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.increment_tile_rows_log2_) -
      reinterpret_cast<char*>(&_impl_.increment_tile_cols_log2_)) + sizeof(_impl_.increment_tile_rows_log2_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader_TileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 increment_tile_cols_log2 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.increment_tile_cols_log2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tile_rows_log2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.tile_rows_log2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 increment_tile_rows_Log2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.increment_tile_rows_log2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader_TileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader.TileInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 increment_tile_cols_log2 = 1;
  if (this->_internal_increment_tile_cols_log2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_increment_tile_cols_log2(), target);
  }

  // uint32 tile_rows_log2 = 2;
  if (this->_internal_tile_rows_log2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_tile_rows_log2(), target);
  }

  // uint32 increment_tile_rows_Log2 = 3;
  if (this->_internal_increment_tile_rows_log2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_increment_tile_rows_log2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader.TileInfo)
  return target;
}

size_t UncompressedHeader_TileInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader.TileInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 increment_tile_cols_log2 = 1;
  if (this->_internal_increment_tile_cols_log2() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_increment_tile_cols_log2());
  }

  // uint32 tile_rows_log2 = 2;
  if (this->_internal_tile_rows_log2() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tile_rows_log2());
  }

  // uint32 increment_tile_rows_Log2 = 3;
  if (this->_internal_increment_tile_rows_log2() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_increment_tile_rows_log2());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader_TileInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader_TileInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader_TileInfo::GetClassData() const { return &_class_data_; }


void UncompressedHeader_TileInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader_TileInfo*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader_TileInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader.TileInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_increment_tile_cols_log2() != 0) {
    _this->_internal_set_increment_tile_cols_log2(from._internal_increment_tile_cols_log2());
  }
  if (from._internal_tile_rows_log2() != 0) {
    _this->_internal_set_tile_rows_log2(from._internal_tile_rows_log2());
  }
  if (from._internal_increment_tile_rows_log2() != 0) {
    _this->_internal_set_increment_tile_rows_log2(from._internal_increment_tile_rows_log2());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader_TileInfo::CopyFrom(const UncompressedHeader_TileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader.TileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader_TileInfo::IsInitialized() const {
  return true;
}

void UncompressedHeader_TileInfo::InternalSwap(UncompressedHeader_TileInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader_TileInfo, _impl_.increment_tile_rows_log2_)
      + sizeof(UncompressedHeader_TileInfo::_impl_.increment_tile_rows_log2_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader_TileInfo, _impl_.increment_tile_cols_log2_)>(
          reinterpret_cast<char*>(&_impl_.increment_tile_cols_log2_),
          reinterpret_cast<char*>(&other->_impl_.increment_tile_cols_log2_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader_TileInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[8]);
}
// ===================================================================

class UncompressedHeader::_Internal {
 public:
  static const ::UncompressedHeader_ColorConfig& color_config(const UncompressedHeader* msg);
  static const ::UncompressedHeader_FrameSize& frame_size(const UncompressedHeader* msg);
  static const ::UncompressedHeader_RenderSize& render_size(const UncompressedHeader* msg);
  static const ::UncompressedHeader_ReadInterpolationFilter& read_interpolation_filter(const UncompressedHeader* msg);
  static const ::UncompressedHeader_LoopFilterParams& loop_filter_params(const UncompressedHeader* msg);
  static const ::UncompressedHeader_QuantizationParams& quantization_params(const UncompressedHeader* msg);
  static const ::UncompressedHeader_SegmentationParams& segmentation_params(const UncompressedHeader* msg);
  static const ::UncompressedHeader_TileInfo& tile_info(const UncompressedHeader* msg);
};

const ::UncompressedHeader_ColorConfig&
UncompressedHeader::_Internal::color_config(const UncompressedHeader* msg) {
  return *msg->_impl_.color_config_;
}
const ::UncompressedHeader_FrameSize&
UncompressedHeader::_Internal::frame_size(const UncompressedHeader* msg) {
  return *msg->_impl_.frame_size_;
}
const ::UncompressedHeader_RenderSize&
UncompressedHeader::_Internal::render_size(const UncompressedHeader* msg) {
  return *msg->_impl_.render_size_;
}
const ::UncompressedHeader_ReadInterpolationFilter&
UncompressedHeader::_Internal::read_interpolation_filter(const UncompressedHeader* msg) {
  return *msg->_impl_.read_interpolation_filter_;
}
const ::UncompressedHeader_LoopFilterParams&
UncompressedHeader::_Internal::loop_filter_params(const UncompressedHeader* msg) {
  return *msg->_impl_.loop_filter_params_;
}
const ::UncompressedHeader_QuantizationParams&
UncompressedHeader::_Internal::quantization_params(const UncompressedHeader* msg) {
  return *msg->_impl_.quantization_params_;
}
const ::UncompressedHeader_SegmentationParams&
UncompressedHeader::_Internal::segmentation_params(const UncompressedHeader* msg) {
  return *msg->_impl_.segmentation_params_;
}
const ::UncompressedHeader_TileInfo&
UncompressedHeader::_Internal::tile_info(const UncompressedHeader* msg) {
  return *msg->_impl_.tile_info_;
}
UncompressedHeader::UncompressedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UncompressedHeader)
}
UncompressedHeader::UncompressedHeader(const UncompressedHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UncompressedHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_config_){nullptr}
    , decltype(_impl_.frame_size_){nullptr}
    , decltype(_impl_.render_size_){nullptr}
    , decltype(_impl_.read_interpolation_filter_){nullptr}
    , decltype(_impl_.loop_filter_params_){nullptr}
    , decltype(_impl_.quantization_params_){nullptr}
    , decltype(_impl_.segmentation_params_){nullptr}
    , decltype(_impl_.tile_info_){nullptr}
    , decltype(_impl_.marker_){}
    , decltype(_impl_.profile_){}
    , decltype(_impl_.reserved_zero_){}
    , decltype(_impl_.show_existing_frame_){}
    , decltype(_impl_.frame_to_show_map_idx_){}
    , decltype(_impl_.frame_type_){}
    , decltype(_impl_.show_frame_){}
    , decltype(_impl_.error_resilient_mode_){}
    , decltype(_impl_.frame_sync_code_){}
    , decltype(_impl_.frame_size_found_ref_){}
    , decltype(_impl_.intra_only_){}
    , decltype(_impl_.reset_frame_context_){}
    , decltype(_impl_.refresh_frame_flags_){}
    , decltype(_impl_.ref_frame_idx_){}
    , decltype(_impl_.ref_frame_sign_bias_){}
    , decltype(_impl_.allow_high_precision_mv_){}
    , decltype(_impl_.frame_parallel_decoding_mode_){}
    , decltype(_impl_.frame_context_idx_){}
    , decltype(_impl_.header_size_in_bytes_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color_config()) {
    _this->_impl_.color_config_ = new ::UncompressedHeader_ColorConfig(*from._impl_.color_config_);
  }
  if (from._internal_has_frame_size()) {
    _this->_impl_.frame_size_ = new ::UncompressedHeader_FrameSize(*from._impl_.frame_size_);
  }
  if (from._internal_has_render_size()) {
    _this->_impl_.render_size_ = new ::UncompressedHeader_RenderSize(*from._impl_.render_size_);
  }
  if (from._internal_has_read_interpolation_filter()) {
    _this->_impl_.read_interpolation_filter_ = new ::UncompressedHeader_ReadInterpolationFilter(*from._impl_.read_interpolation_filter_);
  }
  if (from._internal_has_loop_filter_params()) {
    _this->_impl_.loop_filter_params_ = new ::UncompressedHeader_LoopFilterParams(*from._impl_.loop_filter_params_);
  }
  if (from._internal_has_quantization_params()) {
    _this->_impl_.quantization_params_ = new ::UncompressedHeader_QuantizationParams(*from._impl_.quantization_params_);
  }
  if (from._internal_has_segmentation_params()) {
    _this->_impl_.segmentation_params_ = new ::UncompressedHeader_SegmentationParams(*from._impl_.segmentation_params_);
  }
  if (from._internal_has_tile_info()) {
    _this->_impl_.tile_info_ = new ::UncompressedHeader_TileInfo(*from._impl_.tile_info_);
  }
  ::memcpy(&_impl_.marker_, &from._impl_.marker_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.header_size_in_bytes_) -
    reinterpret_cast<char*>(&_impl_.marker_)) + sizeof(_impl_.header_size_in_bytes_));
  // @@protoc_insertion_point(copy_constructor:UncompressedHeader)
}

inline void UncompressedHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_config_){nullptr}
    , decltype(_impl_.frame_size_){nullptr}
    , decltype(_impl_.render_size_){nullptr}
    , decltype(_impl_.read_interpolation_filter_){nullptr}
    , decltype(_impl_.loop_filter_params_){nullptr}
    , decltype(_impl_.quantization_params_){nullptr}
    , decltype(_impl_.segmentation_params_){nullptr}
    , decltype(_impl_.tile_info_){nullptr}
    , decltype(_impl_.marker_){0u}
    , decltype(_impl_.profile_){0u}
    , decltype(_impl_.reserved_zero_){0u}
    , decltype(_impl_.show_existing_frame_){0u}
    , decltype(_impl_.frame_to_show_map_idx_){0u}
    , decltype(_impl_.frame_type_){0u}
    , decltype(_impl_.show_frame_){0u}
    , decltype(_impl_.error_resilient_mode_){0u}
    , decltype(_impl_.frame_sync_code_){0u}
    , decltype(_impl_.frame_size_found_ref_){0u}
    , decltype(_impl_.intra_only_){0u}
    , decltype(_impl_.reset_frame_context_){0u}
    , decltype(_impl_.refresh_frame_flags_){0u}
    , decltype(_impl_.ref_frame_idx_){0u}
    , decltype(_impl_.ref_frame_sign_bias_){0u}
    , decltype(_impl_.allow_high_precision_mv_){0u}
    , decltype(_impl_.frame_parallel_decoding_mode_){0u}
    , decltype(_impl_.frame_context_idx_){0u}
    , decltype(_impl_.header_size_in_bytes_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UncompressedHeader::~UncompressedHeader() {
  // @@protoc_insertion_point(destructor:UncompressedHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UncompressedHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_config_;
  if (this != internal_default_instance()) delete _impl_.frame_size_;
  if (this != internal_default_instance()) delete _impl_.render_size_;
  if (this != internal_default_instance()) delete _impl_.read_interpolation_filter_;
  if (this != internal_default_instance()) delete _impl_.loop_filter_params_;
  if (this != internal_default_instance()) delete _impl_.quantization_params_;
  if (this != internal_default_instance()) delete _impl_.segmentation_params_;
  if (this != internal_default_instance()) delete _impl_.tile_info_;
}

void UncompressedHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UncompressedHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:UncompressedHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.color_config_ != nullptr) {
    delete _impl_.color_config_;
  }
  _impl_.color_config_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.frame_size_ != nullptr) {
    delete _impl_.frame_size_;
  }
  _impl_.frame_size_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.render_size_ != nullptr) {
    delete _impl_.render_size_;
  }
  _impl_.render_size_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.read_interpolation_filter_ != nullptr) {
    delete _impl_.read_interpolation_filter_;
  }
  _impl_.read_interpolation_filter_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_params_ != nullptr) {
    delete _impl_.loop_filter_params_;
  }
  _impl_.loop_filter_params_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.quantization_params_ != nullptr) {
    delete _impl_.quantization_params_;
  }
  _impl_.quantization_params_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.segmentation_params_ != nullptr) {
    delete _impl_.segmentation_params_;
  }
  _impl_.segmentation_params_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.tile_info_ != nullptr) {
    delete _impl_.tile_info_;
  }
  _impl_.tile_info_ = nullptr;
  ::memset(&_impl_.marker_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.header_size_in_bytes_) -
      reinterpret_cast<char*>(&_impl_.marker_)) + sizeof(_impl_.header_size_in_bytes_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UncompressedHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 marker = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.marker_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 profile = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.profile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reserved_zero = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.reserved_zero_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 show_existing_frame = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.show_existing_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_to_show_map_idx = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.frame_to_show_map_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.frame_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 show_frame = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.show_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 error_resilient_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.error_resilient_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_sync_code = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.frame_sync_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.ColorConfig color_config = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_color_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_size_found_ref = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.frame_size_found_ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.FrameSize frame_size = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.RenderSize render_size = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_render_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 intra_only = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.intra_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reset_frame_context = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.reset_frame_context_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 refresh_frame_flags = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.refresh_frame_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ref_frame_idx = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.ref_frame_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ref_frame_sign_bias = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.ref_frame_sign_bias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 allow_high_precision_mv = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.allow_high_precision_mv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_read_interpolation_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_parallel_decoding_mode = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.frame_parallel_decoding_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_context_idx = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.frame_context_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.LoopFilterParams loop_filter_params = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_loop_filter_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.QuantizationParams quantization_params = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_quantization_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.SegmentationParams segmentation_params = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_segmentation_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .UncompressedHeader.TileInfo tile_info = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_tile_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 header_size_in_bytes = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _impl_.header_size_in_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UncompressedHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UncompressedHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 marker = 1;
  if (this->_internal_marker() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_marker(), target);
  }

  // uint32 profile = 2;
  if (this->_internal_profile() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_profile(), target);
  }

  // uint32 reserved_zero = 3;
  if (this->_internal_reserved_zero() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_reserved_zero(), target);
  }

  // uint32 show_existing_frame = 4;
  if (this->_internal_show_existing_frame() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_show_existing_frame(), target);
  }

  // uint32 frame_to_show_map_idx = 5;
  if (this->_internal_frame_to_show_map_idx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_frame_to_show_map_idx(), target);
  }

  // uint32 frame_type = 6;
  if (this->_internal_frame_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_frame_type(), target);
  }

  // uint32 show_frame = 7;
  if (this->_internal_show_frame() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_show_frame(), target);
  }

  // uint32 error_resilient_mode = 8;
  if (this->_internal_error_resilient_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_error_resilient_mode(), target);
  }

  // uint32 frame_sync_code = 9;
  if (this->_internal_frame_sync_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_frame_sync_code(), target);
  }

  // .UncompressedHeader.ColorConfig color_config = 10;
  if (this->_internal_has_color_config()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::color_config(this),
        _Internal::color_config(this).GetCachedSize(), target, stream);
  }

  // uint32 frame_size_found_ref = 11;
  if (this->_internal_frame_size_found_ref() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_frame_size_found_ref(), target);
  }

  // .UncompressedHeader.FrameSize frame_size = 12;
  if (this->_internal_has_frame_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::frame_size(this),
        _Internal::frame_size(this).GetCachedSize(), target, stream);
  }

  // .UncompressedHeader.RenderSize render_size = 13;
  if (this->_internal_has_render_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::render_size(this),
        _Internal::render_size(this).GetCachedSize(), target, stream);
  }

  // uint32 intra_only = 14;
  if (this->_internal_intra_only() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_intra_only(), target);
  }

  // uint32 reset_frame_context = 15;
  if (this->_internal_reset_frame_context() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_reset_frame_context(), target);
  }

  // uint32 refresh_frame_flags = 16;
  if (this->_internal_refresh_frame_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_refresh_frame_flags(), target);
  }

  // uint32 ref_frame_idx = 17;
  if (this->_internal_ref_frame_idx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_ref_frame_idx(), target);
  }

  // uint32 ref_frame_sign_bias = 18;
  if (this->_internal_ref_frame_sign_bias() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_ref_frame_sign_bias(), target);
  }

  // uint32 allow_high_precision_mv = 19;
  if (this->_internal_allow_high_precision_mv() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_allow_high_precision_mv(), target);
  }

  // .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
  if (this->_internal_has_read_interpolation_filter()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::read_interpolation_filter(this),
        _Internal::read_interpolation_filter(this).GetCachedSize(), target, stream);
  }

  // uint32 frame_parallel_decoding_mode = 21;
  if (this->_internal_frame_parallel_decoding_mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_frame_parallel_decoding_mode(), target);
  }

  // uint32 frame_context_idx = 22;
  if (this->_internal_frame_context_idx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_frame_context_idx(), target);
  }

  // .UncompressedHeader.LoopFilterParams loop_filter_params = 23;
  if (this->_internal_has_loop_filter_params()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::loop_filter_params(this),
        _Internal::loop_filter_params(this).GetCachedSize(), target, stream);
  }

  // .UncompressedHeader.QuantizationParams quantization_params = 24;
  if (this->_internal_has_quantization_params()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::quantization_params(this),
        _Internal::quantization_params(this).GetCachedSize(), target, stream);
  }

  // .UncompressedHeader.SegmentationParams segmentation_params = 25;
  if (this->_internal_has_segmentation_params()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::segmentation_params(this),
        _Internal::segmentation_params(this).GetCachedSize(), target, stream);
  }

  // .UncompressedHeader.TileInfo tile_info = 26;
  if (this->_internal_has_tile_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::tile_info(this),
        _Internal::tile_info(this).GetCachedSize(), target, stream);
  }

  // uint32 header_size_in_bytes = 27;
  if (this->_internal_header_size_in_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_header_size_in_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UncompressedHeader)
  return target;
}

size_t UncompressedHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UncompressedHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .UncompressedHeader.ColorConfig color_config = 10;
  if (this->_internal_has_color_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.color_config_);
  }

  // .UncompressedHeader.FrameSize frame_size = 12;
  if (this->_internal_has_frame_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.frame_size_);
  }

  // .UncompressedHeader.RenderSize render_size = 13;
  if (this->_internal_has_render_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.render_size_);
  }

  // .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
  if (this->_internal_has_read_interpolation_filter()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.read_interpolation_filter_);
  }

  // .UncompressedHeader.LoopFilterParams loop_filter_params = 23;
  if (this->_internal_has_loop_filter_params()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loop_filter_params_);
  }

  // .UncompressedHeader.QuantizationParams quantization_params = 24;
  if (this->_internal_has_quantization_params()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.quantization_params_);
  }

  // .UncompressedHeader.SegmentationParams segmentation_params = 25;
  if (this->_internal_has_segmentation_params()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.segmentation_params_);
  }

  // .UncompressedHeader.TileInfo tile_info = 26;
  if (this->_internal_has_tile_info()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tile_info_);
  }

  // uint32 marker = 1;
  if (this->_internal_marker() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_marker());
  }

  // uint32 profile = 2;
  if (this->_internal_profile() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_profile());
  }

  // uint32 reserved_zero = 3;
  if (this->_internal_reserved_zero() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reserved_zero());
  }

  // uint32 show_existing_frame = 4;
  if (this->_internal_show_existing_frame() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_show_existing_frame());
  }

  // uint32 frame_to_show_map_idx = 5;
  if (this->_internal_frame_to_show_map_idx() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_to_show_map_idx());
  }

  // uint32 frame_type = 6;
  if (this->_internal_frame_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_type());
  }

  // uint32 show_frame = 7;
  if (this->_internal_show_frame() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_show_frame());
  }

  // uint32 error_resilient_mode = 8;
  if (this->_internal_error_resilient_mode() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_error_resilient_mode());
  }

  // uint32 frame_sync_code = 9;
  if (this->_internal_frame_sync_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_sync_code());
  }

  // uint32 frame_size_found_ref = 11;
  if (this->_internal_frame_size_found_ref() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_size_found_ref());
  }

  // uint32 intra_only = 14;
  if (this->_internal_intra_only() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_intra_only());
  }

  // uint32 reset_frame_context = 15;
  if (this->_internal_reset_frame_context() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reset_frame_context());
  }

  // uint32 refresh_frame_flags = 16;
  if (this->_internal_refresh_frame_flags() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_refresh_frame_flags());
  }

  // uint32 ref_frame_idx = 17;
  if (this->_internal_ref_frame_idx() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_ref_frame_idx());
  }

  // uint32 ref_frame_sign_bias = 18;
  if (this->_internal_ref_frame_sign_bias() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_ref_frame_sign_bias());
  }

  // uint32 allow_high_precision_mv = 19;
  if (this->_internal_allow_high_precision_mv() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_allow_high_precision_mv());
  }

  // uint32 frame_parallel_decoding_mode = 21;
  if (this->_internal_frame_parallel_decoding_mode() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_frame_parallel_decoding_mode());
  }

  // uint32 frame_context_idx = 22;
  if (this->_internal_frame_context_idx() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_frame_context_idx());
  }

  // uint32 header_size_in_bytes = 27;
  if (this->_internal_header_size_in_bytes() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_header_size_in_bytes());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UncompressedHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UncompressedHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UncompressedHeader::GetClassData() const { return &_class_data_; }


void UncompressedHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UncompressedHeader*>(&to_msg);
  auto& from = static_cast<const UncompressedHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UncompressedHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_color_config()) {
    _this->_internal_mutable_color_config()->::UncompressedHeader_ColorConfig::MergeFrom(
        from._internal_color_config());
  }
  if (from._internal_has_frame_size()) {
    _this->_internal_mutable_frame_size()->::UncompressedHeader_FrameSize::MergeFrom(
        from._internal_frame_size());
  }
  if (from._internal_has_render_size()) {
    _this->_internal_mutable_render_size()->::UncompressedHeader_RenderSize::MergeFrom(
        from._internal_render_size());
  }
  if (from._internal_has_read_interpolation_filter()) {
    _this->_internal_mutable_read_interpolation_filter()->::UncompressedHeader_ReadInterpolationFilter::MergeFrom(
        from._internal_read_interpolation_filter());
  }
  if (from._internal_has_loop_filter_params()) {
    _this->_internal_mutable_loop_filter_params()->::UncompressedHeader_LoopFilterParams::MergeFrom(
        from._internal_loop_filter_params());
  }
  if (from._internal_has_quantization_params()) {
    _this->_internal_mutable_quantization_params()->::UncompressedHeader_QuantizationParams::MergeFrom(
        from._internal_quantization_params());
  }
  if (from._internal_has_segmentation_params()) {
    _this->_internal_mutable_segmentation_params()->::UncompressedHeader_SegmentationParams::MergeFrom(
        from._internal_segmentation_params());
  }
  if (from._internal_has_tile_info()) {
    _this->_internal_mutable_tile_info()->::UncompressedHeader_TileInfo::MergeFrom(
        from._internal_tile_info());
  }
  if (from._internal_marker() != 0) {
    _this->_internal_set_marker(from._internal_marker());
  }
  if (from._internal_profile() != 0) {
    _this->_internal_set_profile(from._internal_profile());
  }
  if (from._internal_reserved_zero() != 0) {
    _this->_internal_set_reserved_zero(from._internal_reserved_zero());
  }
  if (from._internal_show_existing_frame() != 0) {
    _this->_internal_set_show_existing_frame(from._internal_show_existing_frame());
  }
  if (from._internal_frame_to_show_map_idx() != 0) {
    _this->_internal_set_frame_to_show_map_idx(from._internal_frame_to_show_map_idx());
  }
  if (from._internal_frame_type() != 0) {
    _this->_internal_set_frame_type(from._internal_frame_type());
  }
  if (from._internal_show_frame() != 0) {
    _this->_internal_set_show_frame(from._internal_show_frame());
  }
  if (from._internal_error_resilient_mode() != 0) {
    _this->_internal_set_error_resilient_mode(from._internal_error_resilient_mode());
  }
  if (from._internal_frame_sync_code() != 0) {
    _this->_internal_set_frame_sync_code(from._internal_frame_sync_code());
  }
  if (from._internal_frame_size_found_ref() != 0) {
    _this->_internal_set_frame_size_found_ref(from._internal_frame_size_found_ref());
  }
  if (from._internal_intra_only() != 0) {
    _this->_internal_set_intra_only(from._internal_intra_only());
  }
  if (from._internal_reset_frame_context() != 0) {
    _this->_internal_set_reset_frame_context(from._internal_reset_frame_context());
  }
  if (from._internal_refresh_frame_flags() != 0) {
    _this->_internal_set_refresh_frame_flags(from._internal_refresh_frame_flags());
  }
  if (from._internal_ref_frame_idx() != 0) {
    _this->_internal_set_ref_frame_idx(from._internal_ref_frame_idx());
  }
  if (from._internal_ref_frame_sign_bias() != 0) {
    _this->_internal_set_ref_frame_sign_bias(from._internal_ref_frame_sign_bias());
  }
  if (from._internal_allow_high_precision_mv() != 0) {
    _this->_internal_set_allow_high_precision_mv(from._internal_allow_high_precision_mv());
  }
  if (from._internal_frame_parallel_decoding_mode() != 0) {
    _this->_internal_set_frame_parallel_decoding_mode(from._internal_frame_parallel_decoding_mode());
  }
  if (from._internal_frame_context_idx() != 0) {
    _this->_internal_set_frame_context_idx(from._internal_frame_context_idx());
  }
  if (from._internal_header_size_in_bytes() != 0) {
    _this->_internal_set_header_size_in_bytes(from._internal_header_size_in_bytes());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UncompressedHeader::CopyFrom(const UncompressedHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UncompressedHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UncompressedHeader::IsInitialized() const {
  return true;
}

void UncompressedHeader::InternalSwap(UncompressedHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UncompressedHeader, _impl_.header_size_in_bytes_)
      + sizeof(UncompressedHeader::_impl_.header_size_in_bytes_)
      - PROTOBUF_FIELD_OFFSET(UncompressedHeader, _impl_.color_config_)>(
          reinterpret_cast<char*>(&_impl_.color_config_),
          reinterpret_cast<char*>(&other->_impl_.color_config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UncompressedHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[9]);
}
// ===================================================================

class CompressedHeader::_Internal {
 public:
};

CompressedHeader::CompressedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CompressedHeader)
}
CompressedHeader::CompressedHeader(const CompressedHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompressedHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.read_tx_mode_){}
    , decltype(_impl_.tx_mode_probs_){}
    , decltype(_impl_.read_coef_probs_){}
    , decltype(_impl_.read_skip_prob_){}
    , decltype(_impl_.read_inter_mode_probs_){}
    , decltype(_impl_.read_interp_filter_probs_){}
    , decltype(_impl_.read_is_inter_probs_){}
    , decltype(_impl_.frame_reference_mode_){}
    , decltype(_impl_.frame_reference_mode_probs_){}
    , decltype(_impl_.read_y_mode_probs_){}
    , decltype(_impl_.read_partition_probs_){}
    , decltype(_impl_.mv_probs_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.read_tx_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_tx_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_tx_mode().empty()) {
    _this->_impl_.read_tx_mode_.Set(from._internal_read_tx_mode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tx_mode_probs().empty()) {
    _this->_impl_.tx_mode_probs_.Set(from._internal_tx_mode_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_coef_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_coef_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_coef_probs().empty()) {
    _this->_impl_.read_coef_probs_.Set(from._internal_read_coef_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_skip_prob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_skip_prob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_skip_prob().empty()) {
    _this->_impl_.read_skip_prob_.Set(from._internal_read_skip_prob(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_inter_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_inter_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_inter_mode_probs().empty()) {
    _this->_impl_.read_inter_mode_probs_.Set(from._internal_read_inter_mode_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_interp_filter_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_interp_filter_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_interp_filter_probs().empty()) {
    _this->_impl_.read_interp_filter_probs_.Set(from._internal_read_interp_filter_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_is_inter_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_is_inter_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_is_inter_probs().empty()) {
    _this->_impl_.read_is_inter_probs_.Set(from._internal_read_is_inter_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.frame_reference_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_reference_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_frame_reference_mode().empty()) {
    _this->_impl_.frame_reference_mode_.Set(from._internal_frame_reference_mode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.frame_reference_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_reference_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_frame_reference_mode_probs().empty()) {
    _this->_impl_.frame_reference_mode_probs_.Set(from._internal_frame_reference_mode_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_y_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_y_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_y_mode_probs().empty()) {
    _this->_impl_.read_y_mode_probs_.Set(from._internal_read_y_mode_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_partition_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_partition_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_partition_probs().empty()) {
    _this->_impl_.read_partition_probs_.Set(from._internal_read_partition_probs(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mv_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mv_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mv_probs().empty()) {
    _this->_impl_.mv_probs_.Set(from._internal_mv_probs(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CompressedHeader)
}

inline void CompressedHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.read_tx_mode_){}
    , decltype(_impl_.tx_mode_probs_){}
    , decltype(_impl_.read_coef_probs_){}
    , decltype(_impl_.read_skip_prob_){}
    , decltype(_impl_.read_inter_mode_probs_){}
    , decltype(_impl_.read_interp_filter_probs_){}
    , decltype(_impl_.read_is_inter_probs_){}
    , decltype(_impl_.frame_reference_mode_){}
    , decltype(_impl_.frame_reference_mode_probs_){}
    , decltype(_impl_.read_y_mode_probs_){}
    , decltype(_impl_.read_partition_probs_){}
    , decltype(_impl_.mv_probs_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.read_tx_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_tx_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_coef_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_coef_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_skip_prob_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_skip_prob_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_inter_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_inter_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_interp_filter_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_interp_filter_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_is_inter_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_is_inter_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.frame_reference_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_reference_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.frame_reference_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_reference_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_y_mode_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_y_mode_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_partition_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_partition_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mv_probs_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mv_probs_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CompressedHeader::~CompressedHeader() {
  // @@protoc_insertion_point(destructor:CompressedHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompressedHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.read_tx_mode_.Destroy();
  _impl_.tx_mode_probs_.Destroy();
  _impl_.read_coef_probs_.Destroy();
  _impl_.read_skip_prob_.Destroy();
  _impl_.read_inter_mode_probs_.Destroy();
  _impl_.read_interp_filter_probs_.Destroy();
  _impl_.read_is_inter_probs_.Destroy();
  _impl_.frame_reference_mode_.Destroy();
  _impl_.frame_reference_mode_probs_.Destroy();
  _impl_.read_y_mode_probs_.Destroy();
  _impl_.read_partition_probs_.Destroy();
  _impl_.mv_probs_.Destroy();
}

void CompressedHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompressedHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CompressedHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.read_tx_mode_.ClearToEmpty();
  _impl_.tx_mode_probs_.ClearToEmpty();
  _impl_.read_coef_probs_.ClearToEmpty();
  _impl_.read_skip_prob_.ClearToEmpty();
  _impl_.read_inter_mode_probs_.ClearToEmpty();
  _impl_.read_interp_filter_probs_.ClearToEmpty();
  _impl_.read_is_inter_probs_.ClearToEmpty();
  _impl_.frame_reference_mode_.ClearToEmpty();
  _impl_.frame_reference_mode_probs_.ClearToEmpty();
  _impl_.read_y_mode_probs_.ClearToEmpty();
  _impl_.read_partition_probs_.ClearToEmpty();
  _impl_.mv_probs_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompressedHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes read_tx_mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_read_tx_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes tx_mode_probs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tx_mode_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_coef_probs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_read_coef_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_skip_prob = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_read_skip_prob();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_inter_mode_probs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_read_inter_mode_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_interp_filter_probs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_read_interp_filter_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_is_inter_probs = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_read_is_inter_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes frame_reference_mode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_frame_reference_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes frame_reference_mode_probs = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_frame_reference_mode_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_y_mode_probs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_read_y_mode_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes read_partition_probs = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_read_partition_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes mv_probs = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_mv_probs();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompressedHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CompressedHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes read_tx_mode = 1;
  if (!this->_internal_read_tx_mode().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_read_tx_mode(), target);
  }

  // bytes tx_mode_probs = 2;
  if (!this->_internal_tx_mode_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_tx_mode_probs(), target);
  }

  // bytes read_coef_probs = 3;
  if (!this->_internal_read_coef_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_read_coef_probs(), target);
  }

  // bytes read_skip_prob = 4;
  if (!this->_internal_read_skip_prob().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_read_skip_prob(), target);
  }

  // bytes read_inter_mode_probs = 5;
  if (!this->_internal_read_inter_mode_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_read_inter_mode_probs(), target);
  }

  // bytes read_interp_filter_probs = 6;
  if (!this->_internal_read_interp_filter_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_read_interp_filter_probs(), target);
  }

  // bytes read_is_inter_probs = 7;
  if (!this->_internal_read_is_inter_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_read_is_inter_probs(), target);
  }

  // bytes frame_reference_mode = 8;
  if (!this->_internal_frame_reference_mode().empty()) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_frame_reference_mode(), target);
  }

  // bytes frame_reference_mode_probs = 9;
  if (!this->_internal_frame_reference_mode_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_frame_reference_mode_probs(), target);
  }

  // bytes read_y_mode_probs = 10;
  if (!this->_internal_read_y_mode_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_read_y_mode_probs(), target);
  }

  // bytes read_partition_probs = 11;
  if (!this->_internal_read_partition_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_read_partition_probs(), target);
  }

  // bytes mv_probs = 12;
  if (!this->_internal_mv_probs().empty()) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_mv_probs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CompressedHeader)
  return target;
}

size_t CompressedHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CompressedHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes read_tx_mode = 1;
  if (!this->_internal_read_tx_mode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_tx_mode());
  }

  // bytes tx_mode_probs = 2;
  if (!this->_internal_tx_mode_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_mode_probs());
  }

  // bytes read_coef_probs = 3;
  if (!this->_internal_read_coef_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_coef_probs());
  }

  // bytes read_skip_prob = 4;
  if (!this->_internal_read_skip_prob().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_skip_prob());
  }

  // bytes read_inter_mode_probs = 5;
  if (!this->_internal_read_inter_mode_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_inter_mode_probs());
  }

  // bytes read_interp_filter_probs = 6;
  if (!this->_internal_read_interp_filter_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_interp_filter_probs());
  }

  // bytes read_is_inter_probs = 7;
  if (!this->_internal_read_is_inter_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_is_inter_probs());
  }

  // bytes frame_reference_mode = 8;
  if (!this->_internal_frame_reference_mode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_frame_reference_mode());
  }

  // bytes frame_reference_mode_probs = 9;
  if (!this->_internal_frame_reference_mode_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_frame_reference_mode_probs());
  }

  // bytes read_y_mode_probs = 10;
  if (!this->_internal_read_y_mode_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_y_mode_probs());
  }

  // bytes read_partition_probs = 11;
  if (!this->_internal_read_partition_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_read_partition_probs());
  }

  // bytes mv_probs = 12;
  if (!this->_internal_mv_probs().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_mv_probs());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompressedHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompressedHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompressedHeader::GetClassData() const { return &_class_data_; }


void CompressedHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompressedHeader*>(&to_msg);
  auto& from = static_cast<const CompressedHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CompressedHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_read_tx_mode().empty()) {
    _this->_internal_set_read_tx_mode(from._internal_read_tx_mode());
  }
  if (!from._internal_tx_mode_probs().empty()) {
    _this->_internal_set_tx_mode_probs(from._internal_tx_mode_probs());
  }
  if (!from._internal_read_coef_probs().empty()) {
    _this->_internal_set_read_coef_probs(from._internal_read_coef_probs());
  }
  if (!from._internal_read_skip_prob().empty()) {
    _this->_internal_set_read_skip_prob(from._internal_read_skip_prob());
  }
  if (!from._internal_read_inter_mode_probs().empty()) {
    _this->_internal_set_read_inter_mode_probs(from._internal_read_inter_mode_probs());
  }
  if (!from._internal_read_interp_filter_probs().empty()) {
    _this->_internal_set_read_interp_filter_probs(from._internal_read_interp_filter_probs());
  }
  if (!from._internal_read_is_inter_probs().empty()) {
    _this->_internal_set_read_is_inter_probs(from._internal_read_is_inter_probs());
  }
  if (!from._internal_frame_reference_mode().empty()) {
    _this->_internal_set_frame_reference_mode(from._internal_frame_reference_mode());
  }
  if (!from._internal_frame_reference_mode_probs().empty()) {
    _this->_internal_set_frame_reference_mode_probs(from._internal_frame_reference_mode_probs());
  }
  if (!from._internal_read_y_mode_probs().empty()) {
    _this->_internal_set_read_y_mode_probs(from._internal_read_y_mode_probs());
  }
  if (!from._internal_read_partition_probs().empty()) {
    _this->_internal_set_read_partition_probs(from._internal_read_partition_probs());
  }
  if (!from._internal_mv_probs().empty()) {
    _this->_internal_set_mv_probs(from._internal_mv_probs());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompressedHeader::CopyFrom(const CompressedHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CompressedHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompressedHeader::IsInitialized() const {
  return true;
}

void CompressedHeader::InternalSwap(CompressedHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_tx_mode_, lhs_arena,
      &other->_impl_.read_tx_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_mode_probs_, lhs_arena,
      &other->_impl_.tx_mode_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_coef_probs_, lhs_arena,
      &other->_impl_.read_coef_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_skip_prob_, lhs_arena,
      &other->_impl_.read_skip_prob_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_inter_mode_probs_, lhs_arena,
      &other->_impl_.read_inter_mode_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_interp_filter_probs_, lhs_arena,
      &other->_impl_.read_interp_filter_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_is_inter_probs_, lhs_arena,
      &other->_impl_.read_is_inter_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.frame_reference_mode_, lhs_arena,
      &other->_impl_.frame_reference_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.frame_reference_mode_probs_, lhs_arena,
      &other->_impl_.frame_reference_mode_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_y_mode_probs_, lhs_arena,
      &other->_impl_.read_y_mode_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_partition_probs_, lhs_arena,
      &other->_impl_.read_partition_probs_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mv_probs_, lhs_arena,
      &other->_impl_.mv_probs_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CompressedHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[10]);
}
// ===================================================================

class Block_IntraFrameModeInfo::_Internal {
 public:
};

Block_IntraFrameModeInfo::Block_IntraFrameModeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Block.IntraFrameModeInfo)
}
Block_IntraFrameModeInfo::Block_IntraFrameModeInfo(const Block_IntraFrameModeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Block_IntraFrameModeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){}
    , decltype(_impl_.skip_){}
    , decltype(_impl_.tx_size_){}
    , decltype(_impl_.default_intra_mode_){}
    , decltype(_impl_.default_uv_mode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.segment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_segment_id().empty()) {
    _this->_impl_.segment_id_.Set(from._internal_segment_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.skip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.skip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_skip().empty()) {
    _this->_impl_.skip_.Set(from._internal_skip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tx_size().empty()) {
    _this->_impl_.tx_size_.Set(from._internal_tx_size(), 
      _this->GetArenaForAllocation());
  }
  _impl_.default_intra_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_intra_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_intra_mode().empty()) {
    _this->_impl_.default_intra_mode_.Set(from._internal_default_intra_mode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.default_uv_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_uv_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_default_uv_mode().empty()) {
    _this->_impl_.default_uv_mode_.Set(from._internal_default_uv_mode(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Block.IntraFrameModeInfo)
}

inline void Block_IntraFrameModeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){}
    , decltype(_impl_.skip_){}
    , decltype(_impl_.tx_size_){}
    , decltype(_impl_.default_intra_mode_){}
    , decltype(_impl_.default_uv_mode_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.segment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.skip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.skip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_intra_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_intra_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_uv_mode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_uv_mode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Block_IntraFrameModeInfo::~Block_IntraFrameModeInfo() {
  // @@protoc_insertion_point(destructor:Block.IntraFrameModeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Block_IntraFrameModeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.segment_id_.Destroy();
  _impl_.skip_.Destroy();
  _impl_.tx_size_.Destroy();
  _impl_.default_intra_mode_.Destroy();
  _impl_.default_uv_mode_.Destroy();
}

void Block_IntraFrameModeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Block_IntraFrameModeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Block.IntraFrameModeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.segment_id_.ClearToEmpty();
  _impl_.skip_.ClearToEmpty();
  _impl_.tx_size_.ClearToEmpty();
  _impl_.default_intra_mode_.ClearToEmpty();
  _impl_.default_uv_mode_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Block_IntraFrameModeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes segment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_segment_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes skip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_skip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes tx_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_tx_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes default_intra_mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_default_intra_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes default_uv_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_default_uv_mode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Block_IntraFrameModeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Block.IntraFrameModeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes segment_id = 1;
  if (!this->_internal_segment_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_segment_id(), target);
  }

  // bytes skip = 2;
  if (!this->_internal_skip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_skip(), target);
  }

  // bytes tx_size = 3;
  if (!this->_internal_tx_size().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_tx_size(), target);
  }

  // bytes default_intra_mode = 4;
  if (!this->_internal_default_intra_mode().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_default_intra_mode(), target);
  }

  // bytes default_uv_mode = 5;
  if (!this->_internal_default_uv_mode().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_default_uv_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Block.IntraFrameModeInfo)
  return target;
}

size_t Block_IntraFrameModeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Block.IntraFrameModeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes segment_id = 1;
  if (!this->_internal_segment_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_segment_id());
  }

  // bytes skip = 2;
  if (!this->_internal_skip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_skip());
  }

  // bytes tx_size = 3;
  if (!this->_internal_tx_size().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_size());
  }

  // bytes default_intra_mode = 4;
  if (!this->_internal_default_intra_mode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_default_intra_mode());
  }

  // bytes default_uv_mode = 5;
  if (!this->_internal_default_uv_mode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_default_uv_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Block_IntraFrameModeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Block_IntraFrameModeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Block_IntraFrameModeInfo::GetClassData() const { return &_class_data_; }


void Block_IntraFrameModeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Block_IntraFrameModeInfo*>(&to_msg);
  auto& from = static_cast<const Block_IntraFrameModeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Block.IntraFrameModeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_segment_id().empty()) {
    _this->_internal_set_segment_id(from._internal_segment_id());
  }
  if (!from._internal_skip().empty()) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (!from._internal_tx_size().empty()) {
    _this->_internal_set_tx_size(from._internal_tx_size());
  }
  if (!from._internal_default_intra_mode().empty()) {
    _this->_internal_set_default_intra_mode(from._internal_default_intra_mode());
  }
  if (!from._internal_default_uv_mode().empty()) {
    _this->_internal_set_default_uv_mode(from._internal_default_uv_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Block_IntraFrameModeInfo::CopyFrom(const Block_IntraFrameModeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Block.IntraFrameModeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Block_IntraFrameModeInfo::IsInitialized() const {
  return true;
}

void Block_IntraFrameModeInfo::InternalSwap(Block_IntraFrameModeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.segment_id_, lhs_arena,
      &other->_impl_.segment_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.skip_, lhs_arena,
      &other->_impl_.skip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_size_, lhs_arena,
      &other->_impl_.tx_size_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.default_intra_mode_, lhs_arena,
      &other->_impl_.default_intra_mode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.default_uv_mode_, lhs_arena,
      &other->_impl_.default_uv_mode_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Block_IntraFrameModeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[11]);
}
// ===================================================================

class Block_InterFrameModeInfo::_Internal {
 public:
  static constexpr int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::Block_InterFrameModeInfo, _impl_._oneof_case_);
  static const ::Block_IntraFrameModeInfo& intra_frame(const Block_InterFrameModeInfo* msg);
  static const ::Block_InterFrameModeInfo& inter_frame(const Block_InterFrameModeInfo* msg);
};

const ::Block_IntraFrameModeInfo&
Block_InterFrameModeInfo::_Internal::intra_frame(const Block_InterFrameModeInfo* msg) {
  return *msg->_impl_.next_frame_.intra_frame_;
}
const ::Block_InterFrameModeInfo&
Block_InterFrameModeInfo::_Internal::inter_frame(const Block_InterFrameModeInfo* msg) {
  return *msg->_impl_.next_frame_.inter_frame_;
}
void Block_InterFrameModeInfo::set_allocated_intra_frame(::Block_IntraFrameModeInfo* intra_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_next_frame();
  if (intra_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intra_frame);
    if (message_arena != submessage_arena) {
      intra_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intra_frame, submessage_arena);
    }
    set_has_intra_frame();
    _impl_.next_frame_.intra_frame_ = intra_frame;
  }
  // @@protoc_insertion_point(field_set_allocated:Block.InterFrameModeInfo.intra_frame)
}
void Block_InterFrameModeInfo::set_allocated_inter_frame(::Block_InterFrameModeInfo* inter_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_next_frame();
  if (inter_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inter_frame);
    if (message_arena != submessage_arena) {
      inter_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inter_frame, submessage_arena);
    }
    set_has_inter_frame();
    _impl_.next_frame_.inter_frame_ = inter_frame;
  }
  // @@protoc_insertion_point(field_set_allocated:Block.InterFrameModeInfo.inter_frame)
}
Block_InterFrameModeInfo::Block_InterFrameModeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Block.InterFrameModeInfo)
}
Block_InterFrameModeInfo::Block_InterFrameModeInfo(const Block_InterFrameModeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Block_InterFrameModeInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){}
    , decltype(_impl_.skip_){}
    , decltype(_impl_.is_inter_){}
    , decltype(_impl_.tx_size_){}
    , decltype(_impl_.next_frame_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.segment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_segment_id().empty()) {
    _this->_impl_.segment_id_.Set(from._internal_segment_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.skip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.skip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_skip().empty()) {
    _this->_impl_.skip_.Set(from._internal_skip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.is_inter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.is_inter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_is_inter().empty()) {
    _this->_impl_.is_inter_.Set(from._internal_is_inter(), 
      _this->GetArenaForAllocation());
  }
  _impl_.tx_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tx_size().empty()) {
    _this->_impl_.tx_size_.Set(from._internal_tx_size(), 
      _this->GetArenaForAllocation());
  }
  clear_has_next_frame();
  switch (from.next_frame_case()) {
    case kIntraFrame: {
      _this->_internal_mutable_intra_frame()->::Block_IntraFrameModeInfo::MergeFrom(
          from._internal_intra_frame());
      break;
    }
    case kInterFrame: {
      _this->_internal_mutable_inter_frame()->::Block_InterFrameModeInfo::MergeFrom(
          from._internal_inter_frame());
      break;
    }
    case NEXT_FRAME_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Block.InterFrameModeInfo)
}

inline void Block_InterFrameModeInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.segment_id_){}
    , decltype(_impl_.skip_){}
    , decltype(_impl_.is_inter_){}
    , decltype(_impl_.tx_size_){}
    , decltype(_impl_.next_frame_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.segment_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.skip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.skip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.is_inter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.is_inter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tx_size_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tx_size_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_next_frame();
}

Block_InterFrameModeInfo::~Block_InterFrameModeInfo() {
  // @@protoc_insertion_point(destructor:Block.InterFrameModeInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Block_InterFrameModeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.segment_id_.Destroy();
  _impl_.skip_.Destroy();
  _impl_.is_inter_.Destroy();
  _impl_.tx_size_.Destroy();
  if (has_next_frame()) {
    clear_next_frame();
  }
}

void Block_InterFrameModeInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Block_InterFrameModeInfo::clear_next_frame() {
// @@protoc_insertion_point(one_of_clear_start:Block.InterFrameModeInfo)
  switch (next_frame_case()) {
    case kIntraFrame: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.next_frame_.intra_frame_;
      }
      break;
    }
    case kInterFrame: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.next_frame_.inter_frame_;
      }
      break;
    }
    case NEXT_FRAME_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = NEXT_FRAME_NOT_SET;
}


void Block_InterFrameModeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Block.InterFrameModeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.segment_id_.ClearToEmpty();
  _impl_.skip_.ClearToEmpty();
  _impl_.is_inter_.ClearToEmpty();
  _impl_.tx_size_.ClearToEmpty();
  clear_next_frame();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Block_InterFrameModeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes segment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_segment_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes skip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_skip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes is_inter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_is_inter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes tx_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_tx_size();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Block.IntraFrameModeInfo intra_frame = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_intra_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Block.InterFrameModeInfo inter_frame = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_inter_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Block_InterFrameModeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Block.InterFrameModeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes segment_id = 1;
  if (!this->_internal_segment_id().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_segment_id(), target);
  }

  // bytes skip = 2;
  if (!this->_internal_skip().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_skip(), target);
  }

  // bytes is_inter = 3;
  if (!this->_internal_is_inter().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_is_inter(), target);
  }

  // bytes tx_size = 4;
  if (!this->_internal_tx_size().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_tx_size(), target);
  }

  // .Block.IntraFrameModeInfo intra_frame = 5;
  if (_internal_has_intra_frame()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::intra_frame(this),
        _Internal::intra_frame(this).GetCachedSize(), target, stream);
  }

  // .Block.InterFrameModeInfo inter_frame = 6;
  if (_internal_has_inter_frame()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::inter_frame(this),
        _Internal::inter_frame(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Block.InterFrameModeInfo)
  return target;
}

size_t Block_InterFrameModeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Block.InterFrameModeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes segment_id = 1;
  if (!this->_internal_segment_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_segment_id());
  }

  // bytes skip = 2;
  if (!this->_internal_skip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_skip());
  }

  // bytes is_inter = 3;
  if (!this->_internal_is_inter().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_is_inter());
  }

  // bytes tx_size = 4;
  if (!this->_internal_tx_size().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tx_size());
  }

  switch (next_frame_case()) {
    // .Block.IntraFrameModeInfo intra_frame = 5;
    case kIntraFrame: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.next_frame_.intra_frame_);
      break;
    }
    // .Block.InterFrameModeInfo inter_frame = 6;
    case kInterFrame: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.next_frame_.inter_frame_);
      break;
    }
    case NEXT_FRAME_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Block_InterFrameModeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Block_InterFrameModeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Block_InterFrameModeInfo::GetClassData() const { return &_class_data_; }


void Block_InterFrameModeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Block_InterFrameModeInfo*>(&to_msg);
  auto& from = static_cast<const Block_InterFrameModeInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Block.InterFrameModeInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_segment_id().empty()) {
    _this->_internal_set_segment_id(from._internal_segment_id());
  }
  if (!from._internal_skip().empty()) {
    _this->_internal_set_skip(from._internal_skip());
  }
  if (!from._internal_is_inter().empty()) {
    _this->_internal_set_is_inter(from._internal_is_inter());
  }
  if (!from._internal_tx_size().empty()) {
    _this->_internal_set_tx_size(from._internal_tx_size());
  }
  switch (from.next_frame_case()) {
    case kIntraFrame: {
      _this->_internal_mutable_intra_frame()->::Block_IntraFrameModeInfo::MergeFrom(
          from._internal_intra_frame());
      break;
    }
    case kInterFrame: {
      _this->_internal_mutable_inter_frame()->::Block_InterFrameModeInfo::MergeFrom(
          from._internal_inter_frame());
      break;
    }
    case NEXT_FRAME_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Block_InterFrameModeInfo::CopyFrom(const Block_InterFrameModeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Block.InterFrameModeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Block_InterFrameModeInfo::IsInitialized() const {
  return true;
}

void Block_InterFrameModeInfo::InternalSwap(Block_InterFrameModeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.segment_id_, lhs_arena,
      &other->_impl_.segment_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.skip_, lhs_arena,
      &other->_impl_.skip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.is_inter_, lhs_arena,
      &other->_impl_.is_inter_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tx_size_, lhs_arena,
      &other->_impl_.tx_size_, rhs_arena
  );
  swap(_impl_.next_frame_, other->_impl_.next_frame_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Block_InterFrameModeInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[12]);
}
// ===================================================================

class Block::_Internal {
 public:
  static constexpr int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::Block, _impl_._oneof_case_);
  static const ::Block_IntraFrameModeInfo& intra_frame(const Block* msg);
  static const ::Block_InterFrameModeInfo& inter_frame(const Block* msg);
};

const ::Block_IntraFrameModeInfo&
Block::_Internal::intra_frame(const Block* msg) {
  return *msg->_impl_.mode_info_.intra_frame_;
}
const ::Block_InterFrameModeInfo&
Block::_Internal::inter_frame(const Block* msg) {
  return *msg->_impl_.mode_info_.inter_frame_;
}
void Block::set_allocated_intra_frame(::Block_IntraFrameModeInfo* intra_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_mode_info();
  if (intra_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intra_frame);
    if (message_arena != submessage_arena) {
      intra_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intra_frame, submessage_arena);
    }
    set_has_intra_frame();
    _impl_.mode_info_.intra_frame_ = intra_frame;
  }
  // @@protoc_insertion_point(field_set_allocated:Block.intra_frame)
}
void Block::set_allocated_inter_frame(::Block_InterFrameModeInfo* inter_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_mode_info();
  if (inter_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inter_frame);
    if (message_arena != submessage_arena) {
      inter_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inter_frame, submessage_arena);
    }
    set_has_inter_frame();
    _impl_.mode_info_.inter_frame_ = inter_frame;
  }
  // @@protoc_insertion_point(field_set_allocated:Block.inter_frame)
}
Block::Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Block)
}
Block::Block(const Block& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Block* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.residual_){}
    , decltype(_impl_.mode_info_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.residual_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.residual_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_residual().empty()) {
    _this->_impl_.residual_.Set(from._internal_residual(), 
      _this->GetArenaForAllocation());
  }
  clear_has_mode_info();
  switch (from.mode_info_case()) {
    case kIntraFrame: {
      _this->_internal_mutable_intra_frame()->::Block_IntraFrameModeInfo::MergeFrom(
          from._internal_intra_frame());
      break;
    }
    case kInterFrame: {
      _this->_internal_mutable_inter_frame()->::Block_InterFrameModeInfo::MergeFrom(
          from._internal_inter_frame());
      break;
    }
    case MODE_INFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Block)
}

inline void Block::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.residual_){}
    , decltype(_impl_.mode_info_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.residual_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.residual_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_mode_info();
}

Block::~Block() {
  // @@protoc_insertion_point(destructor:Block)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Block::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.residual_.Destroy();
  if (has_mode_info()) {
    clear_mode_info();
  }
}

void Block::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Block::clear_mode_info() {
// @@protoc_insertion_point(one_of_clear_start:Block)
  switch (mode_info_case()) {
    case kIntraFrame: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.mode_info_.intra_frame_;
      }
      break;
    }
    case kInterFrame: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.mode_info_.inter_frame_;
      }
      break;
    }
    case MODE_INFO_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MODE_INFO_NOT_SET;
}


void Block::Clear() {
// @@protoc_insertion_point(message_clear_start:Block)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.residual_.ClearToEmpty();
  clear_mode_info();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Block::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Block.IntraFrameModeInfo intra_frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_intra_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Block.InterFrameModeInfo inter_frame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_inter_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes residual = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_residual();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Block::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Block)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Block.IntraFrameModeInfo intra_frame = 1;
  if (_internal_has_intra_frame()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::intra_frame(this),
        _Internal::intra_frame(this).GetCachedSize(), target, stream);
  }

  // .Block.InterFrameModeInfo inter_frame = 2;
  if (_internal_has_inter_frame()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::inter_frame(this),
        _Internal::inter_frame(this).GetCachedSize(), target, stream);
  }

  // bytes residual = 3;
  if (!this->_internal_residual().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_residual(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Block)
  return target;
}

size_t Block::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Block)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes residual = 3;
  if (!this->_internal_residual().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_residual());
  }

  switch (mode_info_case()) {
    // .Block.IntraFrameModeInfo intra_frame = 1;
    case kIntraFrame: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mode_info_.intra_frame_);
      break;
    }
    // .Block.InterFrameModeInfo inter_frame = 2;
    case kInterFrame: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mode_info_.inter_frame_);
      break;
    }
    case MODE_INFO_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Block::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Block::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Block::GetClassData() const { return &_class_data_; }


void Block::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Block*>(&to_msg);
  auto& from = static_cast<const Block&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Block)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_residual().empty()) {
    _this->_internal_set_residual(from._internal_residual());
  }
  switch (from.mode_info_case()) {
    case kIntraFrame: {
      _this->_internal_mutable_intra_frame()->::Block_IntraFrameModeInfo::MergeFrom(
          from._internal_intra_frame());
      break;
    }
    case kInterFrame: {
      _this->_internal_mutable_inter_frame()->::Block_InterFrameModeInfo::MergeFrom(
          from._internal_inter_frame());
      break;
    }
    case MODE_INFO_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Block::CopyFrom(const Block& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Block)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Block::IsInitialized() const {
  return true;
}

void Block::InternalSwap(Block* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.residual_, lhs_arena,
      &other->_impl_.residual_, rhs_arena
  );
  swap(_impl_.mode_info_, other->_impl_.mode_info_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Block::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[13]);
}
// ===================================================================

class Partition::_Internal {
 public:
  static const ::Block& block(const Partition* msg);
};

const ::Block&
Partition::_Internal::block(const Partition* msg) {
  return *msg->_impl_.block_;
}
Partition::Partition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Partition)
}
Partition::Partition(const Partition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Partition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.partition_){}
    , decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.partition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.partition_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_partition().empty()) {
    _this->_impl_.partition_.Set(from._internal_partition(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::Block(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:Partition)
}

inline void Partition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.partition_){}
    , decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.partition_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.partition_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Partition::~Partition() {
  // @@protoc_insertion_point(destructor:Partition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Partition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.partition_.Destroy();
  if (this != internal_default_instance()) delete _impl_.block_;
}

void Partition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Partition::Clear() {
// @@protoc_insertion_point(message_clear_start:Partition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.partition_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Partition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes partition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_partition();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Block block = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Partition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Partition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes partition = 1;
  if (!this->_internal_partition().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_partition(), target);
  }

  // .Block block = 2;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Partition)
  return target;
}

size_t Partition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Partition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes partition = 1;
  if (!this->_internal_partition().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_partition());
  }

  // .Block block = 2;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Partition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Partition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Partition::GetClassData() const { return &_class_data_; }


void Partition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Partition*>(&to_msg);
  auto& from = static_cast<const Partition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Partition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_partition().empty()) {
    _this->_internal_set_partition(from._internal_partition());
  }
  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::Block::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Partition::CopyFrom(const Partition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Partition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Partition::IsInitialized() const {
  return true;
}

void Partition::InternalSwap(Partition* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.partition_, lhs_arena,
      &other->_impl_.partition_, rhs_arena
  );
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Partition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[14]);
}
// ===================================================================

class Tile::_Internal {
 public:
  static const ::Partition& partition(const Tile* msg);
};

const ::Partition&
Tile::_Internal::partition(const Tile* msg) {
  return *msg->_impl_.partition_;
}
Tile::Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Tile)
}
Tile::Tile(const Tile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.partition_){nullptr}
    , decltype(_impl_.tile_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_partition()) {
    _this->_impl_.partition_ = new ::Partition(*from._impl_.partition_);
  }
  _this->_impl_.tile_size_ = from._impl_.tile_size_;
  // @@protoc_insertion_point(copy_constructor:Tile)
}

inline void Tile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.partition_){nullptr}
    , decltype(_impl_.tile_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Tile::~Tile() {
  // @@protoc_insertion_point(destructor:Tile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.partition_;
}

void Tile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tile::Clear() {
// @@protoc_insertion_point(message_clear_start:Tile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.partition_ != nullptr) {
    delete _impl_.partition_;
  }
  _impl_.partition_ = nullptr;
  _impl_.tile_size_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 tile_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.tile_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Partition partition = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_partition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Tile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 tile_size = 1;
  if (this->_internal_tile_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tile_size(), target);
  }

  // .Partition partition = 2;
  if (this->_internal_has_partition()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::partition(this),
        _Internal::partition(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Tile)
  return target;
}

size_t Tile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Tile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Partition partition = 2;
  if (this->_internal_has_partition()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.partition_);
  }

  // uint32 tile_size = 1;
  if (this->_internal_tile_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tile_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tile::GetClassData() const { return &_class_data_; }


void Tile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tile*>(&to_msg);
  auto& from = static_cast<const Tile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Tile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_partition()) {
    _this->_internal_mutable_partition()->::Partition::MergeFrom(
        from._internal_partition());
  }
  if (from._internal_tile_size() != 0) {
    _this->_internal_set_tile_size(from._internal_tile_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tile::CopyFrom(const Tile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Tile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tile::IsInitialized() const {
  return true;
}

void Tile::InternalSwap(Tile* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tile, _impl_.tile_size_)
      + sizeof(Tile::_impl_.tile_size_)
      - PROTOBUF_FIELD_OFFSET(Tile, _impl_.partition_)>(
          reinterpret_cast<char*>(&_impl_.partition_),
          reinterpret_cast<char*>(&other->_impl_.partition_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[15]);
}
// ===================================================================

class VP9Frame::_Internal {
 public:
  static const ::UncompressedHeader& uncompressed_header(const VP9Frame* msg);
  static const ::CompressedHeader& compressed_header(const VP9Frame* msg);
};

const ::UncompressedHeader&
VP9Frame::_Internal::uncompressed_header(const VP9Frame* msg) {
  return *msg->_impl_.uncompressed_header_;
}
const ::CompressedHeader&
VP9Frame::_Internal::compressed_header(const VP9Frame* msg) {
  return *msg->_impl_.compressed_header_;
}
VP9Frame::VP9Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:VP9Frame)
}
VP9Frame::VP9Frame(const VP9Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VP9Frame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tiles_){from._impl_.tiles_}
    , decltype(_impl_.uncompressed_header_){nullptr}
    , decltype(_impl_.compressed_header_){nullptr}
    , decltype(_impl_.trailing_bits_){}
    , decltype(_impl_.padding_bit_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_uncompressed_header()) {
    _this->_impl_.uncompressed_header_ = new ::UncompressedHeader(*from._impl_.uncompressed_header_);
  }
  if (from._internal_has_compressed_header()) {
    _this->_impl_.compressed_header_ = new ::CompressedHeader(*from._impl_.compressed_header_);
  }
  ::memcpy(&_impl_.trailing_bits_, &from._impl_.trailing_bits_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.padding_bit_) -
    reinterpret_cast<char*>(&_impl_.trailing_bits_)) + sizeof(_impl_.padding_bit_));
  // @@protoc_insertion_point(copy_constructor:VP9Frame)
}

inline void VP9Frame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tiles_){arena}
    , decltype(_impl_.uncompressed_header_){nullptr}
    , decltype(_impl_.compressed_header_){nullptr}
    , decltype(_impl_.trailing_bits_){0u}
    , decltype(_impl_.padding_bit_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VP9Frame::~VP9Frame() {
  // @@protoc_insertion_point(destructor:VP9Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VP9Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tiles_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.uncompressed_header_;
  if (this != internal_default_instance()) delete _impl_.compressed_header_;
}

void VP9Frame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VP9Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:VP9Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tiles_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.uncompressed_header_ != nullptr) {
    delete _impl_.uncompressed_header_;
  }
  _impl_.uncompressed_header_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.compressed_header_ != nullptr) {
    delete _impl_.compressed_header_;
  }
  _impl_.compressed_header_ = nullptr;
  ::memset(&_impl_.trailing_bits_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.padding_bit_) -
      reinterpret_cast<char*>(&_impl_.trailing_bits_)) + sizeof(_impl_.padding_bit_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VP9Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .UncompressedHeader uncompressed_header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_uncompressed_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 trailing_bits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.trailing_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 padding_bit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.padding_bit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CompressedHeader compressed_header = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_compressed_header(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Tile tiles = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tiles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VP9Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VP9Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .UncompressedHeader uncompressed_header = 1;
  if (this->_internal_has_uncompressed_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::uncompressed_header(this),
        _Internal::uncompressed_header(this).GetCachedSize(), target, stream);
  }

  // uint32 trailing_bits = 2;
  if (this->_internal_trailing_bits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_trailing_bits(), target);
  }

  // uint32 padding_bit = 3;
  if (this->_internal_padding_bit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_padding_bit(), target);
  }

  // .CompressedHeader compressed_header = 4;
  if (this->_internal_has_compressed_header()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::compressed_header(this),
        _Internal::compressed_header(this).GetCachedSize(), target, stream);
  }

  // repeated .Tile tiles = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tiles_size()); i < n; i++) {
    const auto& repfield = this->_internal_tiles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VP9Frame)
  return target;
}

size_t VP9Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VP9Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Tile tiles = 5;
  total_size += 1UL * this->_internal_tiles_size();
  for (const auto& msg : this->_impl_.tiles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .UncompressedHeader uncompressed_header = 1;
  if (this->_internal_has_uncompressed_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.uncompressed_header_);
  }

  // .CompressedHeader compressed_header = 4;
  if (this->_internal_has_compressed_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.compressed_header_);
  }

  // uint32 trailing_bits = 2;
  if (this->_internal_trailing_bits() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trailing_bits());
  }

  // uint32 padding_bit = 3;
  if (this->_internal_padding_bit() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_padding_bit());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VP9Frame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VP9Frame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VP9Frame::GetClassData() const { return &_class_data_; }


void VP9Frame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VP9Frame*>(&to_msg);
  auto& from = static_cast<const VP9Frame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VP9Frame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tiles_.MergeFrom(from._impl_.tiles_);
  if (from._internal_has_uncompressed_header()) {
    _this->_internal_mutable_uncompressed_header()->::UncompressedHeader::MergeFrom(
        from._internal_uncompressed_header());
  }
  if (from._internal_has_compressed_header()) {
    _this->_internal_mutable_compressed_header()->::CompressedHeader::MergeFrom(
        from._internal_compressed_header());
  }
  if (from._internal_trailing_bits() != 0) {
    _this->_internal_set_trailing_bits(from._internal_trailing_bits());
  }
  if (from._internal_padding_bit() != 0) {
    _this->_internal_set_padding_bit(from._internal_padding_bit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VP9Frame::CopyFrom(const VP9Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VP9Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VP9Frame::IsInitialized() const {
  return true;
}

void VP9Frame::InternalSwap(VP9Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tiles_.InternalSwap(&other->_impl_.tiles_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VP9Frame, _impl_.padding_bit_)
      + sizeof(VP9Frame::_impl_.padding_bit_)
      - PROTOBUF_FIELD_OFFSET(VP9Frame, _impl_.uncompressed_header_)>(
          reinterpret_cast<char*>(&_impl_.uncompressed_header_),
          reinterpret_cast<char*>(&other->_impl_.uncompressed_header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VP9Frame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vp9_2eproto_getter, &descriptor_table_vp9_2eproto_once,
      file_level_metadata_vp9_2eproto[16]);
}
// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::VP9SignedInteger*
Arena::CreateMaybeMessage< ::VP9SignedInteger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VP9SignedInteger >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_ColorConfig*
Arena::CreateMaybeMessage< ::UncompressedHeader_ColorConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_ColorConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_FrameSize*
Arena::CreateMaybeMessage< ::UncompressedHeader_FrameSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_FrameSize >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_RenderSize*
Arena::CreateMaybeMessage< ::UncompressedHeader_RenderSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_RenderSize >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_ReadInterpolationFilter*
Arena::CreateMaybeMessage< ::UncompressedHeader_ReadInterpolationFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_ReadInterpolationFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_LoopFilterParams*
Arena::CreateMaybeMessage< ::UncompressedHeader_LoopFilterParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_LoopFilterParams >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_QuantizationParams*
Arena::CreateMaybeMessage< ::UncompressedHeader_QuantizationParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_QuantizationParams >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_SegmentationParams*
Arena::CreateMaybeMessage< ::UncompressedHeader_SegmentationParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_SegmentationParams >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader_TileInfo*
Arena::CreateMaybeMessage< ::UncompressedHeader_TileInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader_TileInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::UncompressedHeader*
Arena::CreateMaybeMessage< ::UncompressedHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UncompressedHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CompressedHeader*
Arena::CreateMaybeMessage< ::CompressedHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CompressedHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::Block_IntraFrameModeInfo*
Arena::CreateMaybeMessage< ::Block_IntraFrameModeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Block_IntraFrameModeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Block_InterFrameModeInfo*
Arena::CreateMaybeMessage< ::Block_InterFrameModeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Block_InterFrameModeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Block*
Arena::CreateMaybeMessage< ::Block >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Block >(arena);
}
template<> PROTOBUF_NOINLINE ::Partition*
Arena::CreateMaybeMessage< ::Partition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Partition >(arena);
}
template<> PROTOBUF_NOINLINE ::Tile*
Arena::CreateMaybeMessage< ::Tile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Tile >(arena);
}
template<> PROTOBUF_NOINLINE ::VP9Frame*
Arena::CreateMaybeMessage< ::VP9Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::VP9Frame >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
