// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vp9.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vp9_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_vp9_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 3021000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_vp9_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vp9_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_vp9_2eproto;
class CompressedHeader;
struct CompressedHeaderDefaultTypeInternal;
extern CompressedHeaderDefaultTypeInternal _CompressedHeader_default_instance_;
class CompressedHeader_DecodeTermSubexp;
struct CompressedHeader_DecodeTermSubexpDefaultTypeInternal;
extern CompressedHeader_DecodeTermSubexpDefaultTypeInternal _CompressedHeader_DecodeTermSubexp_default_instance_;
class CompressedHeader_DiffUpdateProb;
struct CompressedHeader_DiffUpdateProbDefaultTypeInternal;
extern CompressedHeader_DiffUpdateProbDefaultTypeInternal _CompressedHeader_DiffUpdateProb_default_instance_;
class CompressedHeader_FrameReferenceMode;
struct CompressedHeader_FrameReferenceModeDefaultTypeInternal;
extern CompressedHeader_FrameReferenceModeDefaultTypeInternal _CompressedHeader_FrameReferenceMode_default_instance_;
class CompressedHeader_FrameReferenceModeProbs;
struct CompressedHeader_FrameReferenceModeProbsDefaultTypeInternal;
extern CompressedHeader_FrameReferenceModeProbsDefaultTypeInternal _CompressedHeader_FrameReferenceModeProbs_default_instance_;
class CompressedHeader_MvProbs;
struct CompressedHeader_MvProbsDefaultTypeInternal;
extern CompressedHeader_MvProbsDefaultTypeInternal _CompressedHeader_MvProbs_default_instance_;
class CompressedHeader_MvProbs_MvProbsLoop;
struct CompressedHeader_MvProbs_MvProbsLoopDefaultTypeInternal;
extern CompressedHeader_MvProbs_MvProbsLoopDefaultTypeInternal _CompressedHeader_MvProbs_MvProbsLoop_default_instance_;
class CompressedHeader_ReadCoefProbs;
struct CompressedHeader_ReadCoefProbsDefaultTypeInternal;
extern CompressedHeader_ReadCoefProbsDefaultTypeInternal _CompressedHeader_ReadCoefProbs_default_instance_;
class CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop;
struct CompressedHeader_ReadCoefProbs_ReadCoefProbsLoopDefaultTypeInternal;
extern CompressedHeader_ReadCoefProbs_ReadCoefProbsLoopDefaultTypeInternal _CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop_default_instance_;
class CompressedHeader_ReadInterModeProbs;
struct CompressedHeader_ReadInterModeProbsDefaultTypeInternal;
extern CompressedHeader_ReadInterModeProbsDefaultTypeInternal _CompressedHeader_ReadInterModeProbs_default_instance_;
class CompressedHeader_ReadInterpFilterProbs;
struct CompressedHeader_ReadInterpFilterProbsDefaultTypeInternal;
extern CompressedHeader_ReadInterpFilterProbsDefaultTypeInternal _CompressedHeader_ReadInterpFilterProbs_default_instance_;
class CompressedHeader_ReadIsInterProbs;
struct CompressedHeader_ReadIsInterProbsDefaultTypeInternal;
extern CompressedHeader_ReadIsInterProbsDefaultTypeInternal _CompressedHeader_ReadIsInterProbs_default_instance_;
class CompressedHeader_ReadPartitionProbs;
struct CompressedHeader_ReadPartitionProbsDefaultTypeInternal;
extern CompressedHeader_ReadPartitionProbsDefaultTypeInternal _CompressedHeader_ReadPartitionProbs_default_instance_;
class CompressedHeader_ReadSkipProb;
struct CompressedHeader_ReadSkipProbDefaultTypeInternal;
extern CompressedHeader_ReadSkipProbDefaultTypeInternal _CompressedHeader_ReadSkipProb_default_instance_;
class CompressedHeader_ReadTxMode;
struct CompressedHeader_ReadTxModeDefaultTypeInternal;
extern CompressedHeader_ReadTxModeDefaultTypeInternal _CompressedHeader_ReadTxMode_default_instance_;
class CompressedHeader_ReadYModeProbs;
struct CompressedHeader_ReadYModeProbsDefaultTypeInternal;
extern CompressedHeader_ReadYModeProbsDefaultTypeInternal _CompressedHeader_ReadYModeProbs_default_instance_;
class CompressedHeader_TxModeProbs;
struct CompressedHeader_TxModeProbsDefaultTypeInternal;
extern CompressedHeader_TxModeProbsDefaultTypeInternal _CompressedHeader_TxModeProbs_default_instance_;
class Tile;
struct TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class UncompressedHeader;
struct UncompressedHeaderDefaultTypeInternal;
extern UncompressedHeaderDefaultTypeInternal _UncompressedHeader_default_instance_;
class UncompressedHeader_ColorConfig;
struct UncompressedHeader_ColorConfigDefaultTypeInternal;
extern UncompressedHeader_ColorConfigDefaultTypeInternal _UncompressedHeader_ColorConfig_default_instance_;
class UncompressedHeader_FrameSize;
struct UncompressedHeader_FrameSizeDefaultTypeInternal;
extern UncompressedHeader_FrameSizeDefaultTypeInternal _UncompressedHeader_FrameSize_default_instance_;
class UncompressedHeader_LoopFilterParams;
struct UncompressedHeader_LoopFilterParamsDefaultTypeInternal;
extern UncompressedHeader_LoopFilterParamsDefaultTypeInternal _UncompressedHeader_LoopFilterParams_default_instance_;
class UncompressedHeader_LoopFilterParams_ModeDelta;
struct UncompressedHeader_LoopFilterParams_ModeDeltaDefaultTypeInternal;
extern UncompressedHeader_LoopFilterParams_ModeDeltaDefaultTypeInternal _UncompressedHeader_LoopFilterParams_ModeDelta_default_instance_;
class UncompressedHeader_LoopFilterParams_RefDelta;
struct UncompressedHeader_LoopFilterParams_RefDeltaDefaultTypeInternal;
extern UncompressedHeader_LoopFilterParams_RefDeltaDefaultTypeInternal _UncompressedHeader_LoopFilterParams_RefDelta_default_instance_;
class UncompressedHeader_QuantizationParams;
struct UncompressedHeader_QuantizationParamsDefaultTypeInternal;
extern UncompressedHeader_QuantizationParamsDefaultTypeInternal _UncompressedHeader_QuantizationParams_default_instance_;
class UncompressedHeader_QuantizationParams_ReadDeltaQ;
struct UncompressedHeader_QuantizationParams_ReadDeltaQDefaultTypeInternal;
extern UncompressedHeader_QuantizationParams_ReadDeltaQDefaultTypeInternal _UncompressedHeader_QuantizationParams_ReadDeltaQ_default_instance_;
class UncompressedHeader_ReadInterpolationFilter;
struct UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal;
extern UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal _UncompressedHeader_ReadInterpolationFilter_default_instance_;
class UncompressedHeader_RenderSize;
struct UncompressedHeader_RenderSizeDefaultTypeInternal;
extern UncompressedHeader_RenderSizeDefaultTypeInternal _UncompressedHeader_RenderSize_default_instance_;
class UncompressedHeader_SegmentationParams;
struct UncompressedHeader_SegmentationParamsDefaultTypeInternal;
extern UncompressedHeader_SegmentationParamsDefaultTypeInternal _UncompressedHeader_SegmentationParams_default_instance_;
class UncompressedHeader_SegmentationParams_Feature;
struct UncompressedHeader_SegmentationParams_FeatureDefaultTypeInternal;
extern UncompressedHeader_SegmentationParams_FeatureDefaultTypeInternal _UncompressedHeader_SegmentationParams_Feature_default_instance_;
class UncompressedHeader_SegmentationParams_ReadProb;
struct UncompressedHeader_SegmentationParams_ReadProbDefaultTypeInternal;
extern UncompressedHeader_SegmentationParams_ReadProbDefaultTypeInternal _UncompressedHeader_SegmentationParams_ReadProb_default_instance_;
class UncompressedHeader_TileInfo;
struct UncompressedHeader_TileInfoDefaultTypeInternal;
extern UncompressedHeader_TileInfoDefaultTypeInternal _UncompressedHeader_TileInfo_default_instance_;
class VP9Frame;
struct VP9FrameDefaultTypeInternal;
extern VP9FrameDefaultTypeInternal _VP9Frame_default_instance_;
class VP9SignedInteger;
struct VP9SignedIntegerDefaultTypeInternal;
extern VP9SignedIntegerDefaultTypeInternal _VP9SignedInteger_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::CompressedHeader* Arena::CreateMaybeMessage<::CompressedHeader>(Arena*);
template <>
::CompressedHeader_DecodeTermSubexp* Arena::CreateMaybeMessage<::CompressedHeader_DecodeTermSubexp>(Arena*);
template <>
::CompressedHeader_DiffUpdateProb* Arena::CreateMaybeMessage<::CompressedHeader_DiffUpdateProb>(Arena*);
template <>
::CompressedHeader_FrameReferenceMode* Arena::CreateMaybeMessage<::CompressedHeader_FrameReferenceMode>(Arena*);
template <>
::CompressedHeader_FrameReferenceModeProbs* Arena::CreateMaybeMessage<::CompressedHeader_FrameReferenceModeProbs>(Arena*);
template <>
::CompressedHeader_MvProbs* Arena::CreateMaybeMessage<::CompressedHeader_MvProbs>(Arena*);
template <>
::CompressedHeader_MvProbs_MvProbsLoop* Arena::CreateMaybeMessage<::CompressedHeader_MvProbs_MvProbsLoop>(Arena*);
template <>
::CompressedHeader_ReadCoefProbs* Arena::CreateMaybeMessage<::CompressedHeader_ReadCoefProbs>(Arena*);
template <>
::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* Arena::CreateMaybeMessage<::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop>(Arena*);
template <>
::CompressedHeader_ReadInterModeProbs* Arena::CreateMaybeMessage<::CompressedHeader_ReadInterModeProbs>(Arena*);
template <>
::CompressedHeader_ReadInterpFilterProbs* Arena::CreateMaybeMessage<::CompressedHeader_ReadInterpFilterProbs>(Arena*);
template <>
::CompressedHeader_ReadIsInterProbs* Arena::CreateMaybeMessage<::CompressedHeader_ReadIsInterProbs>(Arena*);
template <>
::CompressedHeader_ReadPartitionProbs* Arena::CreateMaybeMessage<::CompressedHeader_ReadPartitionProbs>(Arena*);
template <>
::CompressedHeader_ReadSkipProb* Arena::CreateMaybeMessage<::CompressedHeader_ReadSkipProb>(Arena*);
template <>
::CompressedHeader_ReadTxMode* Arena::CreateMaybeMessage<::CompressedHeader_ReadTxMode>(Arena*);
template <>
::CompressedHeader_ReadYModeProbs* Arena::CreateMaybeMessage<::CompressedHeader_ReadYModeProbs>(Arena*);
template <>
::CompressedHeader_TxModeProbs* Arena::CreateMaybeMessage<::CompressedHeader_TxModeProbs>(Arena*);
template <>
::Tile* Arena::CreateMaybeMessage<::Tile>(Arena*);
template <>
::UncompressedHeader* Arena::CreateMaybeMessage<::UncompressedHeader>(Arena*);
template <>
::UncompressedHeader_ColorConfig* Arena::CreateMaybeMessage<::UncompressedHeader_ColorConfig>(Arena*);
template <>
::UncompressedHeader_FrameSize* Arena::CreateMaybeMessage<::UncompressedHeader_FrameSize>(Arena*);
template <>
::UncompressedHeader_LoopFilterParams* Arena::CreateMaybeMessage<::UncompressedHeader_LoopFilterParams>(Arena*);
template <>
::UncompressedHeader_LoopFilterParams_ModeDelta* Arena::CreateMaybeMessage<::UncompressedHeader_LoopFilterParams_ModeDelta>(Arena*);
template <>
::UncompressedHeader_LoopFilterParams_RefDelta* Arena::CreateMaybeMessage<::UncompressedHeader_LoopFilterParams_RefDelta>(Arena*);
template <>
::UncompressedHeader_QuantizationParams* Arena::CreateMaybeMessage<::UncompressedHeader_QuantizationParams>(Arena*);
template <>
::UncompressedHeader_QuantizationParams_ReadDeltaQ* Arena::CreateMaybeMessage<::UncompressedHeader_QuantizationParams_ReadDeltaQ>(Arena*);
template <>
::UncompressedHeader_ReadInterpolationFilter* Arena::CreateMaybeMessage<::UncompressedHeader_ReadInterpolationFilter>(Arena*);
template <>
::UncompressedHeader_RenderSize* Arena::CreateMaybeMessage<::UncompressedHeader_RenderSize>(Arena*);
template <>
::UncompressedHeader_SegmentationParams* Arena::CreateMaybeMessage<::UncompressedHeader_SegmentationParams>(Arena*);
template <>
::UncompressedHeader_SegmentationParams_Feature* Arena::CreateMaybeMessage<::UncompressedHeader_SegmentationParams_Feature>(Arena*);
template <>
::UncompressedHeader_SegmentationParams_ReadProb* Arena::CreateMaybeMessage<::UncompressedHeader_SegmentationParams_ReadProb>(Arena*);
template <>
::UncompressedHeader_TileInfo* Arena::CreateMaybeMessage<::UncompressedHeader_TileInfo>(Arena*);
template <>
::VP9Frame* Arena::CreateMaybeMessage<::VP9Frame>(Arena*);
template <>
::VP9SignedInteger* Arena::CreateMaybeMessage<::VP9SignedInteger>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum UncompressedHeader_ColorConfig_ColorSpace : int {
  UncompressedHeader_ColorConfig_ColorSpace_CS_UNKNOWN = 0,
  UncompressedHeader_ColorConfig_ColorSpace_CS_BT_601 = 1,
  UncompressedHeader_ColorConfig_ColorSpace_CS_BT_709 = 2,
  UncompressedHeader_ColorConfig_ColorSpace_CS_SMPTE_170 = 3,
  UncompressedHeader_ColorConfig_ColorSpace_CS_SMPTE_240 = 4,
  UncompressedHeader_ColorConfig_ColorSpace_CS_BT_2020 = 5,
  UncompressedHeader_ColorConfig_ColorSpace_CS_RESERVED = 6,
  UncompressedHeader_ColorConfig_ColorSpace_CS_RGB = 7,
  UncompressedHeader_ColorConfig_ColorSpace_UncompressedHeader_ColorConfig_ColorSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UncompressedHeader_ColorConfig_ColorSpace_UncompressedHeader_ColorConfig_ColorSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UncompressedHeader_ColorConfig_ColorSpace_IsValid(int value);
constexpr UncompressedHeader_ColorConfig_ColorSpace UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_MIN = UncompressedHeader_ColorConfig_ColorSpace_CS_UNKNOWN;
constexpr UncompressedHeader_ColorConfig_ColorSpace UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_MAX = UncompressedHeader_ColorConfig_ColorSpace_CS_RGB;
constexpr int UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_ARRAYSIZE = UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UncompressedHeader_ColorConfig_ColorSpace_descriptor();
template<typename T>
inline const std::string& UncompressedHeader_ColorConfig_ColorSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UncompressedHeader_ColorConfig_ColorSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UncompressedHeader_ColorConfig_ColorSpace_Name.");
  return UncompressedHeader_ColorConfig_ColorSpace_Name(static_cast<UncompressedHeader_ColorConfig_ColorSpace>(enum_t_value));
}
template<>
inline const std::string& UncompressedHeader_ColorConfig_ColorSpace_Name(UncompressedHeader_ColorConfig_ColorSpace value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum
    <UncompressedHeader_ColorConfig_ColorSpace_descriptor, 0, 7>(static_cast<int>(value));
}
inline bool UncompressedHeader_ColorConfig_ColorSpace_Parse(
    ::absl::string_view name, UncompressedHeader_ColorConfig_ColorSpace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UncompressedHeader_ColorConfig_ColorSpace>(
    UncompressedHeader_ColorConfig_ColorSpace_descriptor(), name, value);
}
enum UncompressedHeader_FrameType : int {
  UncompressedHeader_FrameType_KEY_FRAME = 0,
  UncompressedHeader_FrameType_NON_KEY_FRAME = 1,
  UncompressedHeader_FrameType_UncompressedHeader_FrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UncompressedHeader_FrameType_UncompressedHeader_FrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UncompressedHeader_FrameType_IsValid(int value);
constexpr UncompressedHeader_FrameType UncompressedHeader_FrameType_FrameType_MIN = UncompressedHeader_FrameType_KEY_FRAME;
constexpr UncompressedHeader_FrameType UncompressedHeader_FrameType_FrameType_MAX = UncompressedHeader_FrameType_NON_KEY_FRAME;
constexpr int UncompressedHeader_FrameType_FrameType_ARRAYSIZE = UncompressedHeader_FrameType_FrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UncompressedHeader_FrameType_descriptor();
template<typename T>
inline const std::string& UncompressedHeader_FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UncompressedHeader_FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UncompressedHeader_FrameType_Name.");
  return UncompressedHeader_FrameType_Name(static_cast<UncompressedHeader_FrameType>(enum_t_value));
}
template<>
inline const std::string& UncompressedHeader_FrameType_Name(UncompressedHeader_FrameType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum
    <UncompressedHeader_FrameType_descriptor, 0, 1>(static_cast<int>(value));
}
inline bool UncompressedHeader_FrameType_Parse(
    ::absl::string_view name, UncompressedHeader_FrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UncompressedHeader_FrameType>(
    UncompressedHeader_FrameType_descriptor(), name, value);
}
enum UncompressedHeader_InterpolationFilter : int {
  UncompressedHeader_InterpolationFilter_EIGHTTAP = 0,
  UncompressedHeader_InterpolationFilter_EIGHTTAP_SMOOTH = 1,
  UncompressedHeader_InterpolationFilter_EIGHTTAP_SHARP = 2,
  UncompressedHeader_InterpolationFilter_BILINEAR = 3,
  UncompressedHeader_InterpolationFilter_SWITCHABLE = 4,
  UncompressedHeader_InterpolationFilter_UncompressedHeader_InterpolationFilter_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UncompressedHeader_InterpolationFilter_UncompressedHeader_InterpolationFilter_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UncompressedHeader_InterpolationFilter_IsValid(int value);
constexpr UncompressedHeader_InterpolationFilter UncompressedHeader_InterpolationFilter_InterpolationFilter_MIN = UncompressedHeader_InterpolationFilter_EIGHTTAP;
constexpr UncompressedHeader_InterpolationFilter UncompressedHeader_InterpolationFilter_InterpolationFilter_MAX = UncompressedHeader_InterpolationFilter_SWITCHABLE;
constexpr int UncompressedHeader_InterpolationFilter_InterpolationFilter_ARRAYSIZE = UncompressedHeader_InterpolationFilter_InterpolationFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UncompressedHeader_InterpolationFilter_descriptor();
template<typename T>
inline const std::string& UncompressedHeader_InterpolationFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UncompressedHeader_InterpolationFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UncompressedHeader_InterpolationFilter_Name.");
  return UncompressedHeader_InterpolationFilter_Name(static_cast<UncompressedHeader_InterpolationFilter>(enum_t_value));
}
template<>
inline const std::string& UncompressedHeader_InterpolationFilter_Name(UncompressedHeader_InterpolationFilter value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum
    <UncompressedHeader_InterpolationFilter_descriptor, 0, 4>(static_cast<int>(value));
}
inline bool UncompressedHeader_InterpolationFilter_Parse(
    ::absl::string_view name, UncompressedHeader_InterpolationFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UncompressedHeader_InterpolationFilter>(
    UncompressedHeader_InterpolationFilter_descriptor(), name, value);
}
enum CompressedHeader_TxMode : int {
  CompressedHeader_TxMode_ONLY_4X4 = 0,
  CompressedHeader_TxMode_ALLOW_8X8 = 1,
  CompressedHeader_TxMode_ALLOW_16X16 = 2,
  CompressedHeader_TxMode_ALLOW_32X32 = 3,
  CompressedHeader_TxMode_TX_MODE_SELECT = 4,
  CompressedHeader_TxMode_CompressedHeader_TxMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompressedHeader_TxMode_CompressedHeader_TxMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompressedHeader_TxMode_IsValid(int value);
constexpr CompressedHeader_TxMode CompressedHeader_TxMode_TxMode_MIN = CompressedHeader_TxMode_ONLY_4X4;
constexpr CompressedHeader_TxMode CompressedHeader_TxMode_TxMode_MAX = CompressedHeader_TxMode_TX_MODE_SELECT;
constexpr int CompressedHeader_TxMode_TxMode_ARRAYSIZE = CompressedHeader_TxMode_TxMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressedHeader_TxMode_descriptor();
template<typename T>
inline const std::string& CompressedHeader_TxMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressedHeader_TxMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressedHeader_TxMode_Name.");
  return CompressedHeader_TxMode_Name(static_cast<CompressedHeader_TxMode>(enum_t_value));
}
template<>
inline const std::string& CompressedHeader_TxMode_Name(CompressedHeader_TxMode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum
    <CompressedHeader_TxMode_descriptor, 0, 4>(static_cast<int>(value));
}
inline bool CompressedHeader_TxMode_Parse(
    ::absl::string_view name, CompressedHeader_TxMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressedHeader_TxMode>(
    CompressedHeader_TxMode_descriptor(), name, value);
}
enum VP9BitField : int {
  ZERO = 0,
  ONE = 1,
  VP9BitField_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VP9BitField_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VP9BitField_IsValid(int value);
constexpr VP9BitField VP9BitField_MIN = ZERO;
constexpr VP9BitField VP9BitField_MAX = ONE;
constexpr int VP9BitField_ARRAYSIZE = VP9BitField_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VP9BitField_descriptor();
template<typename T>
inline const std::string& VP9BitField_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VP9BitField>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VP9BitField_Name.");
  return VP9BitField_Name(static_cast<VP9BitField>(enum_t_value));
}
template<>
inline const std::string& VP9BitField_Name(VP9BitField value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum
    <VP9BitField_descriptor, 0, 1>(static_cast<int>(value));
}
inline bool VP9BitField_Parse(
    ::absl::string_view name, VP9BitField* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VP9BitField>(
    VP9BitField_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VP9SignedInteger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VP9SignedInteger) */ {
 public:
  inline VP9SignedInteger() : VP9SignedInteger(nullptr) {}
  ~VP9SignedInteger() override;
  explicit PROTOBUF_CONSTEXPR VP9SignedInteger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VP9SignedInteger(const VP9SignedInteger& from);
  VP9SignedInteger(VP9SignedInteger&& from) noexcept
    : VP9SignedInteger() {
    *this = ::std::move(from);
  }

  inline VP9SignedInteger& operator=(const VP9SignedInteger& from) {
    CopyFrom(from);
    return *this;
  }
  inline VP9SignedInteger& operator=(VP9SignedInteger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VP9SignedInteger& default_instance() {
    return *internal_default_instance();
  }
  static inline const VP9SignedInteger* internal_default_instance() {
    return reinterpret_cast<const VP9SignedInteger*>(
               &_VP9SignedInteger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VP9SignedInteger& a, VP9SignedInteger& b) {
    a.Swap(&b);
  }
  inline void Swap(VP9SignedInteger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VP9SignedInteger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VP9SignedInteger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VP9SignedInteger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VP9SignedInteger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VP9SignedInteger& from) {
    VP9SignedInteger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VP9SignedInteger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "VP9SignedInteger";
  }
  protected:
  explicit VP9SignedInteger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kSignFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .VP9BitField sign = 2;
  void clear_sign();
  ::VP9BitField sign() const;
  void set_sign(::VP9BitField value);
  private:
  ::VP9BitField _internal_sign() const;
  void _internal_set_sign(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:VP9SignedInteger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_ColorConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.ColorConfig) */ {
 public:
  inline UncompressedHeader_ColorConfig() : UncompressedHeader_ColorConfig(nullptr) {}
  ~UncompressedHeader_ColorConfig() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_ColorConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_ColorConfig(const UncompressedHeader_ColorConfig& from);
  UncompressedHeader_ColorConfig(UncompressedHeader_ColorConfig&& from) noexcept
    : UncompressedHeader_ColorConfig() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_ColorConfig& operator=(const UncompressedHeader_ColorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_ColorConfig& operator=(UncompressedHeader_ColorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_ColorConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_ColorConfig* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_ColorConfig*>(
               &_UncompressedHeader_ColorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UncompressedHeader_ColorConfig& a, UncompressedHeader_ColorConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_ColorConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_ColorConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_ColorConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_ColorConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_ColorConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_ColorConfig& from) {
    UncompressedHeader_ColorConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_ColorConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.ColorConfig";
  }
  protected:
  explicit UncompressedHeader_ColorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UncompressedHeader_ColorConfig_ColorSpace ColorSpace;
  static constexpr ColorSpace CS_UNKNOWN =
    UncompressedHeader_ColorConfig_ColorSpace_CS_UNKNOWN;
  static constexpr ColorSpace CS_BT_601 =
    UncompressedHeader_ColorConfig_ColorSpace_CS_BT_601;
  static constexpr ColorSpace CS_BT_709 =
    UncompressedHeader_ColorConfig_ColorSpace_CS_BT_709;
  static constexpr ColorSpace CS_SMPTE_170 =
    UncompressedHeader_ColorConfig_ColorSpace_CS_SMPTE_170;
  static constexpr ColorSpace CS_SMPTE_240 =
    UncompressedHeader_ColorConfig_ColorSpace_CS_SMPTE_240;
  static constexpr ColorSpace CS_BT_2020 =
    UncompressedHeader_ColorConfig_ColorSpace_CS_BT_2020;
  static constexpr ColorSpace CS_RESERVED =
    UncompressedHeader_ColorConfig_ColorSpace_CS_RESERVED;
  static constexpr ColorSpace CS_RGB =
    UncompressedHeader_ColorConfig_ColorSpace_CS_RGB;
  static inline bool ColorSpace_IsValid(int value) {
    return UncompressedHeader_ColorConfig_ColorSpace_IsValid(value);
  }
  static constexpr ColorSpace ColorSpace_MIN =
    UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_MIN;
  static constexpr ColorSpace ColorSpace_MAX =
    UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_MAX;
  static constexpr int ColorSpace_ARRAYSIZE =
    UncompressedHeader_ColorConfig_ColorSpace_ColorSpace_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ColorSpace_descriptor() {
    return UncompressedHeader_ColorConfig_ColorSpace_descriptor();
  }
  template<typename T>
  static inline const std::string& ColorSpace_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorSpace>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorSpace_Name.");
    return UncompressedHeader_ColorConfig_ColorSpace_Name(enum_t_value);
  }
  static inline bool ColorSpace_Parse(::absl::string_view name,
      ColorSpace* value) {
    return UncompressedHeader_ColorConfig_ColorSpace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTenOrTwelveBitFieldNumber = 1,
    kColorSpaceFieldNumber = 2,
    kColorRangeFieldNumber = 3,
    kSubsamplingXFieldNumber = 4,
    kSubsamplingYFieldNumber = 5,
    kReservedZeroFieldNumber = 6,
  };
  // .VP9BitField ten_or_twelve_bit = 1;
  void clear_ten_or_twelve_bit();
  ::VP9BitField ten_or_twelve_bit() const;
  void set_ten_or_twelve_bit(::VP9BitField value);
  private:
  ::VP9BitField _internal_ten_or_twelve_bit() const;
  void _internal_set_ten_or_twelve_bit(::VP9BitField value);
  public:

  // uint32 color_space = 2;
  void clear_color_space();
  uint32_t color_space() const;
  void set_color_space(uint32_t value);
  private:
  uint32_t _internal_color_space() const;
  void _internal_set_color_space(uint32_t value);
  public:

  // .VP9BitField color_range = 3;
  void clear_color_range();
  ::VP9BitField color_range() const;
  void set_color_range(::VP9BitField value);
  private:
  ::VP9BitField _internal_color_range() const;
  void _internal_set_color_range(::VP9BitField value);
  public:

  // .VP9BitField subsampling_x = 4;
  void clear_subsampling_x();
  ::VP9BitField subsampling_x() const;
  void set_subsampling_x(::VP9BitField value);
  private:
  ::VP9BitField _internal_subsampling_x() const;
  void _internal_set_subsampling_x(::VP9BitField value);
  public:

  // .VP9BitField subsampling_y = 5;
  void clear_subsampling_y();
  ::VP9BitField subsampling_y() const;
  void set_subsampling_y(::VP9BitField value);
  private:
  ::VP9BitField _internal_subsampling_y() const;
  void _internal_set_subsampling_y(::VP9BitField value);
  public:

  // .VP9BitField reserved_zero = 6;
  void clear_reserved_zero();
  ::VP9BitField reserved_zero() const;
  void set_reserved_zero(::VP9BitField value);
  private:
  ::VP9BitField _internal_reserved_zero() const;
  void _internal_set_reserved_zero(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.ColorConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int ten_or_twelve_bit_;
    uint32_t color_space_;
    int color_range_;
    int subsampling_x_;
    int subsampling_y_;
    int reserved_zero_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_FrameSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.FrameSize) */ {
 public:
  inline UncompressedHeader_FrameSize() : UncompressedHeader_FrameSize(nullptr) {}
  ~UncompressedHeader_FrameSize() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_FrameSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_FrameSize(const UncompressedHeader_FrameSize& from);
  UncompressedHeader_FrameSize(UncompressedHeader_FrameSize&& from) noexcept
    : UncompressedHeader_FrameSize() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_FrameSize& operator=(const UncompressedHeader_FrameSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_FrameSize& operator=(UncompressedHeader_FrameSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_FrameSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_FrameSize* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_FrameSize*>(
               &_UncompressedHeader_FrameSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UncompressedHeader_FrameSize& a, UncompressedHeader_FrameSize& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_FrameSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_FrameSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_FrameSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_FrameSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_FrameSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_FrameSize& from) {
    UncompressedHeader_FrameSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_FrameSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.FrameSize";
  }
  protected:
  explicit UncompressedHeader_FrameSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameWidthMinus1FieldNumber = 1,
    kFrameHeightMinus1FieldNumber = 2,
  };
  // uint32 frame_width_minus_1 = 1;
  void clear_frame_width_minus_1();
  uint32_t frame_width_minus_1() const;
  void set_frame_width_minus_1(uint32_t value);
  private:
  uint32_t _internal_frame_width_minus_1() const;
  void _internal_set_frame_width_minus_1(uint32_t value);
  public:

  // uint32 frame_height_minus_1 = 2;
  void clear_frame_height_minus_1();
  uint32_t frame_height_minus_1() const;
  void set_frame_height_minus_1(uint32_t value);
  private:
  uint32_t _internal_frame_height_minus_1() const;
  void _internal_set_frame_height_minus_1(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.FrameSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t frame_width_minus_1_;
    uint32_t frame_height_minus_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_RenderSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.RenderSize) */ {
 public:
  inline UncompressedHeader_RenderSize() : UncompressedHeader_RenderSize(nullptr) {}
  ~UncompressedHeader_RenderSize() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_RenderSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_RenderSize(const UncompressedHeader_RenderSize& from);
  UncompressedHeader_RenderSize(UncompressedHeader_RenderSize&& from) noexcept
    : UncompressedHeader_RenderSize() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_RenderSize& operator=(const UncompressedHeader_RenderSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_RenderSize& operator=(UncompressedHeader_RenderSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_RenderSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_RenderSize* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_RenderSize*>(
               &_UncompressedHeader_RenderSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UncompressedHeader_RenderSize& a, UncompressedHeader_RenderSize& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_RenderSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_RenderSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_RenderSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_RenderSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_RenderSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_RenderSize& from) {
    UncompressedHeader_RenderSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_RenderSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.RenderSize";
  }
  protected:
  explicit UncompressedHeader_RenderSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRenderAndFrameSizeDifferentFieldNumber = 1,
    kRenderWidthMinus1FieldNumber = 2,
    kRenderHeightMinus1FieldNumber = 3,
  };
  // .VP9BitField render_and_frame_size_different = 1;
  void clear_render_and_frame_size_different();
  ::VP9BitField render_and_frame_size_different() const;
  void set_render_and_frame_size_different(::VP9BitField value);
  private:
  ::VP9BitField _internal_render_and_frame_size_different() const;
  void _internal_set_render_and_frame_size_different(::VP9BitField value);
  public:

  // uint32 render_width_minus_1 = 2;
  void clear_render_width_minus_1();
  uint32_t render_width_minus_1() const;
  void set_render_width_minus_1(uint32_t value);
  private:
  uint32_t _internal_render_width_minus_1() const;
  void _internal_set_render_width_minus_1(uint32_t value);
  public:

  // uint32 render_height_minus_1 = 3;
  void clear_render_height_minus_1();
  uint32_t render_height_minus_1() const;
  void set_render_height_minus_1(uint32_t value);
  private:
  uint32_t _internal_render_height_minus_1() const;
  void _internal_set_render_height_minus_1(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.RenderSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int render_and_frame_size_different_;
    uint32_t render_width_minus_1_;
    uint32_t render_height_minus_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_ReadInterpolationFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.ReadInterpolationFilter) */ {
 public:
  inline UncompressedHeader_ReadInterpolationFilter() : UncompressedHeader_ReadInterpolationFilter(nullptr) {}
  ~UncompressedHeader_ReadInterpolationFilter() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_ReadInterpolationFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_ReadInterpolationFilter(const UncompressedHeader_ReadInterpolationFilter& from);
  UncompressedHeader_ReadInterpolationFilter(UncompressedHeader_ReadInterpolationFilter&& from) noexcept
    : UncompressedHeader_ReadInterpolationFilter() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_ReadInterpolationFilter& operator=(const UncompressedHeader_ReadInterpolationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_ReadInterpolationFilter& operator=(UncompressedHeader_ReadInterpolationFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_ReadInterpolationFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_ReadInterpolationFilter* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_ReadInterpolationFilter*>(
               &_UncompressedHeader_ReadInterpolationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UncompressedHeader_ReadInterpolationFilter& a, UncompressedHeader_ReadInterpolationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_ReadInterpolationFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_ReadInterpolationFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_ReadInterpolationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_ReadInterpolationFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_ReadInterpolationFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_ReadInterpolationFilter& from) {
    UncompressedHeader_ReadInterpolationFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_ReadInterpolationFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.ReadInterpolationFilter";
  }
  protected:
  explicit UncompressedHeader_ReadInterpolationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsFilterSwitchableFieldNumber = 1,
    kRawInterpolationFilterFieldNumber = 2,
  };
  // .VP9BitField is_filter_switchable = 1;
  void clear_is_filter_switchable();
  ::VP9BitField is_filter_switchable() const;
  void set_is_filter_switchable(::VP9BitField value);
  private:
  ::VP9BitField _internal_is_filter_switchable() const;
  void _internal_set_is_filter_switchable(::VP9BitField value);
  public:

  // .UncompressedHeader.InterpolationFilter raw_interpolation_filter = 2;
  void clear_raw_interpolation_filter();
  ::UncompressedHeader_InterpolationFilter raw_interpolation_filter() const;
  void set_raw_interpolation_filter(::UncompressedHeader_InterpolationFilter value);
  private:
  ::UncompressedHeader_InterpolationFilter _internal_raw_interpolation_filter() const;
  void _internal_set_raw_interpolation_filter(::UncompressedHeader_InterpolationFilter value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.ReadInterpolationFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int is_filter_switchable_;
    int raw_interpolation_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_LoopFilterParams_RefDelta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.LoopFilterParams.RefDelta) */ {
 public:
  inline UncompressedHeader_LoopFilterParams_RefDelta() : UncompressedHeader_LoopFilterParams_RefDelta(nullptr) {}
  ~UncompressedHeader_LoopFilterParams_RefDelta() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_LoopFilterParams_RefDelta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_LoopFilterParams_RefDelta(const UncompressedHeader_LoopFilterParams_RefDelta& from);
  UncompressedHeader_LoopFilterParams_RefDelta(UncompressedHeader_LoopFilterParams_RefDelta&& from) noexcept
    : UncompressedHeader_LoopFilterParams_RefDelta() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_LoopFilterParams_RefDelta& operator=(const UncompressedHeader_LoopFilterParams_RefDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_LoopFilterParams_RefDelta& operator=(UncompressedHeader_LoopFilterParams_RefDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_LoopFilterParams_RefDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_LoopFilterParams_RefDelta* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_LoopFilterParams_RefDelta*>(
               &_UncompressedHeader_LoopFilterParams_RefDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UncompressedHeader_LoopFilterParams_RefDelta& a, UncompressedHeader_LoopFilterParams_RefDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_LoopFilterParams_RefDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_LoopFilterParams_RefDelta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_LoopFilterParams_RefDelta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_LoopFilterParams_RefDelta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_LoopFilterParams_RefDelta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_LoopFilterParams_RefDelta& from) {
    UncompressedHeader_LoopFilterParams_RefDelta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_LoopFilterParams_RefDelta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.LoopFilterParams.RefDelta";
  }
  protected:
  explicit UncompressedHeader_LoopFilterParams_RefDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoopFilterRefDeltasFieldNumber = 2,
    kUpdateRefDeltaFieldNumber = 1,
  };
  // .VP9SignedInteger loop_filter_ref_deltas = 2;
  bool has_loop_filter_ref_deltas() const;
  private:
  bool _internal_has_loop_filter_ref_deltas() const;
  public:
  void clear_loop_filter_ref_deltas();
  const ::VP9SignedInteger& loop_filter_ref_deltas() const;
  PROTOBUF_NODISCARD ::VP9SignedInteger* release_loop_filter_ref_deltas();
  ::VP9SignedInteger* mutable_loop_filter_ref_deltas();
  void set_allocated_loop_filter_ref_deltas(::VP9SignedInteger* loop_filter_ref_deltas);
  private:
  const ::VP9SignedInteger& _internal_loop_filter_ref_deltas() const;
  ::VP9SignedInteger* _internal_mutable_loop_filter_ref_deltas();
  public:
  void unsafe_arena_set_allocated_loop_filter_ref_deltas(
      ::VP9SignedInteger* loop_filter_ref_deltas);
  ::VP9SignedInteger* unsafe_arena_release_loop_filter_ref_deltas();

  // .VP9BitField update_ref_delta = 1;
  void clear_update_ref_delta();
  ::VP9BitField update_ref_delta() const;
  void set_update_ref_delta(::VP9BitField value);
  private:
  ::VP9BitField _internal_update_ref_delta() const;
  void _internal_set_update_ref_delta(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.LoopFilterParams.RefDelta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::VP9SignedInteger* loop_filter_ref_deltas_;
    int update_ref_delta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_LoopFilterParams_ModeDelta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.LoopFilterParams.ModeDelta) */ {
 public:
  inline UncompressedHeader_LoopFilterParams_ModeDelta() : UncompressedHeader_LoopFilterParams_ModeDelta(nullptr) {}
  ~UncompressedHeader_LoopFilterParams_ModeDelta() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_LoopFilterParams_ModeDelta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_LoopFilterParams_ModeDelta(const UncompressedHeader_LoopFilterParams_ModeDelta& from);
  UncompressedHeader_LoopFilterParams_ModeDelta(UncompressedHeader_LoopFilterParams_ModeDelta&& from) noexcept
    : UncompressedHeader_LoopFilterParams_ModeDelta() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_LoopFilterParams_ModeDelta& operator=(const UncompressedHeader_LoopFilterParams_ModeDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_LoopFilterParams_ModeDelta& operator=(UncompressedHeader_LoopFilterParams_ModeDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_LoopFilterParams_ModeDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_LoopFilterParams_ModeDelta* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_LoopFilterParams_ModeDelta*>(
               &_UncompressedHeader_LoopFilterParams_ModeDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UncompressedHeader_LoopFilterParams_ModeDelta& a, UncompressedHeader_LoopFilterParams_ModeDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_LoopFilterParams_ModeDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_LoopFilterParams_ModeDelta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_LoopFilterParams_ModeDelta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_LoopFilterParams_ModeDelta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_LoopFilterParams_ModeDelta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_LoopFilterParams_ModeDelta& from) {
    UncompressedHeader_LoopFilterParams_ModeDelta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_LoopFilterParams_ModeDelta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.LoopFilterParams.ModeDelta";
  }
  protected:
  explicit UncompressedHeader_LoopFilterParams_ModeDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoopFilterModeDeltasFieldNumber = 2,
    kUpdateModeDeltaFieldNumber = 1,
  };
  // .VP9SignedInteger loop_filter_mode_deltas = 2;
  bool has_loop_filter_mode_deltas() const;
  private:
  bool _internal_has_loop_filter_mode_deltas() const;
  public:
  void clear_loop_filter_mode_deltas();
  const ::VP9SignedInteger& loop_filter_mode_deltas() const;
  PROTOBUF_NODISCARD ::VP9SignedInteger* release_loop_filter_mode_deltas();
  ::VP9SignedInteger* mutable_loop_filter_mode_deltas();
  void set_allocated_loop_filter_mode_deltas(::VP9SignedInteger* loop_filter_mode_deltas);
  private:
  const ::VP9SignedInteger& _internal_loop_filter_mode_deltas() const;
  ::VP9SignedInteger* _internal_mutable_loop_filter_mode_deltas();
  public:
  void unsafe_arena_set_allocated_loop_filter_mode_deltas(
      ::VP9SignedInteger* loop_filter_mode_deltas);
  ::VP9SignedInteger* unsafe_arena_release_loop_filter_mode_deltas();

  // .VP9BitField update_mode_delta = 1;
  void clear_update_mode_delta();
  ::VP9BitField update_mode_delta() const;
  void set_update_mode_delta(::VP9BitField value);
  private:
  ::VP9BitField _internal_update_mode_delta() const;
  void _internal_set_update_mode_delta(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.LoopFilterParams.ModeDelta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::VP9SignedInteger* loop_filter_mode_deltas_;
    int update_mode_delta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_LoopFilterParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.LoopFilterParams) */ {
 public:
  inline UncompressedHeader_LoopFilterParams() : UncompressedHeader_LoopFilterParams(nullptr) {}
  ~UncompressedHeader_LoopFilterParams() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_LoopFilterParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_LoopFilterParams(const UncompressedHeader_LoopFilterParams& from);
  UncompressedHeader_LoopFilterParams(UncompressedHeader_LoopFilterParams&& from) noexcept
    : UncompressedHeader_LoopFilterParams() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_LoopFilterParams& operator=(const UncompressedHeader_LoopFilterParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_LoopFilterParams& operator=(UncompressedHeader_LoopFilterParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_LoopFilterParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_LoopFilterParams* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_LoopFilterParams*>(
               &_UncompressedHeader_LoopFilterParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UncompressedHeader_LoopFilterParams& a, UncompressedHeader_LoopFilterParams& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_LoopFilterParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_LoopFilterParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_LoopFilterParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_LoopFilterParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_LoopFilterParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_LoopFilterParams& from) {
    UncompressedHeader_LoopFilterParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_LoopFilterParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.LoopFilterParams";
  }
  protected:
  explicit UncompressedHeader_LoopFilterParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UncompressedHeader_LoopFilterParams_RefDelta RefDelta;
  typedef UncompressedHeader_LoopFilterParams_ModeDelta ModeDelta;

  // accessors -------------------------------------------------------

  enum : int {
    kRefDeltaFieldNumber = 5,
    kModeDeltaFieldNumber = 6,
    kLoopFilterLevelFieldNumber = 1,
    kLoopFilterSharpnessFieldNumber = 2,
    kLoopFilterDeltaEnabledFieldNumber = 3,
    kLoopFilterDeltaUpdateFieldNumber = 4,
  };
  // repeated .UncompressedHeader.LoopFilterParams.RefDelta ref_delta = 5;
  int ref_delta_size() const;
  private:
  int _internal_ref_delta_size() const;
  public:
  void clear_ref_delta();
  ::UncompressedHeader_LoopFilterParams_RefDelta* mutable_ref_delta(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_RefDelta >*
      mutable_ref_delta();
  private:
  const ::UncompressedHeader_LoopFilterParams_RefDelta& _internal_ref_delta(int index) const;
  ::UncompressedHeader_LoopFilterParams_RefDelta* _internal_add_ref_delta();
  public:
  const ::UncompressedHeader_LoopFilterParams_RefDelta& ref_delta(int index) const;
  ::UncompressedHeader_LoopFilterParams_RefDelta* add_ref_delta();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_RefDelta >&
      ref_delta() const;

  // repeated .UncompressedHeader.LoopFilterParams.ModeDelta mode_delta = 6;
  int mode_delta_size() const;
  private:
  int _internal_mode_delta_size() const;
  public:
  void clear_mode_delta();
  ::UncompressedHeader_LoopFilterParams_ModeDelta* mutable_mode_delta(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_ModeDelta >*
      mutable_mode_delta();
  private:
  const ::UncompressedHeader_LoopFilterParams_ModeDelta& _internal_mode_delta(int index) const;
  ::UncompressedHeader_LoopFilterParams_ModeDelta* _internal_add_mode_delta();
  public:
  const ::UncompressedHeader_LoopFilterParams_ModeDelta& mode_delta(int index) const;
  ::UncompressedHeader_LoopFilterParams_ModeDelta* add_mode_delta();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_ModeDelta >&
      mode_delta() const;

  // uint32 loop_filter_level = 1;
  void clear_loop_filter_level();
  uint32_t loop_filter_level() const;
  void set_loop_filter_level(uint32_t value);
  private:
  uint32_t _internal_loop_filter_level() const;
  void _internal_set_loop_filter_level(uint32_t value);
  public:

  // uint32 loop_filter_sharpness = 2;
  void clear_loop_filter_sharpness();
  uint32_t loop_filter_sharpness() const;
  void set_loop_filter_sharpness(uint32_t value);
  private:
  uint32_t _internal_loop_filter_sharpness() const;
  void _internal_set_loop_filter_sharpness(uint32_t value);
  public:

  // .VP9BitField loop_filter_delta_enabled = 3;
  void clear_loop_filter_delta_enabled();
  ::VP9BitField loop_filter_delta_enabled() const;
  void set_loop_filter_delta_enabled(::VP9BitField value);
  private:
  ::VP9BitField _internal_loop_filter_delta_enabled() const;
  void _internal_set_loop_filter_delta_enabled(::VP9BitField value);
  public:

  // .VP9BitField loop_filter_delta_update = 4;
  void clear_loop_filter_delta_update();
  ::VP9BitField loop_filter_delta_update() const;
  void set_loop_filter_delta_update(::VP9BitField value);
  private:
  ::VP9BitField _internal_loop_filter_delta_update() const;
  void _internal_set_loop_filter_delta_update(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.LoopFilterParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_RefDelta > ref_delta_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_ModeDelta > mode_delta_;
    uint32_t loop_filter_level_;
    uint32_t loop_filter_sharpness_;
    int loop_filter_delta_enabled_;
    int loop_filter_delta_update_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_QuantizationParams_ReadDeltaQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.QuantizationParams.ReadDeltaQ) */ {
 public:
  inline UncompressedHeader_QuantizationParams_ReadDeltaQ() : UncompressedHeader_QuantizationParams_ReadDeltaQ(nullptr) {}
  ~UncompressedHeader_QuantizationParams_ReadDeltaQ() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_QuantizationParams_ReadDeltaQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_QuantizationParams_ReadDeltaQ(const UncompressedHeader_QuantizationParams_ReadDeltaQ& from);
  UncompressedHeader_QuantizationParams_ReadDeltaQ(UncompressedHeader_QuantizationParams_ReadDeltaQ&& from) noexcept
    : UncompressedHeader_QuantizationParams_ReadDeltaQ() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_QuantizationParams_ReadDeltaQ& operator=(const UncompressedHeader_QuantizationParams_ReadDeltaQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_QuantizationParams_ReadDeltaQ& operator=(UncompressedHeader_QuantizationParams_ReadDeltaQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_QuantizationParams_ReadDeltaQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_QuantizationParams_ReadDeltaQ* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_QuantizationParams_ReadDeltaQ*>(
               &_UncompressedHeader_QuantizationParams_ReadDeltaQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UncompressedHeader_QuantizationParams_ReadDeltaQ& a, UncompressedHeader_QuantizationParams_ReadDeltaQ& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_QuantizationParams_ReadDeltaQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_QuantizationParams_ReadDeltaQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_QuantizationParams_ReadDeltaQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_QuantizationParams_ReadDeltaQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_QuantizationParams_ReadDeltaQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_QuantizationParams_ReadDeltaQ& from) {
    UncompressedHeader_QuantizationParams_ReadDeltaQ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_QuantizationParams_ReadDeltaQ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.QuantizationParams.ReadDeltaQ";
  }
  protected:
  explicit UncompressedHeader_QuantizationParams_ReadDeltaQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaQFieldNumber = 2,
    kDeltaCodedFieldNumber = 1,
  };
  // .VP9SignedInteger delta_q = 2;
  bool has_delta_q() const;
  private:
  bool _internal_has_delta_q() const;
  public:
  void clear_delta_q();
  const ::VP9SignedInteger& delta_q() const;
  PROTOBUF_NODISCARD ::VP9SignedInteger* release_delta_q();
  ::VP9SignedInteger* mutable_delta_q();
  void set_allocated_delta_q(::VP9SignedInteger* delta_q);
  private:
  const ::VP9SignedInteger& _internal_delta_q() const;
  ::VP9SignedInteger* _internal_mutable_delta_q();
  public:
  void unsafe_arena_set_allocated_delta_q(
      ::VP9SignedInteger* delta_q);
  ::VP9SignedInteger* unsafe_arena_release_delta_q();

  // .VP9BitField delta_coded = 1;
  void clear_delta_coded();
  ::VP9BitField delta_coded() const;
  void set_delta_coded(::VP9BitField value);
  private:
  ::VP9BitField _internal_delta_coded() const;
  void _internal_set_delta_coded(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.QuantizationParams.ReadDeltaQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::VP9SignedInteger* delta_q_;
    int delta_coded_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_QuantizationParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.QuantizationParams) */ {
 public:
  inline UncompressedHeader_QuantizationParams() : UncompressedHeader_QuantizationParams(nullptr) {}
  ~UncompressedHeader_QuantizationParams() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_QuantizationParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_QuantizationParams(const UncompressedHeader_QuantizationParams& from);
  UncompressedHeader_QuantizationParams(UncompressedHeader_QuantizationParams&& from) noexcept
    : UncompressedHeader_QuantizationParams() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_QuantizationParams& operator=(const UncompressedHeader_QuantizationParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_QuantizationParams& operator=(UncompressedHeader_QuantizationParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_QuantizationParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_QuantizationParams* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_QuantizationParams*>(
               &_UncompressedHeader_QuantizationParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UncompressedHeader_QuantizationParams& a, UncompressedHeader_QuantizationParams& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_QuantizationParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_QuantizationParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_QuantizationParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_QuantizationParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_QuantizationParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_QuantizationParams& from) {
    UncompressedHeader_QuantizationParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_QuantizationParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.QuantizationParams";
  }
  protected:
  explicit UncompressedHeader_QuantizationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UncompressedHeader_QuantizationParams_ReadDeltaQ ReadDeltaQ;

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaQYDcFieldNumber = 2,
    kDeltaQUvDcFieldNumber = 3,
    kDeltaQUvAcFieldNumber = 4,
    kBaseQIdxFieldNumber = 1,
  };
  // .UncompressedHeader.QuantizationParams.ReadDeltaQ delta_q_y_dc = 2;
  bool has_delta_q_y_dc() const;
  private:
  bool _internal_has_delta_q_y_dc() const;
  public:
  void clear_delta_q_y_dc();
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& delta_q_y_dc() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_QuantizationParams_ReadDeltaQ* release_delta_q_y_dc();
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* mutable_delta_q_y_dc();
  void set_allocated_delta_q_y_dc(::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_y_dc);
  private:
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& _internal_delta_q_y_dc() const;
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* _internal_mutable_delta_q_y_dc();
  public:
  void unsafe_arena_set_allocated_delta_q_y_dc(
      ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_y_dc);
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* unsafe_arena_release_delta_q_y_dc();

  // .UncompressedHeader.QuantizationParams.ReadDeltaQ delta_q_uv_dc = 3;
  bool has_delta_q_uv_dc() const;
  private:
  bool _internal_has_delta_q_uv_dc() const;
  public:
  void clear_delta_q_uv_dc();
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& delta_q_uv_dc() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_QuantizationParams_ReadDeltaQ* release_delta_q_uv_dc();
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* mutable_delta_q_uv_dc();
  void set_allocated_delta_q_uv_dc(::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_dc);
  private:
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& _internal_delta_q_uv_dc() const;
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* _internal_mutable_delta_q_uv_dc();
  public:
  void unsafe_arena_set_allocated_delta_q_uv_dc(
      ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_dc);
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* unsafe_arena_release_delta_q_uv_dc();

  // .UncompressedHeader.QuantizationParams.ReadDeltaQ delta_q_uv_ac = 4;
  bool has_delta_q_uv_ac() const;
  private:
  bool _internal_has_delta_q_uv_ac() const;
  public:
  void clear_delta_q_uv_ac();
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& delta_q_uv_ac() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_QuantizationParams_ReadDeltaQ* release_delta_q_uv_ac();
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* mutable_delta_q_uv_ac();
  void set_allocated_delta_q_uv_ac(::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_ac);
  private:
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& _internal_delta_q_uv_ac() const;
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* _internal_mutable_delta_q_uv_ac();
  public:
  void unsafe_arena_set_allocated_delta_q_uv_ac(
      ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_ac);
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* unsafe_arena_release_delta_q_uv_ac();

  // uint32 base_q_idx = 1;
  void clear_base_q_idx();
  uint32_t base_q_idx() const;
  void set_base_q_idx(uint32_t value);
  private:
  uint32_t _internal_base_q_idx() const;
  void _internal_set_base_q_idx(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.QuantizationParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_y_dc_;
    ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_dc_;
    ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_ac_;
    uint32_t base_q_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_TileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.TileInfo) */ {
 public:
  inline UncompressedHeader_TileInfo() : UncompressedHeader_TileInfo(nullptr) {}
  ~UncompressedHeader_TileInfo() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_TileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_TileInfo(const UncompressedHeader_TileInfo& from);
  UncompressedHeader_TileInfo(UncompressedHeader_TileInfo&& from) noexcept
    : UncompressedHeader_TileInfo() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_TileInfo& operator=(const UncompressedHeader_TileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_TileInfo& operator=(UncompressedHeader_TileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_TileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_TileInfo* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_TileInfo*>(
               &_UncompressedHeader_TileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UncompressedHeader_TileInfo& a, UncompressedHeader_TileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_TileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_TileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_TileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_TileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_TileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_TileInfo& from) {
    UncompressedHeader_TileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_TileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.TileInfo";
  }
  protected:
  explicit UncompressedHeader_TileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTileRowsLog2FieldNumber = 1,
    kIncrementTileRowsLog2FieldNumber = 2,
  };
  // .VP9BitField tile_rows_log2 = 1;
  void clear_tile_rows_log2();
  ::VP9BitField tile_rows_log2() const;
  void set_tile_rows_log2(::VP9BitField value);
  private:
  ::VP9BitField _internal_tile_rows_log2() const;
  void _internal_set_tile_rows_log2(::VP9BitField value);
  public:

  // .VP9BitField increment_tile_rows_log2 = 2;
  void clear_increment_tile_rows_log2();
  ::VP9BitField increment_tile_rows_log2() const;
  void set_increment_tile_rows_log2(::VP9BitField value);
  private:
  ::VP9BitField _internal_increment_tile_rows_log2() const;
  void _internal_set_increment_tile_rows_log2(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.TileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int tile_rows_log2_;
    int increment_tile_rows_log2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_SegmentationParams_ReadProb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.SegmentationParams.ReadProb) */ {
 public:
  inline UncompressedHeader_SegmentationParams_ReadProb() : UncompressedHeader_SegmentationParams_ReadProb(nullptr) {}
  ~UncompressedHeader_SegmentationParams_ReadProb() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_SegmentationParams_ReadProb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_SegmentationParams_ReadProb(const UncompressedHeader_SegmentationParams_ReadProb& from);
  UncompressedHeader_SegmentationParams_ReadProb(UncompressedHeader_SegmentationParams_ReadProb&& from) noexcept
    : UncompressedHeader_SegmentationParams_ReadProb() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_SegmentationParams_ReadProb& operator=(const UncompressedHeader_SegmentationParams_ReadProb& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_SegmentationParams_ReadProb& operator=(UncompressedHeader_SegmentationParams_ReadProb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_SegmentationParams_ReadProb& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_SegmentationParams_ReadProb* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_SegmentationParams_ReadProb*>(
               &_UncompressedHeader_SegmentationParams_ReadProb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UncompressedHeader_SegmentationParams_ReadProb& a, UncompressedHeader_SegmentationParams_ReadProb& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_SegmentationParams_ReadProb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_SegmentationParams_ReadProb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_SegmentationParams_ReadProb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_SegmentationParams_ReadProb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_SegmentationParams_ReadProb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_SegmentationParams_ReadProb& from) {
    UncompressedHeader_SegmentationParams_ReadProb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_SegmentationParams_ReadProb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.SegmentationParams.ReadProb";
  }
  protected:
  explicit UncompressedHeader_SegmentationParams_ReadProb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProbCodedFieldNumber = 1,
    kProbFieldNumber = 2,
  };
  // .VP9BitField prob_coded = 1;
  void clear_prob_coded();
  ::VP9BitField prob_coded() const;
  void set_prob_coded(::VP9BitField value);
  private:
  ::VP9BitField _internal_prob_coded() const;
  void _internal_set_prob_coded(::VP9BitField value);
  public:

  // uint32 prob = 2;
  void clear_prob();
  uint32_t prob() const;
  void set_prob(uint32_t value);
  private:
  uint32_t _internal_prob() const;
  void _internal_set_prob(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.SegmentationParams.ReadProb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int prob_coded_;
    uint32_t prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_SegmentationParams_Feature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.SegmentationParams.Feature) */ {
 public:
  inline UncompressedHeader_SegmentationParams_Feature() : UncompressedHeader_SegmentationParams_Feature(nullptr) {}
  ~UncompressedHeader_SegmentationParams_Feature() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_SegmentationParams_Feature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_SegmentationParams_Feature(const UncompressedHeader_SegmentationParams_Feature& from);
  UncompressedHeader_SegmentationParams_Feature(UncompressedHeader_SegmentationParams_Feature&& from) noexcept
    : UncompressedHeader_SegmentationParams_Feature() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_SegmentationParams_Feature& operator=(const UncompressedHeader_SegmentationParams_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_SegmentationParams_Feature& operator=(UncompressedHeader_SegmentationParams_Feature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_SegmentationParams_Feature& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_SegmentationParams_Feature* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_SegmentationParams_Feature*>(
               &_UncompressedHeader_SegmentationParams_Feature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UncompressedHeader_SegmentationParams_Feature& a, UncompressedHeader_SegmentationParams_Feature& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_SegmentationParams_Feature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_SegmentationParams_Feature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_SegmentationParams_Feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_SegmentationParams_Feature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_SegmentationParams_Feature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_SegmentationParams_Feature& from) {
    UncompressedHeader_SegmentationParams_Feature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_SegmentationParams_Feature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.SegmentationParams.Feature";
  }
  protected:
  explicit UncompressedHeader_SegmentationParams_Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureValueFieldNumber = 2,
    kFeatureEnabledFieldNumber = 1,
    kFeatureSignFieldNumber = 3,
  };
  // bytes feature_value = 2;
  void clear_feature_value();
  const std::string& feature_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feature_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feature_value();
  PROTOBUF_NODISCARD std::string* release_feature_value();
  void set_allocated_feature_value(std::string* feature_value);
  private:
  const std::string& _internal_feature_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feature_value(const std::string& value);
  std::string* _internal_mutable_feature_value();
  public:

  // .VP9BitField feature_enabled = 1;
  void clear_feature_enabled();
  ::VP9BitField feature_enabled() const;
  void set_feature_enabled(::VP9BitField value);
  private:
  ::VP9BitField _internal_feature_enabled() const;
  void _internal_set_feature_enabled(::VP9BitField value);
  public:

  // .VP9BitField feature_sign = 3;
  void clear_feature_sign();
  ::VP9BitField feature_sign() const;
  void set_feature_sign(::VP9BitField value);
  private:
  ::VP9BitField _internal_feature_sign() const;
  void _internal_set_feature_sign(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.SegmentationParams.Feature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_value_;
    int feature_enabled_;
    int feature_sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_SegmentationParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.SegmentationParams) */ {
 public:
  inline UncompressedHeader_SegmentationParams() : UncompressedHeader_SegmentationParams(nullptr) {}
  ~UncompressedHeader_SegmentationParams() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_SegmentationParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_SegmentationParams(const UncompressedHeader_SegmentationParams& from);
  UncompressedHeader_SegmentationParams(UncompressedHeader_SegmentationParams&& from) noexcept
    : UncompressedHeader_SegmentationParams() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_SegmentationParams& operator=(const UncompressedHeader_SegmentationParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_SegmentationParams& operator=(UncompressedHeader_SegmentationParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_SegmentationParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_SegmentationParams* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_SegmentationParams*>(
               &_UncompressedHeader_SegmentationParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UncompressedHeader_SegmentationParams& a, UncompressedHeader_SegmentationParams& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_SegmentationParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_SegmentationParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_SegmentationParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_SegmentationParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_SegmentationParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_SegmentationParams& from) {
    UncompressedHeader_SegmentationParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_SegmentationParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.SegmentationParams";
  }
  protected:
  explicit UncompressedHeader_SegmentationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UncompressedHeader_SegmentationParams_ReadProb ReadProb;
  typedef UncompressedHeader_SegmentationParams_Feature Feature;

  // accessors -------------------------------------------------------

  enum : int {
    kProbFieldNumber = 4,
    kFeaturesFieldNumber = 7,
    kSegmentationEnabledFieldNumber = 1,
    kSegmentationUpdateMapFieldNumber = 2,
    kSegmentationTemporalUpdateFieldNumber = 3,
    kSegmentationUpdateDataFieldNumber = 5,
    kSegmentationAbsOrDeltaUpdateFieldNumber = 6,
  };
  // repeated .UncompressedHeader.SegmentationParams.ReadProb prob = 4;
  int prob_size() const;
  private:
  int _internal_prob_size() const;
  public:
  void clear_prob();
  ::UncompressedHeader_SegmentationParams_ReadProb* mutable_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_ReadProb >*
      mutable_prob();
  private:
  const ::UncompressedHeader_SegmentationParams_ReadProb& _internal_prob(int index) const;
  ::UncompressedHeader_SegmentationParams_ReadProb* _internal_add_prob();
  public:
  const ::UncompressedHeader_SegmentationParams_ReadProb& prob(int index) const;
  ::UncompressedHeader_SegmentationParams_ReadProb* add_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_ReadProb >&
      prob() const;

  // repeated .UncompressedHeader.SegmentationParams.Feature features = 7;
  int features_size() const;
  private:
  int _internal_features_size() const;
  public:
  void clear_features();
  ::UncompressedHeader_SegmentationParams_Feature* mutable_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_Feature >*
      mutable_features();
  private:
  const ::UncompressedHeader_SegmentationParams_Feature& _internal_features(int index) const;
  ::UncompressedHeader_SegmentationParams_Feature* _internal_add_features();
  public:
  const ::UncompressedHeader_SegmentationParams_Feature& features(int index) const;
  ::UncompressedHeader_SegmentationParams_Feature* add_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_Feature >&
      features() const;

  // .VP9BitField segmentation_enabled = 1;
  void clear_segmentation_enabled();
  ::VP9BitField segmentation_enabled() const;
  void set_segmentation_enabled(::VP9BitField value);
  private:
  ::VP9BitField _internal_segmentation_enabled() const;
  void _internal_set_segmentation_enabled(::VP9BitField value);
  public:

  // .VP9BitField segmentation_update_map = 2;
  void clear_segmentation_update_map();
  ::VP9BitField segmentation_update_map() const;
  void set_segmentation_update_map(::VP9BitField value);
  private:
  ::VP9BitField _internal_segmentation_update_map() const;
  void _internal_set_segmentation_update_map(::VP9BitField value);
  public:

  // .VP9BitField segmentation_temporal_update = 3;
  void clear_segmentation_temporal_update();
  ::VP9BitField segmentation_temporal_update() const;
  void set_segmentation_temporal_update(::VP9BitField value);
  private:
  ::VP9BitField _internal_segmentation_temporal_update() const;
  void _internal_set_segmentation_temporal_update(::VP9BitField value);
  public:

  // .VP9BitField segmentation_update_data = 5;
  void clear_segmentation_update_data();
  ::VP9BitField segmentation_update_data() const;
  void set_segmentation_update_data(::VP9BitField value);
  private:
  ::VP9BitField _internal_segmentation_update_data() const;
  void _internal_set_segmentation_update_data(::VP9BitField value);
  public:

  // .VP9BitField segmentation_abs_or_delta_update = 6;
  void clear_segmentation_abs_or_delta_update();
  ::VP9BitField segmentation_abs_or_delta_update() const;
  void set_segmentation_abs_or_delta_update(::VP9BitField value);
  private:
  ::VP9BitField _internal_segmentation_abs_or_delta_update() const;
  void _internal_set_segmentation_abs_or_delta_update(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.SegmentationParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_ReadProb > prob_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_Feature > features_;
    int segmentation_enabled_;
    int segmentation_update_map_;
    int segmentation_temporal_update_;
    int segmentation_update_data_;
    int segmentation_abs_or_delta_update_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader) */ {
 public:
  inline UncompressedHeader() : UncompressedHeader(nullptr) {}
  ~UncompressedHeader() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader(const UncompressedHeader& from);
  UncompressedHeader(UncompressedHeader&& from) noexcept
    : UncompressedHeader() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader& operator=(const UncompressedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader& operator=(UncompressedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader*>(
               &_UncompressedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UncompressedHeader& a, UncompressedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader& from) {
    UncompressedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader";
  }
  protected:
  explicit UncompressedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UncompressedHeader_ColorConfig ColorConfig;
  typedef UncompressedHeader_FrameSize FrameSize;
  typedef UncompressedHeader_RenderSize RenderSize;
  typedef UncompressedHeader_ReadInterpolationFilter ReadInterpolationFilter;
  typedef UncompressedHeader_LoopFilterParams LoopFilterParams;
  typedef UncompressedHeader_QuantizationParams QuantizationParams;
  typedef UncompressedHeader_TileInfo TileInfo;
  typedef UncompressedHeader_SegmentationParams SegmentationParams;

  typedef UncompressedHeader_FrameType FrameType;
  static constexpr FrameType KEY_FRAME =
    UncompressedHeader_FrameType_KEY_FRAME;
  static constexpr FrameType NON_KEY_FRAME =
    UncompressedHeader_FrameType_NON_KEY_FRAME;
  static inline bool FrameType_IsValid(int value) {
    return UncompressedHeader_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN =
    UncompressedHeader_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX =
    UncompressedHeader_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE =
    UncompressedHeader_FrameType_FrameType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FrameType_descriptor() {
    return UncompressedHeader_FrameType_descriptor();
  }
  template<typename T>
  static inline const std::string& FrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameType_Name.");
    return UncompressedHeader_FrameType_Name(enum_t_value);
  }
  static inline bool FrameType_Parse(::absl::string_view name,
      FrameType* value) {
    return UncompressedHeader_FrameType_Parse(name, value);
  }

  typedef UncompressedHeader_InterpolationFilter InterpolationFilter;
  static constexpr InterpolationFilter EIGHTTAP =
    UncompressedHeader_InterpolationFilter_EIGHTTAP;
  static constexpr InterpolationFilter EIGHTTAP_SMOOTH =
    UncompressedHeader_InterpolationFilter_EIGHTTAP_SMOOTH;
  static constexpr InterpolationFilter EIGHTTAP_SHARP =
    UncompressedHeader_InterpolationFilter_EIGHTTAP_SHARP;
  static constexpr InterpolationFilter BILINEAR =
    UncompressedHeader_InterpolationFilter_BILINEAR;
  static constexpr InterpolationFilter SWITCHABLE =
    UncompressedHeader_InterpolationFilter_SWITCHABLE;
  static inline bool InterpolationFilter_IsValid(int value) {
    return UncompressedHeader_InterpolationFilter_IsValid(value);
  }
  static constexpr InterpolationFilter InterpolationFilter_MIN =
    UncompressedHeader_InterpolationFilter_InterpolationFilter_MIN;
  static constexpr InterpolationFilter InterpolationFilter_MAX =
    UncompressedHeader_InterpolationFilter_InterpolationFilter_MAX;
  static constexpr int InterpolationFilter_ARRAYSIZE =
    UncompressedHeader_InterpolationFilter_InterpolationFilter_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InterpolationFilter_descriptor() {
    return UncompressedHeader_InterpolationFilter_descriptor();
  }
  template<typename T>
  static inline const std::string& InterpolationFilter_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InterpolationFilter>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InterpolationFilter_Name.");
    return UncompressedHeader_InterpolationFilter_Name(enum_t_value);
  }
  static inline bool InterpolationFilter_Parse(::absl::string_view name,
      InterpolationFilter* value) {
    return UncompressedHeader_InterpolationFilter_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRefFrameIdxFieldNumber = 17,
    kRefFrameSignBiasFieldNumber = 18,
    kColorConfigFieldNumber = 10,
    kFrameSizeFieldNumber = 12,
    kRenderSizeFieldNumber = 13,
    kReadInterpolationFilterFieldNumber = 20,
    kLoopFilterParamsFieldNumber = 24,
    kQuantizationParamsFieldNumber = 25,
    kSegmentationParamsFieldNumber = 26,
    kTileInfoFieldNumber = 27,
    kProfileLowBitFieldNumber = 1,
    kProfileHighBitFieldNumber = 2,
    kReservedZeroFieldNumber = 3,
    kShowExistingFrameFieldNumber = 4,
    kFrameToShowMapIdxFieldNumber = 5,
    kFrameTypeFieldNumber = 6,
    kShowFrameFieldNumber = 7,
    kErrorResilientModeFieldNumber = 8,
    kFrameSyncCodeFieldNumber = 9,
    kFrameSizeFoundRefFieldNumber = 11,
    kIntraOnlyFieldNumber = 14,
    kResetFrameContextFieldNumber = 15,
    kRefreshFrameFlagsFieldNumber = 16,
    kAllowHighPrecisionMvFieldNumber = 19,
    kRefreshFrameContextFieldNumber = 21,
    kFrameParallelDecodingModeFieldNumber = 22,
    kFrameContextIdxFieldNumber = 23,
    kHeaderSizeInBytesFieldNumber = 28,
  };
  // repeated uint32 ref_frame_idx = 17;
  int ref_frame_idx_size() const;
  private:
  int _internal_ref_frame_idx_size() const;
  public:
  void clear_ref_frame_idx();
  private:
  uint32_t _internal_ref_frame_idx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_ref_frame_idx() const;
  void _internal_add_ref_frame_idx(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_ref_frame_idx();
  public:
  uint32_t ref_frame_idx(int index) const;
  void set_ref_frame_idx(int index, uint32_t value);
  void add_ref_frame_idx(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      ref_frame_idx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_ref_frame_idx();

  // repeated .VP9BitField ref_frame_sign_bias = 18;
  int ref_frame_sign_bias_size() const;
  private:
  int _internal_ref_frame_sign_bias_size() const;
  public:
  void clear_ref_frame_sign_bias();
  private:
  ::VP9BitField _internal_ref_frame_sign_bias(int index) const;
  void _internal_add_ref_frame_sign_bias(::VP9BitField value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_ref_frame_sign_bias();
  public:
  ::VP9BitField ref_frame_sign_bias(int index) const;
  void set_ref_frame_sign_bias(int index, ::VP9BitField value);
  void add_ref_frame_sign_bias(::VP9BitField value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ref_frame_sign_bias() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ref_frame_sign_bias();

  // .UncompressedHeader.ColorConfig color_config = 10;
  bool has_color_config() const;
  private:
  bool _internal_has_color_config() const;
  public:
  void clear_color_config();
  const ::UncompressedHeader_ColorConfig& color_config() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_ColorConfig* release_color_config();
  ::UncompressedHeader_ColorConfig* mutable_color_config();
  void set_allocated_color_config(::UncompressedHeader_ColorConfig* color_config);
  private:
  const ::UncompressedHeader_ColorConfig& _internal_color_config() const;
  ::UncompressedHeader_ColorConfig* _internal_mutable_color_config();
  public:
  void unsafe_arena_set_allocated_color_config(
      ::UncompressedHeader_ColorConfig* color_config);
  ::UncompressedHeader_ColorConfig* unsafe_arena_release_color_config();

  // .UncompressedHeader.FrameSize frame_size = 12;
  bool has_frame_size() const;
  private:
  bool _internal_has_frame_size() const;
  public:
  void clear_frame_size();
  const ::UncompressedHeader_FrameSize& frame_size() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_FrameSize* release_frame_size();
  ::UncompressedHeader_FrameSize* mutable_frame_size();
  void set_allocated_frame_size(::UncompressedHeader_FrameSize* frame_size);
  private:
  const ::UncompressedHeader_FrameSize& _internal_frame_size() const;
  ::UncompressedHeader_FrameSize* _internal_mutable_frame_size();
  public:
  void unsafe_arena_set_allocated_frame_size(
      ::UncompressedHeader_FrameSize* frame_size);
  ::UncompressedHeader_FrameSize* unsafe_arena_release_frame_size();

  // .UncompressedHeader.RenderSize render_size = 13;
  bool has_render_size() const;
  private:
  bool _internal_has_render_size() const;
  public:
  void clear_render_size();
  const ::UncompressedHeader_RenderSize& render_size() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_RenderSize* release_render_size();
  ::UncompressedHeader_RenderSize* mutable_render_size();
  void set_allocated_render_size(::UncompressedHeader_RenderSize* render_size);
  private:
  const ::UncompressedHeader_RenderSize& _internal_render_size() const;
  ::UncompressedHeader_RenderSize* _internal_mutable_render_size();
  public:
  void unsafe_arena_set_allocated_render_size(
      ::UncompressedHeader_RenderSize* render_size);
  ::UncompressedHeader_RenderSize* unsafe_arena_release_render_size();

  // .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
  bool has_read_interpolation_filter() const;
  private:
  bool _internal_has_read_interpolation_filter() const;
  public:
  void clear_read_interpolation_filter();
  const ::UncompressedHeader_ReadInterpolationFilter& read_interpolation_filter() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_ReadInterpolationFilter* release_read_interpolation_filter();
  ::UncompressedHeader_ReadInterpolationFilter* mutable_read_interpolation_filter();
  void set_allocated_read_interpolation_filter(::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter);
  private:
  const ::UncompressedHeader_ReadInterpolationFilter& _internal_read_interpolation_filter() const;
  ::UncompressedHeader_ReadInterpolationFilter* _internal_mutable_read_interpolation_filter();
  public:
  void unsafe_arena_set_allocated_read_interpolation_filter(
      ::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter);
  ::UncompressedHeader_ReadInterpolationFilter* unsafe_arena_release_read_interpolation_filter();

  // .UncompressedHeader.LoopFilterParams loop_filter_params = 24;
  bool has_loop_filter_params() const;
  private:
  bool _internal_has_loop_filter_params() const;
  public:
  void clear_loop_filter_params();
  const ::UncompressedHeader_LoopFilterParams& loop_filter_params() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_LoopFilterParams* release_loop_filter_params();
  ::UncompressedHeader_LoopFilterParams* mutable_loop_filter_params();
  void set_allocated_loop_filter_params(::UncompressedHeader_LoopFilterParams* loop_filter_params);
  private:
  const ::UncompressedHeader_LoopFilterParams& _internal_loop_filter_params() const;
  ::UncompressedHeader_LoopFilterParams* _internal_mutable_loop_filter_params();
  public:
  void unsafe_arena_set_allocated_loop_filter_params(
      ::UncompressedHeader_LoopFilterParams* loop_filter_params);
  ::UncompressedHeader_LoopFilterParams* unsafe_arena_release_loop_filter_params();

  // .UncompressedHeader.QuantizationParams quantization_params = 25;
  bool has_quantization_params() const;
  private:
  bool _internal_has_quantization_params() const;
  public:
  void clear_quantization_params();
  const ::UncompressedHeader_QuantizationParams& quantization_params() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_QuantizationParams* release_quantization_params();
  ::UncompressedHeader_QuantizationParams* mutable_quantization_params();
  void set_allocated_quantization_params(::UncompressedHeader_QuantizationParams* quantization_params);
  private:
  const ::UncompressedHeader_QuantizationParams& _internal_quantization_params() const;
  ::UncompressedHeader_QuantizationParams* _internal_mutable_quantization_params();
  public:
  void unsafe_arena_set_allocated_quantization_params(
      ::UncompressedHeader_QuantizationParams* quantization_params);
  ::UncompressedHeader_QuantizationParams* unsafe_arena_release_quantization_params();

  // .UncompressedHeader.SegmentationParams segmentation_params = 26;
  bool has_segmentation_params() const;
  private:
  bool _internal_has_segmentation_params() const;
  public:
  void clear_segmentation_params();
  const ::UncompressedHeader_SegmentationParams& segmentation_params() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_SegmentationParams* release_segmentation_params();
  ::UncompressedHeader_SegmentationParams* mutable_segmentation_params();
  void set_allocated_segmentation_params(::UncompressedHeader_SegmentationParams* segmentation_params);
  private:
  const ::UncompressedHeader_SegmentationParams& _internal_segmentation_params() const;
  ::UncompressedHeader_SegmentationParams* _internal_mutable_segmentation_params();
  public:
  void unsafe_arena_set_allocated_segmentation_params(
      ::UncompressedHeader_SegmentationParams* segmentation_params);
  ::UncompressedHeader_SegmentationParams* unsafe_arena_release_segmentation_params();

  // .UncompressedHeader.TileInfo tile_info = 27;
  bool has_tile_info() const;
  private:
  bool _internal_has_tile_info() const;
  public:
  void clear_tile_info();
  const ::UncompressedHeader_TileInfo& tile_info() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_TileInfo* release_tile_info();
  ::UncompressedHeader_TileInfo* mutable_tile_info();
  void set_allocated_tile_info(::UncompressedHeader_TileInfo* tile_info);
  private:
  const ::UncompressedHeader_TileInfo& _internal_tile_info() const;
  ::UncompressedHeader_TileInfo* _internal_mutable_tile_info();
  public:
  void unsafe_arena_set_allocated_tile_info(
      ::UncompressedHeader_TileInfo* tile_info);
  ::UncompressedHeader_TileInfo* unsafe_arena_release_tile_info();

  // .VP9BitField profile_low_bit = 1;
  void clear_profile_low_bit();
  ::VP9BitField profile_low_bit() const;
  void set_profile_low_bit(::VP9BitField value);
  private:
  ::VP9BitField _internal_profile_low_bit() const;
  void _internal_set_profile_low_bit(::VP9BitField value);
  public:

  // .VP9BitField profile_high_bit = 2;
  void clear_profile_high_bit();
  ::VP9BitField profile_high_bit() const;
  void set_profile_high_bit(::VP9BitField value);
  private:
  ::VP9BitField _internal_profile_high_bit() const;
  void _internal_set_profile_high_bit(::VP9BitField value);
  public:

  // uint32 reserved_zero = 3;
  void clear_reserved_zero();
  uint32_t reserved_zero() const;
  void set_reserved_zero(uint32_t value);
  private:
  uint32_t _internal_reserved_zero() const;
  void _internal_set_reserved_zero(uint32_t value);
  public:

  // .VP9BitField show_existing_frame = 4;
  void clear_show_existing_frame();
  ::VP9BitField show_existing_frame() const;
  void set_show_existing_frame(::VP9BitField value);
  private:
  ::VP9BitField _internal_show_existing_frame() const;
  void _internal_set_show_existing_frame(::VP9BitField value);
  public:

  // uint32 frame_to_show_map_idx = 5;
  void clear_frame_to_show_map_idx();
  uint32_t frame_to_show_map_idx() const;
  void set_frame_to_show_map_idx(uint32_t value);
  private:
  uint32_t _internal_frame_to_show_map_idx() const;
  void _internal_set_frame_to_show_map_idx(uint32_t value);
  public:

  // .UncompressedHeader.FrameType frame_type = 6;
  void clear_frame_type();
  ::UncompressedHeader_FrameType frame_type() const;
  void set_frame_type(::UncompressedHeader_FrameType value);
  private:
  ::UncompressedHeader_FrameType _internal_frame_type() const;
  void _internal_set_frame_type(::UncompressedHeader_FrameType value);
  public:

  // .VP9BitField show_frame = 7;
  void clear_show_frame();
  ::VP9BitField show_frame() const;
  void set_show_frame(::VP9BitField value);
  private:
  ::VP9BitField _internal_show_frame() const;
  void _internal_set_show_frame(::VP9BitField value);
  public:

  // .VP9BitField error_resilient_mode = 8;
  void clear_error_resilient_mode();
  ::VP9BitField error_resilient_mode() const;
  void set_error_resilient_mode(::VP9BitField value);
  private:
  ::VP9BitField _internal_error_resilient_mode() const;
  void _internal_set_error_resilient_mode(::VP9BitField value);
  public:

  // uint32 frame_sync_code = 9;
  void clear_frame_sync_code();
  uint32_t frame_sync_code() const;
  void set_frame_sync_code(uint32_t value);
  private:
  uint32_t _internal_frame_sync_code() const;
  void _internal_set_frame_sync_code(uint32_t value);
  public:

  // uint32 frame_size_found_ref = 11;
  void clear_frame_size_found_ref();
  uint32_t frame_size_found_ref() const;
  void set_frame_size_found_ref(uint32_t value);
  private:
  uint32_t _internal_frame_size_found_ref() const;
  void _internal_set_frame_size_found_ref(uint32_t value);
  public:

  // .VP9BitField intra_only = 14;
  void clear_intra_only();
  ::VP9BitField intra_only() const;
  void set_intra_only(::VP9BitField value);
  private:
  ::VP9BitField _internal_intra_only() const;
  void _internal_set_intra_only(::VP9BitField value);
  public:

  // uint32 reset_frame_context = 15;
  void clear_reset_frame_context();
  uint32_t reset_frame_context() const;
  void set_reset_frame_context(uint32_t value);
  private:
  uint32_t _internal_reset_frame_context() const;
  void _internal_set_reset_frame_context(uint32_t value);
  public:

  // uint32 refresh_frame_flags = 16;
  void clear_refresh_frame_flags();
  uint32_t refresh_frame_flags() const;
  void set_refresh_frame_flags(uint32_t value);
  private:
  uint32_t _internal_refresh_frame_flags() const;
  void _internal_set_refresh_frame_flags(uint32_t value);
  public:

  // .VP9BitField allow_high_precision_mv = 19;
  void clear_allow_high_precision_mv();
  ::VP9BitField allow_high_precision_mv() const;
  void set_allow_high_precision_mv(::VP9BitField value);
  private:
  ::VP9BitField _internal_allow_high_precision_mv() const;
  void _internal_set_allow_high_precision_mv(::VP9BitField value);
  public:

  // .VP9BitField refresh_frame_context = 21;
  void clear_refresh_frame_context();
  ::VP9BitField refresh_frame_context() const;
  void set_refresh_frame_context(::VP9BitField value);
  private:
  ::VP9BitField _internal_refresh_frame_context() const;
  void _internal_set_refresh_frame_context(::VP9BitField value);
  public:

  // .VP9BitField frame_parallel_decoding_mode = 22;
  void clear_frame_parallel_decoding_mode();
  ::VP9BitField frame_parallel_decoding_mode() const;
  void set_frame_parallel_decoding_mode(::VP9BitField value);
  private:
  ::VP9BitField _internal_frame_parallel_decoding_mode() const;
  void _internal_set_frame_parallel_decoding_mode(::VP9BitField value);
  public:

  // uint32 frame_context_idx = 23;
  void clear_frame_context_idx();
  uint32_t frame_context_idx() const;
  void set_frame_context_idx(uint32_t value);
  private:
  uint32_t _internal_frame_context_idx() const;
  void _internal_set_frame_context_idx(uint32_t value);
  public:

  // uint32 header_size_in_bytes = 28;
  void clear_header_size_in_bytes();
  uint32_t header_size_in_bytes() const;
  void set_header_size_in_bytes(uint32_t value);
  private:
  uint32_t _internal_header_size_in_bytes() const;
  void _internal_set_header_size_in_bytes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > ref_frame_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _ref_frame_idx_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ref_frame_sign_bias_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _ref_frame_sign_bias_cached_byte_size_;
    ::UncompressedHeader_ColorConfig* color_config_;
    ::UncompressedHeader_FrameSize* frame_size_;
    ::UncompressedHeader_RenderSize* render_size_;
    ::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter_;
    ::UncompressedHeader_LoopFilterParams* loop_filter_params_;
    ::UncompressedHeader_QuantizationParams* quantization_params_;
    ::UncompressedHeader_SegmentationParams* segmentation_params_;
    ::UncompressedHeader_TileInfo* tile_info_;
    int profile_low_bit_;
    int profile_high_bit_;
    uint32_t reserved_zero_;
    int show_existing_frame_;
    uint32_t frame_to_show_map_idx_;
    int frame_type_;
    int show_frame_;
    int error_resilient_mode_;
    uint32_t frame_sync_code_;
    uint32_t frame_size_found_ref_;
    int intra_only_;
    uint32_t reset_frame_context_;
    uint32_t refresh_frame_flags_;
    int allow_high_precision_mv_;
    int refresh_frame_context_;
    int frame_parallel_decoding_mode_;
    uint32_t frame_context_idx_;
    uint32_t header_size_in_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadTxMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadTxMode) */ {
 public:
  inline CompressedHeader_ReadTxMode() : CompressedHeader_ReadTxMode(nullptr) {}
  ~CompressedHeader_ReadTxMode() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadTxMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadTxMode(const CompressedHeader_ReadTxMode& from);
  CompressedHeader_ReadTxMode(CompressedHeader_ReadTxMode&& from) noexcept
    : CompressedHeader_ReadTxMode() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadTxMode& operator=(const CompressedHeader_ReadTxMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadTxMode& operator=(CompressedHeader_ReadTxMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadTxMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadTxMode* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadTxMode*>(
               &_CompressedHeader_ReadTxMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CompressedHeader_ReadTxMode& a, CompressedHeader_ReadTxMode& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadTxMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadTxMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadTxMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadTxMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadTxMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadTxMode& from) {
    CompressedHeader_ReadTxMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadTxMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadTxMode";
  }
  protected:
  explicit CompressedHeader_ReadTxMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxModeFieldNumber = 1,
    kTxModeSelectFieldNumber = 2,
  };
  // .CompressedHeader.TxMode tx_mode = 1;
  void clear_tx_mode();
  ::CompressedHeader_TxMode tx_mode() const;
  void set_tx_mode(::CompressedHeader_TxMode value);
  private:
  ::CompressedHeader_TxMode _internal_tx_mode() const;
  void _internal_set_tx_mode(::CompressedHeader_TxMode value);
  public:

  // .VP9BitField tx_mode_select = 2;
  void clear_tx_mode_select();
  ::VP9BitField tx_mode_select() const;
  void set_tx_mode_select(::VP9BitField value);
  private:
  ::VP9BitField _internal_tx_mode_select() const;
  void _internal_set_tx_mode_select(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadTxMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int tx_mode_;
    int tx_mode_select_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_DecodeTermSubexp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.DecodeTermSubexp) */ {
 public:
  inline CompressedHeader_DecodeTermSubexp() : CompressedHeader_DecodeTermSubexp(nullptr) {}
  ~CompressedHeader_DecodeTermSubexp() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_DecodeTermSubexp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_DecodeTermSubexp(const CompressedHeader_DecodeTermSubexp& from);
  CompressedHeader_DecodeTermSubexp(CompressedHeader_DecodeTermSubexp&& from) noexcept
    : CompressedHeader_DecodeTermSubexp() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_DecodeTermSubexp& operator=(const CompressedHeader_DecodeTermSubexp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_DecodeTermSubexp& operator=(CompressedHeader_DecodeTermSubexp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_DecodeTermSubexp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_DecodeTermSubexp* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_DecodeTermSubexp*>(
               &_CompressedHeader_DecodeTermSubexp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CompressedHeader_DecodeTermSubexp& a, CompressedHeader_DecodeTermSubexp& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_DecodeTermSubexp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_DecodeTermSubexp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_DecodeTermSubexp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_DecodeTermSubexp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_DecodeTermSubexp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_DecodeTermSubexp& from) {
    CompressedHeader_DecodeTermSubexp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_DecodeTermSubexp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.DecodeTermSubexp";
  }
  protected:
  explicit CompressedHeader_DecodeTermSubexp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBit1FieldNumber = 1,
    kSubExpValFieldNumber = 2,
    kBit2FieldNumber = 3,
    kSubExpValMinus16FieldNumber = 4,
    kBit3FieldNumber = 5,
    kSubExpValMinus32FieldNumber = 6,
    kVFieldNumber = 7,
    kBit4FieldNumber = 8,
  };
  // .VP9BitField bit_1 = 1;
  void clear_bit_1();
  ::VP9BitField bit_1() const;
  void set_bit_1(::VP9BitField value);
  private:
  ::VP9BitField _internal_bit_1() const;
  void _internal_set_bit_1(::VP9BitField value);
  public:

  // uint32 sub_exp_val = 2;
  void clear_sub_exp_val();
  uint32_t sub_exp_val() const;
  void set_sub_exp_val(uint32_t value);
  private:
  uint32_t _internal_sub_exp_val() const;
  void _internal_set_sub_exp_val(uint32_t value);
  public:

  // .VP9BitField bit_2 = 3;
  void clear_bit_2();
  ::VP9BitField bit_2() const;
  void set_bit_2(::VP9BitField value);
  private:
  ::VP9BitField _internal_bit_2() const;
  void _internal_set_bit_2(::VP9BitField value);
  public:

  // uint32 sub_exp_Val_minus_16 = 4;
  void clear_sub_exp_val_minus_16();
  uint32_t sub_exp_val_minus_16() const;
  void set_sub_exp_val_minus_16(uint32_t value);
  private:
  uint32_t _internal_sub_exp_val_minus_16() const;
  void _internal_set_sub_exp_val_minus_16(uint32_t value);
  public:

  // .VP9BitField bit_3 = 5;
  void clear_bit_3();
  ::VP9BitField bit_3() const;
  void set_bit_3(::VP9BitField value);
  private:
  ::VP9BitField _internal_bit_3() const;
  void _internal_set_bit_3(::VP9BitField value);
  public:

  // uint32 sub_exp_val_minus_32 = 6;
  void clear_sub_exp_val_minus_32();
  uint32_t sub_exp_val_minus_32() const;
  void set_sub_exp_val_minus_32(uint32_t value);
  private:
  uint32_t _internal_sub_exp_val_minus_32() const;
  void _internal_set_sub_exp_val_minus_32(uint32_t value);
  public:

  // uint32 v = 7;
  void clear_v();
  uint32_t v() const;
  void set_v(uint32_t value);
  private:
  uint32_t _internal_v() const;
  void _internal_set_v(uint32_t value);
  public:

  // .VP9BitField bit_4 = 8;
  void clear_bit_4();
  ::VP9BitField bit_4() const;
  void set_bit_4(::VP9BitField value);
  private:
  ::VP9BitField _internal_bit_4() const;
  void _internal_set_bit_4(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader.DecodeTermSubexp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int bit_1_;
    uint32_t sub_exp_val_;
    int bit_2_;
    uint32_t sub_exp_val_minus_16_;
    int bit_3_;
    uint32_t sub_exp_val_minus_32_;
    uint32_t v_;
    int bit_4_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_DiffUpdateProb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.DiffUpdateProb) */ {
 public:
  inline CompressedHeader_DiffUpdateProb() : CompressedHeader_DiffUpdateProb(nullptr) {}
  ~CompressedHeader_DiffUpdateProb() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_DiffUpdateProb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_DiffUpdateProb(const CompressedHeader_DiffUpdateProb& from);
  CompressedHeader_DiffUpdateProb(CompressedHeader_DiffUpdateProb&& from) noexcept
    : CompressedHeader_DiffUpdateProb() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_DiffUpdateProb& operator=(const CompressedHeader_DiffUpdateProb& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_DiffUpdateProb& operator=(CompressedHeader_DiffUpdateProb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_DiffUpdateProb& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_DiffUpdateProb* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_DiffUpdateProb*>(
               &_CompressedHeader_DiffUpdateProb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CompressedHeader_DiffUpdateProb& a, CompressedHeader_DiffUpdateProb& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_DiffUpdateProb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_DiffUpdateProb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_DiffUpdateProb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_DiffUpdateProb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_DiffUpdateProb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_DiffUpdateProb& from) {
    CompressedHeader_DiffUpdateProb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_DiffUpdateProb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.DiffUpdateProb";
  }
  protected:
  explicit CompressedHeader_DiffUpdateProb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecodeTermSubexpFieldNumber = 2,
    kUpdateProbFieldNumber = 1,
  };
  // .CompressedHeader.DecodeTermSubexp decode_term_subexp = 2;
  bool has_decode_term_subexp() const;
  private:
  bool _internal_has_decode_term_subexp() const;
  public:
  void clear_decode_term_subexp();
  const ::CompressedHeader_DecodeTermSubexp& decode_term_subexp() const;
  PROTOBUF_NODISCARD ::CompressedHeader_DecodeTermSubexp* release_decode_term_subexp();
  ::CompressedHeader_DecodeTermSubexp* mutable_decode_term_subexp();
  void set_allocated_decode_term_subexp(::CompressedHeader_DecodeTermSubexp* decode_term_subexp);
  private:
  const ::CompressedHeader_DecodeTermSubexp& _internal_decode_term_subexp() const;
  ::CompressedHeader_DecodeTermSubexp* _internal_mutable_decode_term_subexp();
  public:
  void unsafe_arena_set_allocated_decode_term_subexp(
      ::CompressedHeader_DecodeTermSubexp* decode_term_subexp);
  ::CompressedHeader_DecodeTermSubexp* unsafe_arena_release_decode_term_subexp();

  // .VP9BitField update_prob = 1;
  void clear_update_prob();
  ::VP9BitField update_prob() const;
  void set_update_prob(::VP9BitField value);
  private:
  ::VP9BitField _internal_update_prob() const;
  void _internal_set_update_prob(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader.DiffUpdateProb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CompressedHeader_DecodeTermSubexp* decode_term_subexp_;
    int update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_TxModeProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.TxModeProbs) */ {
 public:
  inline CompressedHeader_TxModeProbs() : CompressedHeader_TxModeProbs(nullptr) {}
  ~CompressedHeader_TxModeProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_TxModeProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_TxModeProbs(const CompressedHeader_TxModeProbs& from);
  CompressedHeader_TxModeProbs(CompressedHeader_TxModeProbs&& from) noexcept
    : CompressedHeader_TxModeProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_TxModeProbs& operator=(const CompressedHeader_TxModeProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_TxModeProbs& operator=(CompressedHeader_TxModeProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_TxModeProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_TxModeProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_TxModeProbs*>(
               &_CompressedHeader_TxModeProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CompressedHeader_TxModeProbs& a, CompressedHeader_TxModeProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_TxModeProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_TxModeProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_TxModeProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_TxModeProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_TxModeProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_TxModeProbs& from) {
    CompressedHeader_TxModeProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_TxModeProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.TxModeProbs";
  }
  protected:
  explicit CompressedHeader_TxModeProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.TxModeProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop) */ {
 public:
  inline CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop() : CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop(nullptr) {}
  ~CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop(const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& from);
  CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop(CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop&& from) noexcept
    : CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& operator=(const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& operator=(CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop*>(
               &_CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& a, CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& from) {
    CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop";
  }
  protected:
  explicit CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 2,
    kUpdateProbsFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 2;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // .VP9BitField update_probs = 1;
  void clear_update_probs();
  ::VP9BitField update_probs() const;
  void set_update_probs(::VP9BitField value);
  private:
  ::VP9BitField _internal_update_probs() const;
  void _internal_set_update_probs(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    int update_probs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadCoefProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadCoefProbs) */ {
 public:
  inline CompressedHeader_ReadCoefProbs() : CompressedHeader_ReadCoefProbs(nullptr) {}
  ~CompressedHeader_ReadCoefProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadCoefProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadCoefProbs(const CompressedHeader_ReadCoefProbs& from);
  CompressedHeader_ReadCoefProbs(CompressedHeader_ReadCoefProbs&& from) noexcept
    : CompressedHeader_ReadCoefProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadCoefProbs& operator=(const CompressedHeader_ReadCoefProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadCoefProbs& operator=(CompressedHeader_ReadCoefProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadCoefProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadCoefProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadCoefProbs*>(
               &_CompressedHeader_ReadCoefProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CompressedHeader_ReadCoefProbs& a, CompressedHeader_ReadCoefProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadCoefProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadCoefProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadCoefProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadCoefProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadCoefProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadCoefProbs& from) {
    CompressedHeader_ReadCoefProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadCoefProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadCoefProbs";
  }
  protected:
  explicit CompressedHeader_ReadCoefProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop ReadCoefProbsLoop;

  // accessors -------------------------------------------------------

  enum : int {
    kReadCoefProbsFieldNumber = 1,
  };
  // repeated .CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop read_coef_probs = 1;
  int read_coef_probs_size() const;
  private:
  int _internal_read_coef_probs_size() const;
  public:
  void clear_read_coef_probs();
  ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* mutable_read_coef_probs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop >*
      mutable_read_coef_probs();
  private:
  const ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& _internal_read_coef_probs(int index) const;
  ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* _internal_add_read_coef_probs();
  public:
  const ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& read_coef_probs(int index) const;
  ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* add_read_coef_probs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop >&
      read_coef_probs() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadCoefProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop > read_coef_probs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadSkipProb final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadSkipProb) */ {
 public:
  inline CompressedHeader_ReadSkipProb() : CompressedHeader_ReadSkipProb(nullptr) {}
  ~CompressedHeader_ReadSkipProb() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadSkipProb(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadSkipProb(const CompressedHeader_ReadSkipProb& from);
  CompressedHeader_ReadSkipProb(CompressedHeader_ReadSkipProb&& from) noexcept
    : CompressedHeader_ReadSkipProb() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadSkipProb& operator=(const CompressedHeader_ReadSkipProb& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadSkipProb& operator=(CompressedHeader_ReadSkipProb&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadSkipProb& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadSkipProb* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadSkipProb*>(
               &_CompressedHeader_ReadSkipProb_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CompressedHeader_ReadSkipProb& a, CompressedHeader_ReadSkipProb& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadSkipProb* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadSkipProb* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadSkipProb* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadSkipProb>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadSkipProb& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadSkipProb& from) {
    CompressedHeader_ReadSkipProb::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadSkipProb* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadSkipProb";
  }
  protected:
  explicit CompressedHeader_ReadSkipProb(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadSkipProb)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadInterModeProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadInterModeProbs) */ {
 public:
  inline CompressedHeader_ReadInterModeProbs() : CompressedHeader_ReadInterModeProbs(nullptr) {}
  ~CompressedHeader_ReadInterModeProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadInterModeProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadInterModeProbs(const CompressedHeader_ReadInterModeProbs& from);
  CompressedHeader_ReadInterModeProbs(CompressedHeader_ReadInterModeProbs&& from) noexcept
    : CompressedHeader_ReadInterModeProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadInterModeProbs& operator=(const CompressedHeader_ReadInterModeProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadInterModeProbs& operator=(CompressedHeader_ReadInterModeProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadInterModeProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadInterModeProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadInterModeProbs*>(
               &_CompressedHeader_ReadInterModeProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CompressedHeader_ReadInterModeProbs& a, CompressedHeader_ReadInterModeProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadInterModeProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadInterModeProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadInterModeProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadInterModeProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadInterModeProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadInterModeProbs& from) {
    CompressedHeader_ReadInterModeProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadInterModeProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadInterModeProbs";
  }
  protected:
  explicit CompressedHeader_ReadInterModeProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadInterModeProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadInterpFilterProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadInterpFilterProbs) */ {
 public:
  inline CompressedHeader_ReadInterpFilterProbs() : CompressedHeader_ReadInterpFilterProbs(nullptr) {}
  ~CompressedHeader_ReadInterpFilterProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadInterpFilterProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadInterpFilterProbs(const CompressedHeader_ReadInterpFilterProbs& from);
  CompressedHeader_ReadInterpFilterProbs(CompressedHeader_ReadInterpFilterProbs&& from) noexcept
    : CompressedHeader_ReadInterpFilterProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadInterpFilterProbs& operator=(const CompressedHeader_ReadInterpFilterProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadInterpFilterProbs& operator=(CompressedHeader_ReadInterpFilterProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadInterpFilterProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadInterpFilterProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadInterpFilterProbs*>(
               &_CompressedHeader_ReadInterpFilterProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CompressedHeader_ReadInterpFilterProbs& a, CompressedHeader_ReadInterpFilterProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadInterpFilterProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadInterpFilterProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadInterpFilterProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadInterpFilterProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadInterpFilterProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadInterpFilterProbs& from) {
    CompressedHeader_ReadInterpFilterProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadInterpFilterProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadInterpFilterProbs";
  }
  protected:
  explicit CompressedHeader_ReadInterpFilterProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadInterpFilterProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadIsInterProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadIsInterProbs) */ {
 public:
  inline CompressedHeader_ReadIsInterProbs() : CompressedHeader_ReadIsInterProbs(nullptr) {}
  ~CompressedHeader_ReadIsInterProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadIsInterProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadIsInterProbs(const CompressedHeader_ReadIsInterProbs& from);
  CompressedHeader_ReadIsInterProbs(CompressedHeader_ReadIsInterProbs&& from) noexcept
    : CompressedHeader_ReadIsInterProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadIsInterProbs& operator=(const CompressedHeader_ReadIsInterProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadIsInterProbs& operator=(CompressedHeader_ReadIsInterProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadIsInterProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadIsInterProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadIsInterProbs*>(
               &_CompressedHeader_ReadIsInterProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CompressedHeader_ReadIsInterProbs& a, CompressedHeader_ReadIsInterProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadIsInterProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadIsInterProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadIsInterProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadIsInterProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadIsInterProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadIsInterProbs& from) {
    CompressedHeader_ReadIsInterProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadIsInterProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadIsInterProbs";
  }
  protected:
  explicit CompressedHeader_ReadIsInterProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadIsInterProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_FrameReferenceMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.FrameReferenceMode) */ {
 public:
  inline CompressedHeader_FrameReferenceMode() : CompressedHeader_FrameReferenceMode(nullptr) {}
  ~CompressedHeader_FrameReferenceMode() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_FrameReferenceMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_FrameReferenceMode(const CompressedHeader_FrameReferenceMode& from);
  CompressedHeader_FrameReferenceMode(CompressedHeader_FrameReferenceMode&& from) noexcept
    : CompressedHeader_FrameReferenceMode() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_FrameReferenceMode& operator=(const CompressedHeader_FrameReferenceMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_FrameReferenceMode& operator=(CompressedHeader_FrameReferenceMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_FrameReferenceMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_FrameReferenceMode* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_FrameReferenceMode*>(
               &_CompressedHeader_FrameReferenceMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CompressedHeader_FrameReferenceMode& a, CompressedHeader_FrameReferenceMode& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_FrameReferenceMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_FrameReferenceMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_FrameReferenceMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_FrameReferenceMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_FrameReferenceMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_FrameReferenceMode& from) {
    CompressedHeader_FrameReferenceMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_FrameReferenceMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.FrameReferenceMode";
  }
  protected:
  explicit CompressedHeader_FrameReferenceMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonSingleReferenceFieldNumber = 1,
    kReferenceSelectFieldNumber = 2,
  };
  // .VP9BitField non_single_reference = 1;
  void clear_non_single_reference();
  ::VP9BitField non_single_reference() const;
  void set_non_single_reference(::VP9BitField value);
  private:
  ::VP9BitField _internal_non_single_reference() const;
  void _internal_set_non_single_reference(::VP9BitField value);
  public:

  // .VP9BitField reference_select = 2;
  void clear_reference_select();
  ::VP9BitField reference_select() const;
  void set_reference_select(::VP9BitField value);
  private:
  ::VP9BitField _internal_reference_select() const;
  void _internal_set_reference_select(::VP9BitField value);
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader.FrameReferenceMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int non_single_reference_;
    int reference_select_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_FrameReferenceModeProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.FrameReferenceModeProbs) */ {
 public:
  inline CompressedHeader_FrameReferenceModeProbs() : CompressedHeader_FrameReferenceModeProbs(nullptr) {}
  ~CompressedHeader_FrameReferenceModeProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_FrameReferenceModeProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_FrameReferenceModeProbs(const CompressedHeader_FrameReferenceModeProbs& from);
  CompressedHeader_FrameReferenceModeProbs(CompressedHeader_FrameReferenceModeProbs&& from) noexcept
    : CompressedHeader_FrameReferenceModeProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_FrameReferenceModeProbs& operator=(const CompressedHeader_FrameReferenceModeProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_FrameReferenceModeProbs& operator=(CompressedHeader_FrameReferenceModeProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_FrameReferenceModeProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_FrameReferenceModeProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_FrameReferenceModeProbs*>(
               &_CompressedHeader_FrameReferenceModeProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CompressedHeader_FrameReferenceModeProbs& a, CompressedHeader_FrameReferenceModeProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_FrameReferenceModeProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_FrameReferenceModeProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_FrameReferenceModeProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_FrameReferenceModeProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_FrameReferenceModeProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_FrameReferenceModeProbs& from) {
    CompressedHeader_FrameReferenceModeProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_FrameReferenceModeProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.FrameReferenceModeProbs";
  }
  protected:
  explicit CompressedHeader_FrameReferenceModeProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.FrameReferenceModeProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadYModeProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadYModeProbs) */ {
 public:
  inline CompressedHeader_ReadYModeProbs() : CompressedHeader_ReadYModeProbs(nullptr) {}
  ~CompressedHeader_ReadYModeProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadYModeProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadYModeProbs(const CompressedHeader_ReadYModeProbs& from);
  CompressedHeader_ReadYModeProbs(CompressedHeader_ReadYModeProbs&& from) noexcept
    : CompressedHeader_ReadYModeProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadYModeProbs& operator=(const CompressedHeader_ReadYModeProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadYModeProbs& operator=(CompressedHeader_ReadYModeProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadYModeProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadYModeProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadYModeProbs*>(
               &_CompressedHeader_ReadYModeProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CompressedHeader_ReadYModeProbs& a, CompressedHeader_ReadYModeProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadYModeProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadYModeProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadYModeProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadYModeProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadYModeProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadYModeProbs& from) {
    CompressedHeader_ReadYModeProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadYModeProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadYModeProbs";
  }
  protected:
  explicit CompressedHeader_ReadYModeProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadYModeProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_ReadPartitionProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.ReadPartitionProbs) */ {
 public:
  inline CompressedHeader_ReadPartitionProbs() : CompressedHeader_ReadPartitionProbs(nullptr) {}
  ~CompressedHeader_ReadPartitionProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_ReadPartitionProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_ReadPartitionProbs(const CompressedHeader_ReadPartitionProbs& from);
  CompressedHeader_ReadPartitionProbs(CompressedHeader_ReadPartitionProbs&& from) noexcept
    : CompressedHeader_ReadPartitionProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_ReadPartitionProbs& operator=(const CompressedHeader_ReadPartitionProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_ReadPartitionProbs& operator=(CompressedHeader_ReadPartitionProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_ReadPartitionProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_ReadPartitionProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_ReadPartitionProbs*>(
               &_CompressedHeader_ReadPartitionProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CompressedHeader_ReadPartitionProbs& a, CompressedHeader_ReadPartitionProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_ReadPartitionProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_ReadPartitionProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_ReadPartitionProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_ReadPartitionProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_ReadPartitionProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_ReadPartitionProbs& from) {
    CompressedHeader_ReadPartitionProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_ReadPartitionProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.ReadPartitionProbs";
  }
  protected:
  explicit CompressedHeader_ReadPartitionProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiffUpdateProbFieldNumber = 1,
  };
  // repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
  int diff_update_prob_size() const;
  private:
  int _internal_diff_update_prob_size() const;
  public:
  void clear_diff_update_prob();
  ::CompressedHeader_DiffUpdateProb* mutable_diff_update_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
      mutable_diff_update_prob();
  private:
  const ::CompressedHeader_DiffUpdateProb& _internal_diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* _internal_add_diff_update_prob();
  public:
  const ::CompressedHeader_DiffUpdateProb& diff_update_prob(int index) const;
  ::CompressedHeader_DiffUpdateProb* add_diff_update_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
      diff_update_prob() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.ReadPartitionProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb > diff_update_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_MvProbs_MvProbsLoop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.MvProbs.MvProbsLoop) */ {
 public:
  inline CompressedHeader_MvProbs_MvProbsLoop() : CompressedHeader_MvProbs_MvProbsLoop(nullptr) {}
  ~CompressedHeader_MvProbs_MvProbsLoop() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_MvProbs_MvProbsLoop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_MvProbs_MvProbsLoop(const CompressedHeader_MvProbs_MvProbsLoop& from);
  CompressedHeader_MvProbs_MvProbsLoop(CompressedHeader_MvProbs_MvProbsLoop&& from) noexcept
    : CompressedHeader_MvProbs_MvProbsLoop() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_MvProbs_MvProbsLoop& operator=(const CompressedHeader_MvProbs_MvProbsLoop& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_MvProbs_MvProbsLoop& operator=(CompressedHeader_MvProbs_MvProbsLoop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_MvProbs_MvProbsLoop& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_MvProbs_MvProbsLoop* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_MvProbs_MvProbsLoop*>(
               &_CompressedHeader_MvProbs_MvProbsLoop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CompressedHeader_MvProbs_MvProbsLoop& a, CompressedHeader_MvProbs_MvProbsLoop& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_MvProbs_MvProbsLoop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_MvProbs_MvProbsLoop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_MvProbs_MvProbsLoop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_MvProbs_MvProbsLoop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_MvProbs_MvProbsLoop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_MvProbs_MvProbsLoop& from) {
    CompressedHeader_MvProbs_MvProbsLoop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_MvProbs_MvProbsLoop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.MvProbs.MvProbsLoop";
  }
  protected:
  explicit CompressedHeader_MvProbs_MvProbsLoop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateMvProbFieldNumber = 1,
    kMvProbFieldNumber = 2,
  };
  // .VP9BitField update_mv_prob = 1;
  void clear_update_mv_prob();
  ::VP9BitField update_mv_prob() const;
  void set_update_mv_prob(::VP9BitField value);
  private:
  ::VP9BitField _internal_update_mv_prob() const;
  void _internal_set_update_mv_prob(::VP9BitField value);
  public:

  // uint32 mv_prob = 2;
  void clear_mv_prob();
  uint32_t mv_prob() const;
  void set_mv_prob(uint32_t value);
  private:
  uint32_t _internal_mv_prob() const;
  void _internal_set_mv_prob(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader.MvProbs.MvProbsLoop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int update_mv_prob_;
    uint32_t mv_prob_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader_MvProbs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader.MvProbs) */ {
 public:
  inline CompressedHeader_MvProbs() : CompressedHeader_MvProbs(nullptr) {}
  ~CompressedHeader_MvProbs() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader_MvProbs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader_MvProbs(const CompressedHeader_MvProbs& from);
  CompressedHeader_MvProbs(CompressedHeader_MvProbs&& from) noexcept
    : CompressedHeader_MvProbs() {
    *this = ::std::move(from);
  }

  inline CompressedHeader_MvProbs& operator=(const CompressedHeader_MvProbs& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader_MvProbs& operator=(CompressedHeader_MvProbs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader_MvProbs& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader_MvProbs* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader_MvProbs*>(
               &_CompressedHeader_MvProbs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CompressedHeader_MvProbs& a, CompressedHeader_MvProbs& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader_MvProbs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader_MvProbs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader_MvProbs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader_MvProbs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader_MvProbs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader_MvProbs& from) {
    CompressedHeader_MvProbs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader_MvProbs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader.MvProbs";
  }
  protected:
  explicit CompressedHeader_MvProbs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompressedHeader_MvProbs_MvProbsLoop MvProbsLoop;

  // accessors -------------------------------------------------------

  enum : int {
    kMvProbsFieldNumber = 1,
  };
  // repeated .CompressedHeader.MvProbs.MvProbsLoop mv_probs = 1;
  int mv_probs_size() const;
  private:
  int _internal_mv_probs_size() const;
  public:
  void clear_mv_probs();
  ::CompressedHeader_MvProbs_MvProbsLoop* mutable_mv_probs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_MvProbs_MvProbsLoop >*
      mutable_mv_probs();
  private:
  const ::CompressedHeader_MvProbs_MvProbsLoop& _internal_mv_probs(int index) const;
  ::CompressedHeader_MvProbs_MvProbsLoop* _internal_add_mv_probs();
  public:
  const ::CompressedHeader_MvProbs_MvProbsLoop& mv_probs(int index) const;
  ::CompressedHeader_MvProbs_MvProbsLoop* add_mv_probs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_MvProbs_MvProbsLoop >&
      mv_probs() const;

  // @@protoc_insertion_point(class_scope:CompressedHeader.MvProbs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_MvProbs_MvProbsLoop > mv_probs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader) */ {
 public:
  inline CompressedHeader() : CompressedHeader(nullptr) {}
  ~CompressedHeader() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader(const CompressedHeader& from);
  CompressedHeader(CompressedHeader&& from) noexcept
    : CompressedHeader() {
    *this = ::std::move(from);
  }

  inline CompressedHeader& operator=(const CompressedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader& operator=(CompressedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader*>(
               &_CompressedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CompressedHeader& a, CompressedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader& from) {
    CompressedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader";
  }
  protected:
  explicit CompressedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompressedHeader_ReadTxMode ReadTxMode;
  typedef CompressedHeader_DecodeTermSubexp DecodeTermSubexp;
  typedef CompressedHeader_DiffUpdateProb DiffUpdateProb;
  typedef CompressedHeader_TxModeProbs TxModeProbs;
  typedef CompressedHeader_ReadCoefProbs ReadCoefProbs;
  typedef CompressedHeader_ReadSkipProb ReadSkipProb;
  typedef CompressedHeader_ReadInterModeProbs ReadInterModeProbs;
  typedef CompressedHeader_ReadInterpFilterProbs ReadInterpFilterProbs;
  typedef CompressedHeader_ReadIsInterProbs ReadIsInterProbs;
  typedef CompressedHeader_FrameReferenceMode FrameReferenceMode;
  typedef CompressedHeader_FrameReferenceModeProbs FrameReferenceModeProbs;
  typedef CompressedHeader_ReadYModeProbs ReadYModeProbs;
  typedef CompressedHeader_ReadPartitionProbs ReadPartitionProbs;
  typedef CompressedHeader_MvProbs MvProbs;

  typedef CompressedHeader_TxMode TxMode;
  static constexpr TxMode ONLY_4X4 =
    CompressedHeader_TxMode_ONLY_4X4;
  static constexpr TxMode ALLOW_8X8 =
    CompressedHeader_TxMode_ALLOW_8X8;
  static constexpr TxMode ALLOW_16X16 =
    CompressedHeader_TxMode_ALLOW_16X16;
  static constexpr TxMode ALLOW_32X32 =
    CompressedHeader_TxMode_ALLOW_32X32;
  static constexpr TxMode TX_MODE_SELECT =
    CompressedHeader_TxMode_TX_MODE_SELECT;
  static inline bool TxMode_IsValid(int value) {
    return CompressedHeader_TxMode_IsValid(value);
  }
  static constexpr TxMode TxMode_MIN =
    CompressedHeader_TxMode_TxMode_MIN;
  static constexpr TxMode TxMode_MAX =
    CompressedHeader_TxMode_TxMode_MAX;
  static constexpr int TxMode_ARRAYSIZE =
    CompressedHeader_TxMode_TxMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TxMode_descriptor() {
    return CompressedHeader_TxMode_descriptor();
  }
  template<typename T>
  static inline const std::string& TxMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TxMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TxMode_Name.");
    return CompressedHeader_TxMode_Name(enum_t_value);
  }
  static inline bool TxMode_Parse(::absl::string_view name,
      TxMode* value) {
    return CompressedHeader_TxMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReadTxModeFieldNumber = 1,
    kTxModeProbsFieldNumber = 2,
    kReadCoefProbsFieldNumber = 3,
    kReadSkipProbFieldNumber = 4,
    kReadInterModeProbsFieldNumber = 5,
    kReadInterpFilterProbsFieldNumber = 6,
    kReadIsInterProbsFieldNumber = 7,
    kFrameReferenceModeFieldNumber = 8,
    kFrameReferenceModeProbsFieldNumber = 9,
    kReadYModeProbsFieldNumber = 10,
    kReadPartitionProbsFieldNumber = 11,
    kMvProbsFieldNumber = 12,
  };
  // .CompressedHeader.ReadTxMode read_tx_mode = 1;
  bool has_read_tx_mode() const;
  private:
  bool _internal_has_read_tx_mode() const;
  public:
  void clear_read_tx_mode();
  const ::CompressedHeader_ReadTxMode& read_tx_mode() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadTxMode* release_read_tx_mode();
  ::CompressedHeader_ReadTxMode* mutable_read_tx_mode();
  void set_allocated_read_tx_mode(::CompressedHeader_ReadTxMode* read_tx_mode);
  private:
  const ::CompressedHeader_ReadTxMode& _internal_read_tx_mode() const;
  ::CompressedHeader_ReadTxMode* _internal_mutable_read_tx_mode();
  public:
  void unsafe_arena_set_allocated_read_tx_mode(
      ::CompressedHeader_ReadTxMode* read_tx_mode);
  ::CompressedHeader_ReadTxMode* unsafe_arena_release_read_tx_mode();

  // .CompressedHeader.TxModeProbs tx_mode_probs = 2;
  bool has_tx_mode_probs() const;
  private:
  bool _internal_has_tx_mode_probs() const;
  public:
  void clear_tx_mode_probs();
  const ::CompressedHeader_TxModeProbs& tx_mode_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_TxModeProbs* release_tx_mode_probs();
  ::CompressedHeader_TxModeProbs* mutable_tx_mode_probs();
  void set_allocated_tx_mode_probs(::CompressedHeader_TxModeProbs* tx_mode_probs);
  private:
  const ::CompressedHeader_TxModeProbs& _internal_tx_mode_probs() const;
  ::CompressedHeader_TxModeProbs* _internal_mutable_tx_mode_probs();
  public:
  void unsafe_arena_set_allocated_tx_mode_probs(
      ::CompressedHeader_TxModeProbs* tx_mode_probs);
  ::CompressedHeader_TxModeProbs* unsafe_arena_release_tx_mode_probs();

  // .CompressedHeader.ReadCoefProbs read_coef_probs = 3;
  bool has_read_coef_probs() const;
  private:
  bool _internal_has_read_coef_probs() const;
  public:
  void clear_read_coef_probs();
  const ::CompressedHeader_ReadCoefProbs& read_coef_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadCoefProbs* release_read_coef_probs();
  ::CompressedHeader_ReadCoefProbs* mutable_read_coef_probs();
  void set_allocated_read_coef_probs(::CompressedHeader_ReadCoefProbs* read_coef_probs);
  private:
  const ::CompressedHeader_ReadCoefProbs& _internal_read_coef_probs() const;
  ::CompressedHeader_ReadCoefProbs* _internal_mutable_read_coef_probs();
  public:
  void unsafe_arena_set_allocated_read_coef_probs(
      ::CompressedHeader_ReadCoefProbs* read_coef_probs);
  ::CompressedHeader_ReadCoefProbs* unsafe_arena_release_read_coef_probs();

  // .CompressedHeader.ReadSkipProb read_skip_prob = 4;
  bool has_read_skip_prob() const;
  private:
  bool _internal_has_read_skip_prob() const;
  public:
  void clear_read_skip_prob();
  const ::CompressedHeader_ReadSkipProb& read_skip_prob() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadSkipProb* release_read_skip_prob();
  ::CompressedHeader_ReadSkipProb* mutable_read_skip_prob();
  void set_allocated_read_skip_prob(::CompressedHeader_ReadSkipProb* read_skip_prob);
  private:
  const ::CompressedHeader_ReadSkipProb& _internal_read_skip_prob() const;
  ::CompressedHeader_ReadSkipProb* _internal_mutable_read_skip_prob();
  public:
  void unsafe_arena_set_allocated_read_skip_prob(
      ::CompressedHeader_ReadSkipProb* read_skip_prob);
  ::CompressedHeader_ReadSkipProb* unsafe_arena_release_read_skip_prob();

  // .CompressedHeader.ReadInterModeProbs read_inter_mode_probs = 5;
  bool has_read_inter_mode_probs() const;
  private:
  bool _internal_has_read_inter_mode_probs() const;
  public:
  void clear_read_inter_mode_probs();
  const ::CompressedHeader_ReadInterModeProbs& read_inter_mode_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadInterModeProbs* release_read_inter_mode_probs();
  ::CompressedHeader_ReadInterModeProbs* mutable_read_inter_mode_probs();
  void set_allocated_read_inter_mode_probs(::CompressedHeader_ReadInterModeProbs* read_inter_mode_probs);
  private:
  const ::CompressedHeader_ReadInterModeProbs& _internal_read_inter_mode_probs() const;
  ::CompressedHeader_ReadInterModeProbs* _internal_mutable_read_inter_mode_probs();
  public:
  void unsafe_arena_set_allocated_read_inter_mode_probs(
      ::CompressedHeader_ReadInterModeProbs* read_inter_mode_probs);
  ::CompressedHeader_ReadInterModeProbs* unsafe_arena_release_read_inter_mode_probs();

  // .CompressedHeader.ReadInterpFilterProbs read_interp_filter_probs = 6;
  bool has_read_interp_filter_probs() const;
  private:
  bool _internal_has_read_interp_filter_probs() const;
  public:
  void clear_read_interp_filter_probs();
  const ::CompressedHeader_ReadInterpFilterProbs& read_interp_filter_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadInterpFilterProbs* release_read_interp_filter_probs();
  ::CompressedHeader_ReadInterpFilterProbs* mutable_read_interp_filter_probs();
  void set_allocated_read_interp_filter_probs(::CompressedHeader_ReadInterpFilterProbs* read_interp_filter_probs);
  private:
  const ::CompressedHeader_ReadInterpFilterProbs& _internal_read_interp_filter_probs() const;
  ::CompressedHeader_ReadInterpFilterProbs* _internal_mutable_read_interp_filter_probs();
  public:
  void unsafe_arena_set_allocated_read_interp_filter_probs(
      ::CompressedHeader_ReadInterpFilterProbs* read_interp_filter_probs);
  ::CompressedHeader_ReadInterpFilterProbs* unsafe_arena_release_read_interp_filter_probs();

  // .CompressedHeader.ReadIsInterProbs read_is_inter_probs = 7;
  bool has_read_is_inter_probs() const;
  private:
  bool _internal_has_read_is_inter_probs() const;
  public:
  void clear_read_is_inter_probs();
  const ::CompressedHeader_ReadIsInterProbs& read_is_inter_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadIsInterProbs* release_read_is_inter_probs();
  ::CompressedHeader_ReadIsInterProbs* mutable_read_is_inter_probs();
  void set_allocated_read_is_inter_probs(::CompressedHeader_ReadIsInterProbs* read_is_inter_probs);
  private:
  const ::CompressedHeader_ReadIsInterProbs& _internal_read_is_inter_probs() const;
  ::CompressedHeader_ReadIsInterProbs* _internal_mutable_read_is_inter_probs();
  public:
  void unsafe_arena_set_allocated_read_is_inter_probs(
      ::CompressedHeader_ReadIsInterProbs* read_is_inter_probs);
  ::CompressedHeader_ReadIsInterProbs* unsafe_arena_release_read_is_inter_probs();

  // .CompressedHeader.FrameReferenceMode frame_reference_mode = 8;
  bool has_frame_reference_mode() const;
  private:
  bool _internal_has_frame_reference_mode() const;
  public:
  void clear_frame_reference_mode();
  const ::CompressedHeader_FrameReferenceMode& frame_reference_mode() const;
  PROTOBUF_NODISCARD ::CompressedHeader_FrameReferenceMode* release_frame_reference_mode();
  ::CompressedHeader_FrameReferenceMode* mutable_frame_reference_mode();
  void set_allocated_frame_reference_mode(::CompressedHeader_FrameReferenceMode* frame_reference_mode);
  private:
  const ::CompressedHeader_FrameReferenceMode& _internal_frame_reference_mode() const;
  ::CompressedHeader_FrameReferenceMode* _internal_mutable_frame_reference_mode();
  public:
  void unsafe_arena_set_allocated_frame_reference_mode(
      ::CompressedHeader_FrameReferenceMode* frame_reference_mode);
  ::CompressedHeader_FrameReferenceMode* unsafe_arena_release_frame_reference_mode();

  // .CompressedHeader.FrameReferenceModeProbs frame_reference_mode_probs = 9;
  bool has_frame_reference_mode_probs() const;
  private:
  bool _internal_has_frame_reference_mode_probs() const;
  public:
  void clear_frame_reference_mode_probs();
  const ::CompressedHeader_FrameReferenceModeProbs& frame_reference_mode_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_FrameReferenceModeProbs* release_frame_reference_mode_probs();
  ::CompressedHeader_FrameReferenceModeProbs* mutable_frame_reference_mode_probs();
  void set_allocated_frame_reference_mode_probs(::CompressedHeader_FrameReferenceModeProbs* frame_reference_mode_probs);
  private:
  const ::CompressedHeader_FrameReferenceModeProbs& _internal_frame_reference_mode_probs() const;
  ::CompressedHeader_FrameReferenceModeProbs* _internal_mutable_frame_reference_mode_probs();
  public:
  void unsafe_arena_set_allocated_frame_reference_mode_probs(
      ::CompressedHeader_FrameReferenceModeProbs* frame_reference_mode_probs);
  ::CompressedHeader_FrameReferenceModeProbs* unsafe_arena_release_frame_reference_mode_probs();

  // .CompressedHeader.ReadYModeProbs read_y_mode_probs = 10;
  bool has_read_y_mode_probs() const;
  private:
  bool _internal_has_read_y_mode_probs() const;
  public:
  void clear_read_y_mode_probs();
  const ::CompressedHeader_ReadYModeProbs& read_y_mode_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadYModeProbs* release_read_y_mode_probs();
  ::CompressedHeader_ReadYModeProbs* mutable_read_y_mode_probs();
  void set_allocated_read_y_mode_probs(::CompressedHeader_ReadYModeProbs* read_y_mode_probs);
  private:
  const ::CompressedHeader_ReadYModeProbs& _internal_read_y_mode_probs() const;
  ::CompressedHeader_ReadYModeProbs* _internal_mutable_read_y_mode_probs();
  public:
  void unsafe_arena_set_allocated_read_y_mode_probs(
      ::CompressedHeader_ReadYModeProbs* read_y_mode_probs);
  ::CompressedHeader_ReadYModeProbs* unsafe_arena_release_read_y_mode_probs();

  // .CompressedHeader.ReadPartitionProbs read_partition_probs = 11;
  bool has_read_partition_probs() const;
  private:
  bool _internal_has_read_partition_probs() const;
  public:
  void clear_read_partition_probs();
  const ::CompressedHeader_ReadPartitionProbs& read_partition_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_ReadPartitionProbs* release_read_partition_probs();
  ::CompressedHeader_ReadPartitionProbs* mutable_read_partition_probs();
  void set_allocated_read_partition_probs(::CompressedHeader_ReadPartitionProbs* read_partition_probs);
  private:
  const ::CompressedHeader_ReadPartitionProbs& _internal_read_partition_probs() const;
  ::CompressedHeader_ReadPartitionProbs* _internal_mutable_read_partition_probs();
  public:
  void unsafe_arena_set_allocated_read_partition_probs(
      ::CompressedHeader_ReadPartitionProbs* read_partition_probs);
  ::CompressedHeader_ReadPartitionProbs* unsafe_arena_release_read_partition_probs();

  // .CompressedHeader.MvProbs mv_probs = 12;
  bool has_mv_probs() const;
  private:
  bool _internal_has_mv_probs() const;
  public:
  void clear_mv_probs();
  const ::CompressedHeader_MvProbs& mv_probs() const;
  PROTOBUF_NODISCARD ::CompressedHeader_MvProbs* release_mv_probs();
  ::CompressedHeader_MvProbs* mutable_mv_probs();
  void set_allocated_mv_probs(::CompressedHeader_MvProbs* mv_probs);
  private:
  const ::CompressedHeader_MvProbs& _internal_mv_probs() const;
  ::CompressedHeader_MvProbs* _internal_mutable_mv_probs();
  public:
  void unsafe_arena_set_allocated_mv_probs(
      ::CompressedHeader_MvProbs* mv_probs);
  ::CompressedHeader_MvProbs* unsafe_arena_release_mv_probs();

  // @@protoc_insertion_point(class_scope:CompressedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CompressedHeader_ReadTxMode* read_tx_mode_;
    ::CompressedHeader_TxModeProbs* tx_mode_probs_;
    ::CompressedHeader_ReadCoefProbs* read_coef_probs_;
    ::CompressedHeader_ReadSkipProb* read_skip_prob_;
    ::CompressedHeader_ReadInterModeProbs* read_inter_mode_probs_;
    ::CompressedHeader_ReadInterpFilterProbs* read_interp_filter_probs_;
    ::CompressedHeader_ReadIsInterProbs* read_is_inter_probs_;
    ::CompressedHeader_FrameReferenceMode* frame_reference_mode_;
    ::CompressedHeader_FrameReferenceModeProbs* frame_reference_mode_probs_;
    ::CompressedHeader_ReadYModeProbs* read_y_mode_probs_;
    ::CompressedHeader_ReadPartitionProbs* read_partition_probs_;
    ::CompressedHeader_MvProbs* mv_probs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class Tile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  ~Tile() override;
  explicit PROTOBUF_CONSTEXPR Tile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tile& from) {
    Tile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionFieldNumber = 2,
    kTileSizeFieldNumber = 1,
  };
  // bytes partition = 2;
  void clear_partition();
  const std::string& partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition();
  PROTOBUF_NODISCARD std::string* release_partition();
  void set_allocated_partition(std::string* partition);
  private:
  const std::string& _internal_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition(const std::string& value);
  std::string* _internal_mutable_partition();
  public:

  // uint32 tile_size = 1;
  void clear_tile_size();
  uint32_t tile_size() const;
  void set_tile_size(uint32_t value);
  private:
  uint32_t _internal_tile_size() const;
  void _internal_set_tile_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_;
    uint32_t tile_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class VP9Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VP9Frame) */ {
 public:
  inline VP9Frame() : VP9Frame(nullptr) {}
  ~VP9Frame() override;
  explicit PROTOBUF_CONSTEXPR VP9Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VP9Frame(const VP9Frame& from);
  VP9Frame(VP9Frame&& from) noexcept
    : VP9Frame() {
    *this = ::std::move(from);
  }

  inline VP9Frame& operator=(const VP9Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline VP9Frame& operator=(VP9Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VP9Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const VP9Frame* internal_default_instance() {
    return reinterpret_cast<const VP9Frame*>(
               &_VP9Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(VP9Frame& a, VP9Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(VP9Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VP9Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VP9Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VP9Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VP9Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VP9Frame& from) {
    VP9Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VP9Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "VP9Frame";
  }
  protected:
  explicit VP9Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 3,
    kUncompressedHeaderFieldNumber = 1,
    kCompressedHeaderFieldNumber = 2,
  };
  // repeated .Tile tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
      mutable_tiles();
  private:
  const ::Tile& _internal_tiles(int index) const;
  ::Tile* _internal_add_tiles();
  public:
  const ::Tile& tiles(int index) const;
  ::Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
      tiles() const;

  // .UncompressedHeader uncompressed_header = 1;
  bool has_uncompressed_header() const;
  private:
  bool _internal_has_uncompressed_header() const;
  public:
  void clear_uncompressed_header();
  const ::UncompressedHeader& uncompressed_header() const;
  PROTOBUF_NODISCARD ::UncompressedHeader* release_uncompressed_header();
  ::UncompressedHeader* mutable_uncompressed_header();
  void set_allocated_uncompressed_header(::UncompressedHeader* uncompressed_header);
  private:
  const ::UncompressedHeader& _internal_uncompressed_header() const;
  ::UncompressedHeader* _internal_mutable_uncompressed_header();
  public:
  void unsafe_arena_set_allocated_uncompressed_header(
      ::UncompressedHeader* uncompressed_header);
  ::UncompressedHeader* unsafe_arena_release_uncompressed_header();

  // .CompressedHeader compressed_header = 2;
  bool has_compressed_header() const;
  private:
  bool _internal_has_compressed_header() const;
  public:
  void clear_compressed_header();
  const ::CompressedHeader& compressed_header() const;
  PROTOBUF_NODISCARD ::CompressedHeader* release_compressed_header();
  ::CompressedHeader* mutable_compressed_header();
  void set_allocated_compressed_header(::CompressedHeader* compressed_header);
  private:
  const ::CompressedHeader& _internal_compressed_header() const;
  ::CompressedHeader* _internal_mutable_compressed_header();
  public:
  void unsafe_arena_set_allocated_compressed_header(
      ::CompressedHeader* compressed_header);
  ::CompressedHeader* unsafe_arena_release_compressed_header();

  // @@protoc_insertion_point(class_scope:VP9Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile > tiles_;
    ::UncompressedHeader* uncompressed_header_;
    ::CompressedHeader* compressed_header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};
// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// VP9SignedInteger

// bytes value = 1;
inline void VP9SignedInteger::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& VP9SignedInteger::value() const {
  // @@protoc_insertion_point(field_get:VP9SignedInteger.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VP9SignedInteger::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VP9SignedInteger.value)
}
inline std::string* VP9SignedInteger::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:VP9SignedInteger.value)
  return _s;
}
inline const std::string& VP9SignedInteger::_internal_value() const {
  return _impl_.value_.Get();
}
inline void VP9SignedInteger::_internal_set_value(const std::string& value) {

  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* VP9SignedInteger::_internal_mutable_value() {

  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* VP9SignedInteger::release_value() {
  // @@protoc_insertion_point(field_release:VP9SignedInteger.value)
  return _impl_.value_.Release();
}
inline void VP9SignedInteger::set_allocated_value(std::string* value) {
  if (value != nullptr) {

  } else {

  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VP9SignedInteger.value)
}

// .VP9BitField sign = 2;
inline void VP9SignedInteger::clear_sign() {
  _impl_.sign_ = 0;
}
inline ::VP9BitField VP9SignedInteger::_internal_sign() const {
  return static_cast< ::VP9BitField >(_impl_.sign_);
}
inline ::VP9BitField VP9SignedInteger::sign() const {
  // @@protoc_insertion_point(field_get:VP9SignedInteger.sign)
  return _internal_sign();
}
inline void VP9SignedInteger::_internal_set_sign(::VP9BitField value) {
  
  _impl_.sign_ = value;
}
inline void VP9SignedInteger::set_sign(::VP9BitField value) {
  _internal_set_sign(value);
  // @@protoc_insertion_point(field_set:VP9SignedInteger.sign)
}

// -------------------------------------------------------------------

// UncompressedHeader_ColorConfig

// .VP9BitField ten_or_twelve_bit = 1;
inline void UncompressedHeader_ColorConfig::clear_ten_or_twelve_bit() {
  _impl_.ten_or_twelve_bit_ = 0;
}
inline ::VP9BitField UncompressedHeader_ColorConfig::_internal_ten_or_twelve_bit() const {
  return static_cast< ::VP9BitField >(_impl_.ten_or_twelve_bit_);
}
inline ::VP9BitField UncompressedHeader_ColorConfig::ten_or_twelve_bit() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.ten_or_twelve_bit)
  return _internal_ten_or_twelve_bit();
}
inline void UncompressedHeader_ColorConfig::_internal_set_ten_or_twelve_bit(::VP9BitField value) {
  
  _impl_.ten_or_twelve_bit_ = value;
}
inline void UncompressedHeader_ColorConfig::set_ten_or_twelve_bit(::VP9BitField value) {
  _internal_set_ten_or_twelve_bit(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.ten_or_twelve_bit)
}

// uint32 color_space = 2;
inline void UncompressedHeader_ColorConfig::clear_color_space() {
  _impl_.color_space_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_color_space() const {
  return _impl_.color_space_;
}
inline uint32_t UncompressedHeader_ColorConfig::color_space() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.color_space)
  return _internal_color_space();
}
inline void UncompressedHeader_ColorConfig::_internal_set_color_space(uint32_t value) {

  _impl_.color_space_ = value;
}
inline void UncompressedHeader_ColorConfig::set_color_space(uint32_t value) {
  _internal_set_color_space(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.color_space)
}

// .VP9BitField color_range = 3;
inline void UncompressedHeader_ColorConfig::clear_color_range() {
  _impl_.color_range_ = 0;
}
inline ::VP9BitField UncompressedHeader_ColorConfig::_internal_color_range() const {
  return static_cast< ::VP9BitField >(_impl_.color_range_);
}
inline ::VP9BitField UncompressedHeader_ColorConfig::color_range() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.color_range)
  return _internal_color_range();
}
inline void UncompressedHeader_ColorConfig::_internal_set_color_range(::VP9BitField value) {
  
  _impl_.color_range_ = value;
}
inline void UncompressedHeader_ColorConfig::set_color_range(::VP9BitField value) {
  _internal_set_color_range(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.color_range)
}

// .VP9BitField subsampling_x = 4;
inline void UncompressedHeader_ColorConfig::clear_subsampling_x() {
  _impl_.subsampling_x_ = 0;
}
inline ::VP9BitField UncompressedHeader_ColorConfig::_internal_subsampling_x() const {
  return static_cast< ::VP9BitField >(_impl_.subsampling_x_);
}
inline ::VP9BitField UncompressedHeader_ColorConfig::subsampling_x() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.subsampling_x)
  return _internal_subsampling_x();
}
inline void UncompressedHeader_ColorConfig::_internal_set_subsampling_x(::VP9BitField value) {
  
  _impl_.subsampling_x_ = value;
}
inline void UncompressedHeader_ColorConfig::set_subsampling_x(::VP9BitField value) {
  _internal_set_subsampling_x(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.subsampling_x)
}

// .VP9BitField subsampling_y = 5;
inline void UncompressedHeader_ColorConfig::clear_subsampling_y() {
  _impl_.subsampling_y_ = 0;
}
inline ::VP9BitField UncompressedHeader_ColorConfig::_internal_subsampling_y() const {
  return static_cast< ::VP9BitField >(_impl_.subsampling_y_);
}
inline ::VP9BitField UncompressedHeader_ColorConfig::subsampling_y() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.subsampling_y)
  return _internal_subsampling_y();
}
inline void UncompressedHeader_ColorConfig::_internal_set_subsampling_y(::VP9BitField value) {
  
  _impl_.subsampling_y_ = value;
}
inline void UncompressedHeader_ColorConfig::set_subsampling_y(::VP9BitField value) {
  _internal_set_subsampling_y(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.subsampling_y)
}

// .VP9BitField reserved_zero = 6;
inline void UncompressedHeader_ColorConfig::clear_reserved_zero() {
  _impl_.reserved_zero_ = 0;
}
inline ::VP9BitField UncompressedHeader_ColorConfig::_internal_reserved_zero() const {
  return static_cast< ::VP9BitField >(_impl_.reserved_zero_);
}
inline ::VP9BitField UncompressedHeader_ColorConfig::reserved_zero() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.reserved_zero)
  return _internal_reserved_zero();
}
inline void UncompressedHeader_ColorConfig::_internal_set_reserved_zero(::VP9BitField value) {
  
  _impl_.reserved_zero_ = value;
}
inline void UncompressedHeader_ColorConfig::set_reserved_zero(::VP9BitField value) {
  _internal_set_reserved_zero(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.reserved_zero)
}

// -------------------------------------------------------------------

// UncompressedHeader_FrameSize

// uint32 frame_width_minus_1 = 1;
inline void UncompressedHeader_FrameSize::clear_frame_width_minus_1() {
  _impl_.frame_width_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_FrameSize::_internal_frame_width_minus_1() const {
  return _impl_.frame_width_minus_1_;
}
inline uint32_t UncompressedHeader_FrameSize::frame_width_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.FrameSize.frame_width_minus_1)
  return _internal_frame_width_minus_1();
}
inline void UncompressedHeader_FrameSize::_internal_set_frame_width_minus_1(uint32_t value) {

  _impl_.frame_width_minus_1_ = value;
}
inline void UncompressedHeader_FrameSize::set_frame_width_minus_1(uint32_t value) {
  _internal_set_frame_width_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.FrameSize.frame_width_minus_1)
}

// uint32 frame_height_minus_1 = 2;
inline void UncompressedHeader_FrameSize::clear_frame_height_minus_1() {
  _impl_.frame_height_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_FrameSize::_internal_frame_height_minus_1() const {
  return _impl_.frame_height_minus_1_;
}
inline uint32_t UncompressedHeader_FrameSize::frame_height_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.FrameSize.frame_height_minus_1)
  return _internal_frame_height_minus_1();
}
inline void UncompressedHeader_FrameSize::_internal_set_frame_height_minus_1(uint32_t value) {

  _impl_.frame_height_minus_1_ = value;
}
inline void UncompressedHeader_FrameSize::set_frame_height_minus_1(uint32_t value) {
  _internal_set_frame_height_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.FrameSize.frame_height_minus_1)
}

// -------------------------------------------------------------------

// UncompressedHeader_RenderSize

// .VP9BitField render_and_frame_size_different = 1;
inline void UncompressedHeader_RenderSize::clear_render_and_frame_size_different() {
  _impl_.render_and_frame_size_different_ = 0;
}
inline ::VP9BitField UncompressedHeader_RenderSize::_internal_render_and_frame_size_different() const {
  return static_cast< ::VP9BitField >(_impl_.render_and_frame_size_different_);
}
inline ::VP9BitField UncompressedHeader_RenderSize::render_and_frame_size_different() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.RenderSize.render_and_frame_size_different)
  return _internal_render_and_frame_size_different();
}
inline void UncompressedHeader_RenderSize::_internal_set_render_and_frame_size_different(::VP9BitField value) {
  
  _impl_.render_and_frame_size_different_ = value;
}
inline void UncompressedHeader_RenderSize::set_render_and_frame_size_different(::VP9BitField value) {
  _internal_set_render_and_frame_size_different(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.RenderSize.render_and_frame_size_different)
}

// uint32 render_width_minus_1 = 2;
inline void UncompressedHeader_RenderSize::clear_render_width_minus_1() {
  _impl_.render_width_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_RenderSize::_internal_render_width_minus_1() const {
  return _impl_.render_width_minus_1_;
}
inline uint32_t UncompressedHeader_RenderSize::render_width_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.RenderSize.render_width_minus_1)
  return _internal_render_width_minus_1();
}
inline void UncompressedHeader_RenderSize::_internal_set_render_width_minus_1(uint32_t value) {

  _impl_.render_width_minus_1_ = value;
}
inline void UncompressedHeader_RenderSize::set_render_width_minus_1(uint32_t value) {
  _internal_set_render_width_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.RenderSize.render_width_minus_1)
}

// uint32 render_height_minus_1 = 3;
inline void UncompressedHeader_RenderSize::clear_render_height_minus_1() {
  _impl_.render_height_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_RenderSize::_internal_render_height_minus_1() const {
  return _impl_.render_height_minus_1_;
}
inline uint32_t UncompressedHeader_RenderSize::render_height_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.RenderSize.render_height_minus_1)
  return _internal_render_height_minus_1();
}
inline void UncompressedHeader_RenderSize::_internal_set_render_height_minus_1(uint32_t value) {

  _impl_.render_height_minus_1_ = value;
}
inline void UncompressedHeader_RenderSize::set_render_height_minus_1(uint32_t value) {
  _internal_set_render_height_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.RenderSize.render_height_minus_1)
}

// -------------------------------------------------------------------

// UncompressedHeader_ReadInterpolationFilter

// .VP9BitField is_filter_switchable = 1;
inline void UncompressedHeader_ReadInterpolationFilter::clear_is_filter_switchable() {
  _impl_.is_filter_switchable_ = 0;
}
inline ::VP9BitField UncompressedHeader_ReadInterpolationFilter::_internal_is_filter_switchable() const {
  return static_cast< ::VP9BitField >(_impl_.is_filter_switchable_);
}
inline ::VP9BitField UncompressedHeader_ReadInterpolationFilter::is_filter_switchable() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ReadInterpolationFilter.is_filter_switchable)
  return _internal_is_filter_switchable();
}
inline void UncompressedHeader_ReadInterpolationFilter::_internal_set_is_filter_switchable(::VP9BitField value) {
  
  _impl_.is_filter_switchable_ = value;
}
inline void UncompressedHeader_ReadInterpolationFilter::set_is_filter_switchable(::VP9BitField value) {
  _internal_set_is_filter_switchable(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ReadInterpolationFilter.is_filter_switchable)
}

// .UncompressedHeader.InterpolationFilter raw_interpolation_filter = 2;
inline void UncompressedHeader_ReadInterpolationFilter::clear_raw_interpolation_filter() {
  _impl_.raw_interpolation_filter_ = 0;
}
inline ::UncompressedHeader_InterpolationFilter UncompressedHeader_ReadInterpolationFilter::_internal_raw_interpolation_filter() const {
  return static_cast< ::UncompressedHeader_InterpolationFilter >(_impl_.raw_interpolation_filter_);
}
inline ::UncompressedHeader_InterpolationFilter UncompressedHeader_ReadInterpolationFilter::raw_interpolation_filter() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ReadInterpolationFilter.raw_interpolation_filter)
  return _internal_raw_interpolation_filter();
}
inline void UncompressedHeader_ReadInterpolationFilter::_internal_set_raw_interpolation_filter(::UncompressedHeader_InterpolationFilter value) {
  
  _impl_.raw_interpolation_filter_ = value;
}
inline void UncompressedHeader_ReadInterpolationFilter::set_raw_interpolation_filter(::UncompressedHeader_InterpolationFilter value) {
  _internal_set_raw_interpolation_filter(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ReadInterpolationFilter.raw_interpolation_filter)
}

// -------------------------------------------------------------------

// UncompressedHeader_LoopFilterParams_RefDelta

// .VP9BitField update_ref_delta = 1;
inline void UncompressedHeader_LoopFilterParams_RefDelta::clear_update_ref_delta() {
  _impl_.update_ref_delta_ = 0;
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams_RefDelta::_internal_update_ref_delta() const {
  return static_cast< ::VP9BitField >(_impl_.update_ref_delta_);
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams_RefDelta::update_ref_delta() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.RefDelta.update_ref_delta)
  return _internal_update_ref_delta();
}
inline void UncompressedHeader_LoopFilterParams_RefDelta::_internal_set_update_ref_delta(::VP9BitField value) {
  
  _impl_.update_ref_delta_ = value;
}
inline void UncompressedHeader_LoopFilterParams_RefDelta::set_update_ref_delta(::VP9BitField value) {
  _internal_set_update_ref_delta(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.RefDelta.update_ref_delta)
}

// .VP9SignedInteger loop_filter_ref_deltas = 2;
inline bool UncompressedHeader_LoopFilterParams_RefDelta::_internal_has_loop_filter_ref_deltas() const {
  return this != internal_default_instance() && _impl_.loop_filter_ref_deltas_ != nullptr;
}
inline bool UncompressedHeader_LoopFilterParams_RefDelta::has_loop_filter_ref_deltas() const {
  return _internal_has_loop_filter_ref_deltas();
}
inline void UncompressedHeader_LoopFilterParams_RefDelta::clear_loop_filter_ref_deltas() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_ref_deltas_ != nullptr) {
    delete _impl_.loop_filter_ref_deltas_;
  }
  _impl_.loop_filter_ref_deltas_ = nullptr;
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams_RefDelta::_internal_loop_filter_ref_deltas() const {
  const ::VP9SignedInteger* p = _impl_.loop_filter_ref_deltas_;
  return p != nullptr ? *p : reinterpret_cast<const ::VP9SignedInteger&>(
      ::_VP9SignedInteger_default_instance_);
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams_RefDelta::loop_filter_ref_deltas() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.RefDelta.loop_filter_ref_deltas)
  return _internal_loop_filter_ref_deltas();
}
inline void UncompressedHeader_LoopFilterParams_RefDelta::unsafe_arena_set_allocated_loop_filter_ref_deltas(
    ::VP9SignedInteger* loop_filter_ref_deltas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_filter_ref_deltas_);
  }
  _impl_.loop_filter_ref_deltas_ = loop_filter_ref_deltas;
  if (loop_filter_ref_deltas) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.LoopFilterParams.RefDelta.loop_filter_ref_deltas)
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_RefDelta::release_loop_filter_ref_deltas() {
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_ref_deltas_;
  _impl_.loop_filter_ref_deltas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_RefDelta::unsafe_arena_release_loop_filter_ref_deltas() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.LoopFilterParams.RefDelta.loop_filter_ref_deltas)
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_ref_deltas_;
  _impl_.loop_filter_ref_deltas_ = nullptr;
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_RefDelta::_internal_mutable_loop_filter_ref_deltas() {
  
  if (_impl_.loop_filter_ref_deltas_ == nullptr) {
    auto* p = CreateMaybeMessage<::VP9SignedInteger>(GetArenaForAllocation());
    _impl_.loop_filter_ref_deltas_ = p;
  }
  return _impl_.loop_filter_ref_deltas_;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_RefDelta::mutable_loop_filter_ref_deltas() {
  ::VP9SignedInteger* _msg = _internal_mutable_loop_filter_ref_deltas();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.LoopFilterParams.RefDelta.loop_filter_ref_deltas)
  return _msg;
}
inline void UncompressedHeader_LoopFilterParams_RefDelta::set_allocated_loop_filter_ref_deltas(::VP9SignedInteger* loop_filter_ref_deltas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_filter_ref_deltas_;
  }
  if (loop_filter_ref_deltas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_filter_ref_deltas);
    if (message_arena != submessage_arena) {
      loop_filter_ref_deltas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_filter_ref_deltas, submessage_arena);
    }

  } else {

  }
  _impl_.loop_filter_ref_deltas_ = loop_filter_ref_deltas;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.LoopFilterParams.RefDelta.loop_filter_ref_deltas)
}

// -------------------------------------------------------------------

// UncompressedHeader_LoopFilterParams_ModeDelta

// .VP9BitField update_mode_delta = 1;
inline void UncompressedHeader_LoopFilterParams_ModeDelta::clear_update_mode_delta() {
  _impl_.update_mode_delta_ = 0;
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams_ModeDelta::_internal_update_mode_delta() const {
  return static_cast< ::VP9BitField >(_impl_.update_mode_delta_);
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams_ModeDelta::update_mode_delta() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.ModeDelta.update_mode_delta)
  return _internal_update_mode_delta();
}
inline void UncompressedHeader_LoopFilterParams_ModeDelta::_internal_set_update_mode_delta(::VP9BitField value) {
  
  _impl_.update_mode_delta_ = value;
}
inline void UncompressedHeader_LoopFilterParams_ModeDelta::set_update_mode_delta(::VP9BitField value) {
  _internal_set_update_mode_delta(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.ModeDelta.update_mode_delta)
}

// .VP9SignedInteger loop_filter_mode_deltas = 2;
inline bool UncompressedHeader_LoopFilterParams_ModeDelta::_internal_has_loop_filter_mode_deltas() const {
  return this != internal_default_instance() && _impl_.loop_filter_mode_deltas_ != nullptr;
}
inline bool UncompressedHeader_LoopFilterParams_ModeDelta::has_loop_filter_mode_deltas() const {
  return _internal_has_loop_filter_mode_deltas();
}
inline void UncompressedHeader_LoopFilterParams_ModeDelta::clear_loop_filter_mode_deltas() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_mode_deltas_ != nullptr) {
    delete _impl_.loop_filter_mode_deltas_;
  }
  _impl_.loop_filter_mode_deltas_ = nullptr;
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams_ModeDelta::_internal_loop_filter_mode_deltas() const {
  const ::VP9SignedInteger* p = _impl_.loop_filter_mode_deltas_;
  return p != nullptr ? *p : reinterpret_cast<const ::VP9SignedInteger&>(
      ::_VP9SignedInteger_default_instance_);
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams_ModeDelta::loop_filter_mode_deltas() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.ModeDelta.loop_filter_mode_deltas)
  return _internal_loop_filter_mode_deltas();
}
inline void UncompressedHeader_LoopFilterParams_ModeDelta::unsafe_arena_set_allocated_loop_filter_mode_deltas(
    ::VP9SignedInteger* loop_filter_mode_deltas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_filter_mode_deltas_);
  }
  _impl_.loop_filter_mode_deltas_ = loop_filter_mode_deltas;
  if (loop_filter_mode_deltas) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.LoopFilterParams.ModeDelta.loop_filter_mode_deltas)
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_ModeDelta::release_loop_filter_mode_deltas() {
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_mode_deltas_;
  _impl_.loop_filter_mode_deltas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_ModeDelta::unsafe_arena_release_loop_filter_mode_deltas() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.LoopFilterParams.ModeDelta.loop_filter_mode_deltas)
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_mode_deltas_;
  _impl_.loop_filter_mode_deltas_ = nullptr;
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_ModeDelta::_internal_mutable_loop_filter_mode_deltas() {
  
  if (_impl_.loop_filter_mode_deltas_ == nullptr) {
    auto* p = CreateMaybeMessage<::VP9SignedInteger>(GetArenaForAllocation());
    _impl_.loop_filter_mode_deltas_ = p;
  }
  return _impl_.loop_filter_mode_deltas_;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams_ModeDelta::mutable_loop_filter_mode_deltas() {
  ::VP9SignedInteger* _msg = _internal_mutable_loop_filter_mode_deltas();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.LoopFilterParams.ModeDelta.loop_filter_mode_deltas)
  return _msg;
}
inline void UncompressedHeader_LoopFilterParams_ModeDelta::set_allocated_loop_filter_mode_deltas(::VP9SignedInteger* loop_filter_mode_deltas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_filter_mode_deltas_;
  }
  if (loop_filter_mode_deltas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_filter_mode_deltas);
    if (message_arena != submessage_arena) {
      loop_filter_mode_deltas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_filter_mode_deltas, submessage_arena);
    }

  } else {

  }
  _impl_.loop_filter_mode_deltas_ = loop_filter_mode_deltas;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.LoopFilterParams.ModeDelta.loop_filter_mode_deltas)
}

// -------------------------------------------------------------------

// UncompressedHeader_LoopFilterParams

// uint32 loop_filter_level = 1;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_level() {
  _impl_.loop_filter_level_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_loop_filter_level() const {
  return _impl_.loop_filter_level_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::loop_filter_level() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_level)
  return _internal_loop_filter_level();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_level(uint32_t value) {

  _impl_.loop_filter_level_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_level(uint32_t value) {
  _internal_set_loop_filter_level(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_level)
}

// uint32 loop_filter_sharpness = 2;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_sharpness() {
  _impl_.loop_filter_sharpness_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_loop_filter_sharpness() const {
  return _impl_.loop_filter_sharpness_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::loop_filter_sharpness() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_sharpness)
  return _internal_loop_filter_sharpness();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_sharpness(uint32_t value) {

  _impl_.loop_filter_sharpness_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_sharpness(uint32_t value) {
  _internal_set_loop_filter_sharpness(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_sharpness)
}

// .VP9BitField loop_filter_delta_enabled = 3;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_delta_enabled() {
  _impl_.loop_filter_delta_enabled_ = 0;
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams::_internal_loop_filter_delta_enabled() const {
  return static_cast< ::VP9BitField >(_impl_.loop_filter_delta_enabled_);
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams::loop_filter_delta_enabled() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_delta_enabled)
  return _internal_loop_filter_delta_enabled();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_delta_enabled(::VP9BitField value) {
  
  _impl_.loop_filter_delta_enabled_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_delta_enabled(::VP9BitField value) {
  _internal_set_loop_filter_delta_enabled(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_delta_enabled)
}

// .VP9BitField loop_filter_delta_update = 4;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_delta_update() {
  _impl_.loop_filter_delta_update_ = 0;
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams::_internal_loop_filter_delta_update() const {
  return static_cast< ::VP9BitField >(_impl_.loop_filter_delta_update_);
}
inline ::VP9BitField UncompressedHeader_LoopFilterParams::loop_filter_delta_update() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_delta_update)
  return _internal_loop_filter_delta_update();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_delta_update(::VP9BitField value) {
  
  _impl_.loop_filter_delta_update_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_delta_update(::VP9BitField value) {
  _internal_set_loop_filter_delta_update(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_delta_update)
}

// repeated .UncompressedHeader.LoopFilterParams.RefDelta ref_delta = 5;
inline int UncompressedHeader_LoopFilterParams::_internal_ref_delta_size() const {
  return _impl_.ref_delta_.size();
}
inline int UncompressedHeader_LoopFilterParams::ref_delta_size() const {
  return _internal_ref_delta_size();
}
inline void UncompressedHeader_LoopFilterParams::clear_ref_delta() {
  _impl_.ref_delta_.Clear();
}
inline ::UncompressedHeader_LoopFilterParams_RefDelta* UncompressedHeader_LoopFilterParams::mutable_ref_delta(int index) {
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.LoopFilterParams.ref_delta)
  return _impl_.ref_delta_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_RefDelta >*
UncompressedHeader_LoopFilterParams::mutable_ref_delta() {
  // @@protoc_insertion_point(field_mutable_list:UncompressedHeader.LoopFilterParams.ref_delta)
  return &_impl_.ref_delta_;
}
inline const ::UncompressedHeader_LoopFilterParams_RefDelta& UncompressedHeader_LoopFilterParams::_internal_ref_delta(int index) const {
  return _impl_.ref_delta_.Get(index);
}
inline const ::UncompressedHeader_LoopFilterParams_RefDelta& UncompressedHeader_LoopFilterParams::ref_delta(int index) const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.ref_delta)
  return _internal_ref_delta(index);
}
inline ::UncompressedHeader_LoopFilterParams_RefDelta* UncompressedHeader_LoopFilterParams::_internal_add_ref_delta() {
  return _impl_.ref_delta_.Add();
}
inline ::UncompressedHeader_LoopFilterParams_RefDelta* UncompressedHeader_LoopFilterParams::add_ref_delta() {
  ::UncompressedHeader_LoopFilterParams_RefDelta* _add = _internal_add_ref_delta();
  // @@protoc_insertion_point(field_add:UncompressedHeader.LoopFilterParams.ref_delta)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_RefDelta >&
UncompressedHeader_LoopFilterParams::ref_delta() const {
  // @@protoc_insertion_point(field_list:UncompressedHeader.LoopFilterParams.ref_delta)
  return _impl_.ref_delta_;
}

// repeated .UncompressedHeader.LoopFilterParams.ModeDelta mode_delta = 6;
inline int UncompressedHeader_LoopFilterParams::_internal_mode_delta_size() const {
  return _impl_.mode_delta_.size();
}
inline int UncompressedHeader_LoopFilterParams::mode_delta_size() const {
  return _internal_mode_delta_size();
}
inline void UncompressedHeader_LoopFilterParams::clear_mode_delta() {
  _impl_.mode_delta_.Clear();
}
inline ::UncompressedHeader_LoopFilterParams_ModeDelta* UncompressedHeader_LoopFilterParams::mutable_mode_delta(int index) {
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.LoopFilterParams.mode_delta)
  return _impl_.mode_delta_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_ModeDelta >*
UncompressedHeader_LoopFilterParams::mutable_mode_delta() {
  // @@protoc_insertion_point(field_mutable_list:UncompressedHeader.LoopFilterParams.mode_delta)
  return &_impl_.mode_delta_;
}
inline const ::UncompressedHeader_LoopFilterParams_ModeDelta& UncompressedHeader_LoopFilterParams::_internal_mode_delta(int index) const {
  return _impl_.mode_delta_.Get(index);
}
inline const ::UncompressedHeader_LoopFilterParams_ModeDelta& UncompressedHeader_LoopFilterParams::mode_delta(int index) const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.mode_delta)
  return _internal_mode_delta(index);
}
inline ::UncompressedHeader_LoopFilterParams_ModeDelta* UncompressedHeader_LoopFilterParams::_internal_add_mode_delta() {
  return _impl_.mode_delta_.Add();
}
inline ::UncompressedHeader_LoopFilterParams_ModeDelta* UncompressedHeader_LoopFilterParams::add_mode_delta() {
  ::UncompressedHeader_LoopFilterParams_ModeDelta* _add = _internal_add_mode_delta();
  // @@protoc_insertion_point(field_add:UncompressedHeader.LoopFilterParams.mode_delta)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_LoopFilterParams_ModeDelta >&
UncompressedHeader_LoopFilterParams::mode_delta() const {
  // @@protoc_insertion_point(field_list:UncompressedHeader.LoopFilterParams.mode_delta)
  return _impl_.mode_delta_;
}

// -------------------------------------------------------------------

// UncompressedHeader_QuantizationParams_ReadDeltaQ

// .VP9BitField delta_coded = 1;
inline void UncompressedHeader_QuantizationParams_ReadDeltaQ::clear_delta_coded() {
  _impl_.delta_coded_ = 0;
}
inline ::VP9BitField UncompressedHeader_QuantizationParams_ReadDeltaQ::_internal_delta_coded() const {
  return static_cast< ::VP9BitField >(_impl_.delta_coded_);
}
inline ::VP9BitField UncompressedHeader_QuantizationParams_ReadDeltaQ::delta_coded() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_coded)
  return _internal_delta_coded();
}
inline void UncompressedHeader_QuantizationParams_ReadDeltaQ::_internal_set_delta_coded(::VP9BitField value) {
  
  _impl_.delta_coded_ = value;
}
inline void UncompressedHeader_QuantizationParams_ReadDeltaQ::set_delta_coded(::VP9BitField value) {
  _internal_set_delta_coded(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_coded)
}

// .VP9SignedInteger delta_q = 2;
inline bool UncompressedHeader_QuantizationParams_ReadDeltaQ::_internal_has_delta_q() const {
  return this != internal_default_instance() && _impl_.delta_q_ != nullptr;
}
inline bool UncompressedHeader_QuantizationParams_ReadDeltaQ::has_delta_q() const {
  return _internal_has_delta_q();
}
inline void UncompressedHeader_QuantizationParams_ReadDeltaQ::clear_delta_q() {
  if (GetArenaForAllocation() == nullptr && _impl_.delta_q_ != nullptr) {
    delete _impl_.delta_q_;
  }
  _impl_.delta_q_ = nullptr;
}
inline const ::VP9SignedInteger& UncompressedHeader_QuantizationParams_ReadDeltaQ::_internal_delta_q() const {
  const ::VP9SignedInteger* p = _impl_.delta_q_;
  return p != nullptr ? *p : reinterpret_cast<const ::VP9SignedInteger&>(
      ::_VP9SignedInteger_default_instance_);
}
inline const ::VP9SignedInteger& UncompressedHeader_QuantizationParams_ReadDeltaQ::delta_q() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_q)
  return _internal_delta_q();
}
inline void UncompressedHeader_QuantizationParams_ReadDeltaQ::unsafe_arena_set_allocated_delta_q(
    ::VP9SignedInteger* delta_q) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_q_);
  }
  _impl_.delta_q_ = delta_q;
  if (delta_q) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_q)
}
inline ::VP9SignedInteger* UncompressedHeader_QuantizationParams_ReadDeltaQ::release_delta_q() {
  
  ::VP9SignedInteger* temp = _impl_.delta_q_;
  _impl_.delta_q_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_QuantizationParams_ReadDeltaQ::unsafe_arena_release_delta_q() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_q)
  
  ::VP9SignedInteger* temp = _impl_.delta_q_;
  _impl_.delta_q_ = nullptr;
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_QuantizationParams_ReadDeltaQ::_internal_mutable_delta_q() {
  
  if (_impl_.delta_q_ == nullptr) {
    auto* p = CreateMaybeMessage<::VP9SignedInteger>(GetArenaForAllocation());
    _impl_.delta_q_ = p;
  }
  return _impl_.delta_q_;
}
inline ::VP9SignedInteger* UncompressedHeader_QuantizationParams_ReadDeltaQ::mutable_delta_q() {
  ::VP9SignedInteger* _msg = _internal_mutable_delta_q();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_q)
  return _msg;
}
inline void UncompressedHeader_QuantizationParams_ReadDeltaQ::set_allocated_delta_q(::VP9SignedInteger* delta_q) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.delta_q_;
  }
  if (delta_q) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delta_q);
    if (message_arena != submessage_arena) {
      delta_q = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delta_q, submessage_arena);
    }

  } else {

  }
  _impl_.delta_q_ = delta_q;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.QuantizationParams.ReadDeltaQ.delta_q)
}

// -------------------------------------------------------------------

// UncompressedHeader_QuantizationParams

// uint32 base_q_idx = 1;
inline void UncompressedHeader_QuantizationParams::clear_base_q_idx() {
  _impl_.base_q_idx_ = 0u;
}
inline uint32_t UncompressedHeader_QuantizationParams::_internal_base_q_idx() const {
  return _impl_.base_q_idx_;
}
inline uint32_t UncompressedHeader_QuantizationParams::base_q_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.base_q_idx)
  return _internal_base_q_idx();
}
inline void UncompressedHeader_QuantizationParams::_internal_set_base_q_idx(uint32_t value) {

  _impl_.base_q_idx_ = value;
}
inline void UncompressedHeader_QuantizationParams::set_base_q_idx(uint32_t value) {
  _internal_set_base_q_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.QuantizationParams.base_q_idx)
}

// .UncompressedHeader.QuantizationParams.ReadDeltaQ delta_q_y_dc = 2;
inline bool UncompressedHeader_QuantizationParams::_internal_has_delta_q_y_dc() const {
  return this != internal_default_instance() && _impl_.delta_q_y_dc_ != nullptr;
}
inline bool UncompressedHeader_QuantizationParams::has_delta_q_y_dc() const {
  return _internal_has_delta_q_y_dc();
}
inline void UncompressedHeader_QuantizationParams::clear_delta_q_y_dc() {
  if (GetArenaForAllocation() == nullptr && _impl_.delta_q_y_dc_ != nullptr) {
    delete _impl_.delta_q_y_dc_;
  }
  _impl_.delta_q_y_dc_ = nullptr;
}
inline const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& UncompressedHeader_QuantizationParams::_internal_delta_q_y_dc() const {
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ* p = _impl_.delta_q_y_dc_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_QuantizationParams_ReadDeltaQ&>(
      ::_UncompressedHeader_QuantizationParams_ReadDeltaQ_default_instance_);
}
inline const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& UncompressedHeader_QuantizationParams::delta_q_y_dc() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.delta_q_y_dc)
  return _internal_delta_q_y_dc();
}
inline void UncompressedHeader_QuantizationParams::unsafe_arena_set_allocated_delta_q_y_dc(
    ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_y_dc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_q_y_dc_);
  }
  _impl_.delta_q_y_dc_ = delta_q_y_dc;
  if (delta_q_y_dc) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.QuantizationParams.delta_q_y_dc)
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::release_delta_q_y_dc() {
  
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* temp = _impl_.delta_q_y_dc_;
  _impl_.delta_q_y_dc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::unsafe_arena_release_delta_q_y_dc() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.QuantizationParams.delta_q_y_dc)
  
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* temp = _impl_.delta_q_y_dc_;
  _impl_.delta_q_y_dc_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::_internal_mutable_delta_q_y_dc() {
  
  if (_impl_.delta_q_y_dc_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_QuantizationParams_ReadDeltaQ>(GetArenaForAllocation());
    _impl_.delta_q_y_dc_ = p;
  }
  return _impl_.delta_q_y_dc_;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::mutable_delta_q_y_dc() {
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* _msg = _internal_mutable_delta_q_y_dc();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.QuantizationParams.delta_q_y_dc)
  return _msg;
}
inline void UncompressedHeader_QuantizationParams::set_allocated_delta_q_y_dc(::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_y_dc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.delta_q_y_dc_;
  }
  if (delta_q_y_dc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delta_q_y_dc);
    if (message_arena != submessage_arena) {
      delta_q_y_dc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delta_q_y_dc, submessage_arena);
    }

  } else {

  }
  _impl_.delta_q_y_dc_ = delta_q_y_dc;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.QuantizationParams.delta_q_y_dc)
}

// .UncompressedHeader.QuantizationParams.ReadDeltaQ delta_q_uv_dc = 3;
inline bool UncompressedHeader_QuantizationParams::_internal_has_delta_q_uv_dc() const {
  return this != internal_default_instance() && _impl_.delta_q_uv_dc_ != nullptr;
}
inline bool UncompressedHeader_QuantizationParams::has_delta_q_uv_dc() const {
  return _internal_has_delta_q_uv_dc();
}
inline void UncompressedHeader_QuantizationParams::clear_delta_q_uv_dc() {
  if (GetArenaForAllocation() == nullptr && _impl_.delta_q_uv_dc_ != nullptr) {
    delete _impl_.delta_q_uv_dc_;
  }
  _impl_.delta_q_uv_dc_ = nullptr;
}
inline const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& UncompressedHeader_QuantizationParams::_internal_delta_q_uv_dc() const {
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ* p = _impl_.delta_q_uv_dc_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_QuantizationParams_ReadDeltaQ&>(
      ::_UncompressedHeader_QuantizationParams_ReadDeltaQ_default_instance_);
}
inline const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& UncompressedHeader_QuantizationParams::delta_q_uv_dc() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.delta_q_uv_dc)
  return _internal_delta_q_uv_dc();
}
inline void UncompressedHeader_QuantizationParams::unsafe_arena_set_allocated_delta_q_uv_dc(
    ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_dc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_q_uv_dc_);
  }
  _impl_.delta_q_uv_dc_ = delta_q_uv_dc;
  if (delta_q_uv_dc) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.QuantizationParams.delta_q_uv_dc)
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::release_delta_q_uv_dc() {
  
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* temp = _impl_.delta_q_uv_dc_;
  _impl_.delta_q_uv_dc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::unsafe_arena_release_delta_q_uv_dc() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.QuantizationParams.delta_q_uv_dc)
  
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* temp = _impl_.delta_q_uv_dc_;
  _impl_.delta_q_uv_dc_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::_internal_mutable_delta_q_uv_dc() {
  
  if (_impl_.delta_q_uv_dc_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_QuantizationParams_ReadDeltaQ>(GetArenaForAllocation());
    _impl_.delta_q_uv_dc_ = p;
  }
  return _impl_.delta_q_uv_dc_;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::mutable_delta_q_uv_dc() {
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* _msg = _internal_mutable_delta_q_uv_dc();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.QuantizationParams.delta_q_uv_dc)
  return _msg;
}
inline void UncompressedHeader_QuantizationParams::set_allocated_delta_q_uv_dc(::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_dc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.delta_q_uv_dc_;
  }
  if (delta_q_uv_dc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delta_q_uv_dc);
    if (message_arena != submessage_arena) {
      delta_q_uv_dc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delta_q_uv_dc, submessage_arena);
    }

  } else {

  }
  _impl_.delta_q_uv_dc_ = delta_q_uv_dc;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.QuantizationParams.delta_q_uv_dc)
}

// .UncompressedHeader.QuantizationParams.ReadDeltaQ delta_q_uv_ac = 4;
inline bool UncompressedHeader_QuantizationParams::_internal_has_delta_q_uv_ac() const {
  return this != internal_default_instance() && _impl_.delta_q_uv_ac_ != nullptr;
}
inline bool UncompressedHeader_QuantizationParams::has_delta_q_uv_ac() const {
  return _internal_has_delta_q_uv_ac();
}
inline void UncompressedHeader_QuantizationParams::clear_delta_q_uv_ac() {
  if (GetArenaForAllocation() == nullptr && _impl_.delta_q_uv_ac_ != nullptr) {
    delete _impl_.delta_q_uv_ac_;
  }
  _impl_.delta_q_uv_ac_ = nullptr;
}
inline const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& UncompressedHeader_QuantizationParams::_internal_delta_q_uv_ac() const {
  const ::UncompressedHeader_QuantizationParams_ReadDeltaQ* p = _impl_.delta_q_uv_ac_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_QuantizationParams_ReadDeltaQ&>(
      ::_UncompressedHeader_QuantizationParams_ReadDeltaQ_default_instance_);
}
inline const ::UncompressedHeader_QuantizationParams_ReadDeltaQ& UncompressedHeader_QuantizationParams::delta_q_uv_ac() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.delta_q_uv_ac)
  return _internal_delta_q_uv_ac();
}
inline void UncompressedHeader_QuantizationParams::unsafe_arena_set_allocated_delta_q_uv_ac(
    ::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_ac) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.delta_q_uv_ac_);
  }
  _impl_.delta_q_uv_ac_ = delta_q_uv_ac;
  if (delta_q_uv_ac) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.QuantizationParams.delta_q_uv_ac)
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::release_delta_q_uv_ac() {
  
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* temp = _impl_.delta_q_uv_ac_;
  _impl_.delta_q_uv_ac_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::unsafe_arena_release_delta_q_uv_ac() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.QuantizationParams.delta_q_uv_ac)
  
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* temp = _impl_.delta_q_uv_ac_;
  _impl_.delta_q_uv_ac_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::_internal_mutable_delta_q_uv_ac() {
  
  if (_impl_.delta_q_uv_ac_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_QuantizationParams_ReadDeltaQ>(GetArenaForAllocation());
    _impl_.delta_q_uv_ac_ = p;
  }
  return _impl_.delta_q_uv_ac_;
}
inline ::UncompressedHeader_QuantizationParams_ReadDeltaQ* UncompressedHeader_QuantizationParams::mutable_delta_q_uv_ac() {
  ::UncompressedHeader_QuantizationParams_ReadDeltaQ* _msg = _internal_mutable_delta_q_uv_ac();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.QuantizationParams.delta_q_uv_ac)
  return _msg;
}
inline void UncompressedHeader_QuantizationParams::set_allocated_delta_q_uv_ac(::UncompressedHeader_QuantizationParams_ReadDeltaQ* delta_q_uv_ac) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.delta_q_uv_ac_;
  }
  if (delta_q_uv_ac) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delta_q_uv_ac);
    if (message_arena != submessage_arena) {
      delta_q_uv_ac = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delta_q_uv_ac, submessage_arena);
    }

  } else {

  }
  _impl_.delta_q_uv_ac_ = delta_q_uv_ac;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.QuantizationParams.delta_q_uv_ac)
}

// -------------------------------------------------------------------

// UncompressedHeader_TileInfo

// .VP9BitField tile_rows_log2 = 1;
inline void UncompressedHeader_TileInfo::clear_tile_rows_log2() {
  _impl_.tile_rows_log2_ = 0;
}
inline ::VP9BitField UncompressedHeader_TileInfo::_internal_tile_rows_log2() const {
  return static_cast< ::VP9BitField >(_impl_.tile_rows_log2_);
}
inline ::VP9BitField UncompressedHeader_TileInfo::tile_rows_log2() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.TileInfo.tile_rows_log2)
  return _internal_tile_rows_log2();
}
inline void UncompressedHeader_TileInfo::_internal_set_tile_rows_log2(::VP9BitField value) {
  
  _impl_.tile_rows_log2_ = value;
}
inline void UncompressedHeader_TileInfo::set_tile_rows_log2(::VP9BitField value) {
  _internal_set_tile_rows_log2(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.TileInfo.tile_rows_log2)
}

// .VP9BitField increment_tile_rows_log2 = 2;
inline void UncompressedHeader_TileInfo::clear_increment_tile_rows_log2() {
  _impl_.increment_tile_rows_log2_ = 0;
}
inline ::VP9BitField UncompressedHeader_TileInfo::_internal_increment_tile_rows_log2() const {
  return static_cast< ::VP9BitField >(_impl_.increment_tile_rows_log2_);
}
inline ::VP9BitField UncompressedHeader_TileInfo::increment_tile_rows_log2() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.TileInfo.increment_tile_rows_log2)
  return _internal_increment_tile_rows_log2();
}
inline void UncompressedHeader_TileInfo::_internal_set_increment_tile_rows_log2(::VP9BitField value) {
  
  _impl_.increment_tile_rows_log2_ = value;
}
inline void UncompressedHeader_TileInfo::set_increment_tile_rows_log2(::VP9BitField value) {
  _internal_set_increment_tile_rows_log2(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.TileInfo.increment_tile_rows_log2)
}

// -------------------------------------------------------------------

// UncompressedHeader_SegmentationParams_ReadProb

// .VP9BitField prob_coded = 1;
inline void UncompressedHeader_SegmentationParams_ReadProb::clear_prob_coded() {
  _impl_.prob_coded_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams_ReadProb::_internal_prob_coded() const {
  return static_cast< ::VP9BitField >(_impl_.prob_coded_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams_ReadProb::prob_coded() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.ReadProb.prob_coded)
  return _internal_prob_coded();
}
inline void UncompressedHeader_SegmentationParams_ReadProb::_internal_set_prob_coded(::VP9BitField value) {
  
  _impl_.prob_coded_ = value;
}
inline void UncompressedHeader_SegmentationParams_ReadProb::set_prob_coded(::VP9BitField value) {
  _internal_set_prob_coded(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.ReadProb.prob_coded)
}

// uint32 prob = 2;
inline void UncompressedHeader_SegmentationParams_ReadProb::clear_prob() {
  _impl_.prob_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams_ReadProb::_internal_prob() const {
  return _impl_.prob_;
}
inline uint32_t UncompressedHeader_SegmentationParams_ReadProb::prob() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.ReadProb.prob)
  return _internal_prob();
}
inline void UncompressedHeader_SegmentationParams_ReadProb::_internal_set_prob(uint32_t value) {

  _impl_.prob_ = value;
}
inline void UncompressedHeader_SegmentationParams_ReadProb::set_prob(uint32_t value) {
  _internal_set_prob(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.ReadProb.prob)
}

// -------------------------------------------------------------------

// UncompressedHeader_SegmentationParams_Feature

// .VP9BitField feature_enabled = 1;
inline void UncompressedHeader_SegmentationParams_Feature::clear_feature_enabled() {
  _impl_.feature_enabled_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams_Feature::_internal_feature_enabled() const {
  return static_cast< ::VP9BitField >(_impl_.feature_enabled_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams_Feature::feature_enabled() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.Feature.feature_enabled)
  return _internal_feature_enabled();
}
inline void UncompressedHeader_SegmentationParams_Feature::_internal_set_feature_enabled(::VP9BitField value) {
  
  _impl_.feature_enabled_ = value;
}
inline void UncompressedHeader_SegmentationParams_Feature::set_feature_enabled(::VP9BitField value) {
  _internal_set_feature_enabled(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.Feature.feature_enabled)
}

// bytes feature_value = 2;
inline void UncompressedHeader_SegmentationParams_Feature::clear_feature_value() {
  _impl_.feature_value_.ClearToEmpty();
}
inline const std::string& UncompressedHeader_SegmentationParams_Feature::feature_value() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.Feature.feature_value)
  return _internal_feature_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UncompressedHeader_SegmentationParams_Feature::set_feature_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feature_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.Feature.feature_value)
}
inline std::string* UncompressedHeader_SegmentationParams_Feature::mutable_feature_value() {
  std::string* _s = _internal_mutable_feature_value();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.SegmentationParams.Feature.feature_value)
  return _s;
}
inline const std::string& UncompressedHeader_SegmentationParams_Feature::_internal_feature_value() const {
  return _impl_.feature_value_.Get();
}
inline void UncompressedHeader_SegmentationParams_Feature::_internal_set_feature_value(const std::string& value) {

  _impl_.feature_value_.Set(value, GetArenaForAllocation());
}
inline std::string* UncompressedHeader_SegmentationParams_Feature::_internal_mutable_feature_value() {

  return _impl_.feature_value_.Mutable(GetArenaForAllocation());
}
inline std::string* UncompressedHeader_SegmentationParams_Feature::release_feature_value() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.SegmentationParams.Feature.feature_value)
  return _impl_.feature_value_.Release();
}
inline void UncompressedHeader_SegmentationParams_Feature::set_allocated_feature_value(std::string* feature_value) {
  if (feature_value != nullptr) {

  } else {

  }
  _impl_.feature_value_.SetAllocated(feature_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feature_value_.IsDefault()) {
    _impl_.feature_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.SegmentationParams.Feature.feature_value)
}

// .VP9BitField feature_sign = 3;
inline void UncompressedHeader_SegmentationParams_Feature::clear_feature_sign() {
  _impl_.feature_sign_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams_Feature::_internal_feature_sign() const {
  return static_cast< ::VP9BitField >(_impl_.feature_sign_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams_Feature::feature_sign() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.Feature.feature_sign)
  return _internal_feature_sign();
}
inline void UncompressedHeader_SegmentationParams_Feature::_internal_set_feature_sign(::VP9BitField value) {
  
  _impl_.feature_sign_ = value;
}
inline void UncompressedHeader_SegmentationParams_Feature::set_feature_sign(::VP9BitField value) {
  _internal_set_feature_sign(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.Feature.feature_sign)
}

// -------------------------------------------------------------------

// UncompressedHeader_SegmentationParams

// .VP9BitField segmentation_enabled = 1;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_enabled() {
  _impl_.segmentation_enabled_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::_internal_segmentation_enabled() const {
  return static_cast< ::VP9BitField >(_impl_.segmentation_enabled_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::segmentation_enabled() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_enabled)
  return _internal_segmentation_enabled();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_enabled(::VP9BitField value) {
  
  _impl_.segmentation_enabled_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_enabled(::VP9BitField value) {
  _internal_set_segmentation_enabled(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_enabled)
}

// .VP9BitField segmentation_update_map = 2;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_update_map() {
  _impl_.segmentation_update_map_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::_internal_segmentation_update_map() const {
  return static_cast< ::VP9BitField >(_impl_.segmentation_update_map_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::segmentation_update_map() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_update_map)
  return _internal_segmentation_update_map();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_update_map(::VP9BitField value) {
  
  _impl_.segmentation_update_map_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_update_map(::VP9BitField value) {
  _internal_set_segmentation_update_map(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_update_map)
}

// .VP9BitField segmentation_temporal_update = 3;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_temporal_update() {
  _impl_.segmentation_temporal_update_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::_internal_segmentation_temporal_update() const {
  return static_cast< ::VP9BitField >(_impl_.segmentation_temporal_update_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::segmentation_temporal_update() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_temporal_update)
  return _internal_segmentation_temporal_update();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_temporal_update(::VP9BitField value) {
  
  _impl_.segmentation_temporal_update_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_temporal_update(::VP9BitField value) {
  _internal_set_segmentation_temporal_update(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_temporal_update)
}

// repeated .UncompressedHeader.SegmentationParams.ReadProb prob = 4;
inline int UncompressedHeader_SegmentationParams::_internal_prob_size() const {
  return _impl_.prob_.size();
}
inline int UncompressedHeader_SegmentationParams::prob_size() const {
  return _internal_prob_size();
}
inline void UncompressedHeader_SegmentationParams::clear_prob() {
  _impl_.prob_.Clear();
}
inline ::UncompressedHeader_SegmentationParams_ReadProb* UncompressedHeader_SegmentationParams::mutable_prob(int index) {
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.SegmentationParams.prob)
  return _impl_.prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_ReadProb >*
UncompressedHeader_SegmentationParams::mutable_prob() {
  // @@protoc_insertion_point(field_mutable_list:UncompressedHeader.SegmentationParams.prob)
  return &_impl_.prob_;
}
inline const ::UncompressedHeader_SegmentationParams_ReadProb& UncompressedHeader_SegmentationParams::_internal_prob(int index) const {
  return _impl_.prob_.Get(index);
}
inline const ::UncompressedHeader_SegmentationParams_ReadProb& UncompressedHeader_SegmentationParams::prob(int index) const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.prob)
  return _internal_prob(index);
}
inline ::UncompressedHeader_SegmentationParams_ReadProb* UncompressedHeader_SegmentationParams::_internal_add_prob() {
  return _impl_.prob_.Add();
}
inline ::UncompressedHeader_SegmentationParams_ReadProb* UncompressedHeader_SegmentationParams::add_prob() {
  ::UncompressedHeader_SegmentationParams_ReadProb* _add = _internal_add_prob();
  // @@protoc_insertion_point(field_add:UncompressedHeader.SegmentationParams.prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_ReadProb >&
UncompressedHeader_SegmentationParams::prob() const {
  // @@protoc_insertion_point(field_list:UncompressedHeader.SegmentationParams.prob)
  return _impl_.prob_;
}

// .VP9BitField segmentation_update_data = 5;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_update_data() {
  _impl_.segmentation_update_data_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::_internal_segmentation_update_data() const {
  return static_cast< ::VP9BitField >(_impl_.segmentation_update_data_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::segmentation_update_data() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_update_data)
  return _internal_segmentation_update_data();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_update_data(::VP9BitField value) {
  
  _impl_.segmentation_update_data_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_update_data(::VP9BitField value) {
  _internal_set_segmentation_update_data(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_update_data)
}

// .VP9BitField segmentation_abs_or_delta_update = 6;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_abs_or_delta_update() {
  _impl_.segmentation_abs_or_delta_update_ = 0;
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::_internal_segmentation_abs_or_delta_update() const {
  return static_cast< ::VP9BitField >(_impl_.segmentation_abs_or_delta_update_);
}
inline ::VP9BitField UncompressedHeader_SegmentationParams::segmentation_abs_or_delta_update() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_abs_or_delta_update)
  return _internal_segmentation_abs_or_delta_update();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_abs_or_delta_update(::VP9BitField value) {
  
  _impl_.segmentation_abs_or_delta_update_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_abs_or_delta_update(::VP9BitField value) {
  _internal_set_segmentation_abs_or_delta_update(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_abs_or_delta_update)
}

// repeated .UncompressedHeader.SegmentationParams.Feature features = 7;
inline int UncompressedHeader_SegmentationParams::_internal_features_size() const {
  return _impl_.features_.size();
}
inline int UncompressedHeader_SegmentationParams::features_size() const {
  return _internal_features_size();
}
inline void UncompressedHeader_SegmentationParams::clear_features() {
  _impl_.features_.Clear();
}
inline ::UncompressedHeader_SegmentationParams_Feature* UncompressedHeader_SegmentationParams::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.SegmentationParams.features)
  return _impl_.features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_Feature >*
UncompressedHeader_SegmentationParams::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:UncompressedHeader.SegmentationParams.features)
  return &_impl_.features_;
}
inline const ::UncompressedHeader_SegmentationParams_Feature& UncompressedHeader_SegmentationParams::_internal_features(int index) const {
  return _impl_.features_.Get(index);
}
inline const ::UncompressedHeader_SegmentationParams_Feature& UncompressedHeader_SegmentationParams::features(int index) const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.features)
  return _internal_features(index);
}
inline ::UncompressedHeader_SegmentationParams_Feature* UncompressedHeader_SegmentationParams::_internal_add_features() {
  return _impl_.features_.Add();
}
inline ::UncompressedHeader_SegmentationParams_Feature* UncompressedHeader_SegmentationParams::add_features() {
  ::UncompressedHeader_SegmentationParams_Feature* _add = _internal_add_features();
  // @@protoc_insertion_point(field_add:UncompressedHeader.SegmentationParams.features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UncompressedHeader_SegmentationParams_Feature >&
UncompressedHeader_SegmentationParams::features() const {
  // @@protoc_insertion_point(field_list:UncompressedHeader.SegmentationParams.features)
  return _impl_.features_;
}

// -------------------------------------------------------------------

// UncompressedHeader

// .VP9BitField profile_low_bit = 1;
inline void UncompressedHeader::clear_profile_low_bit() {
  _impl_.profile_low_bit_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_profile_low_bit() const {
  return static_cast< ::VP9BitField >(_impl_.profile_low_bit_);
}
inline ::VP9BitField UncompressedHeader::profile_low_bit() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.profile_low_bit)
  return _internal_profile_low_bit();
}
inline void UncompressedHeader::_internal_set_profile_low_bit(::VP9BitField value) {
  
  _impl_.profile_low_bit_ = value;
}
inline void UncompressedHeader::set_profile_low_bit(::VP9BitField value) {
  _internal_set_profile_low_bit(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.profile_low_bit)
}

// .VP9BitField profile_high_bit = 2;
inline void UncompressedHeader::clear_profile_high_bit() {
  _impl_.profile_high_bit_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_profile_high_bit() const {
  return static_cast< ::VP9BitField >(_impl_.profile_high_bit_);
}
inline ::VP9BitField UncompressedHeader::profile_high_bit() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.profile_high_bit)
  return _internal_profile_high_bit();
}
inline void UncompressedHeader::_internal_set_profile_high_bit(::VP9BitField value) {
  
  _impl_.profile_high_bit_ = value;
}
inline void UncompressedHeader::set_profile_high_bit(::VP9BitField value) {
  _internal_set_profile_high_bit(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.profile_high_bit)
}

// uint32 reserved_zero = 3;
inline void UncompressedHeader::clear_reserved_zero() {
  _impl_.reserved_zero_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_reserved_zero() const {
  return _impl_.reserved_zero_;
}
inline uint32_t UncompressedHeader::reserved_zero() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.reserved_zero)
  return _internal_reserved_zero();
}
inline void UncompressedHeader::_internal_set_reserved_zero(uint32_t value) {

  _impl_.reserved_zero_ = value;
}
inline void UncompressedHeader::set_reserved_zero(uint32_t value) {
  _internal_set_reserved_zero(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.reserved_zero)
}

// .VP9BitField show_existing_frame = 4;
inline void UncompressedHeader::clear_show_existing_frame() {
  _impl_.show_existing_frame_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_show_existing_frame() const {
  return static_cast< ::VP9BitField >(_impl_.show_existing_frame_);
}
inline ::VP9BitField UncompressedHeader::show_existing_frame() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.show_existing_frame)
  return _internal_show_existing_frame();
}
inline void UncompressedHeader::_internal_set_show_existing_frame(::VP9BitField value) {
  
  _impl_.show_existing_frame_ = value;
}
inline void UncompressedHeader::set_show_existing_frame(::VP9BitField value) {
  _internal_set_show_existing_frame(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.show_existing_frame)
}

// uint32 frame_to_show_map_idx = 5;
inline void UncompressedHeader::clear_frame_to_show_map_idx() {
  _impl_.frame_to_show_map_idx_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_to_show_map_idx() const {
  return _impl_.frame_to_show_map_idx_;
}
inline uint32_t UncompressedHeader::frame_to_show_map_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_to_show_map_idx)
  return _internal_frame_to_show_map_idx();
}
inline void UncompressedHeader::_internal_set_frame_to_show_map_idx(uint32_t value) {

  _impl_.frame_to_show_map_idx_ = value;
}
inline void UncompressedHeader::set_frame_to_show_map_idx(uint32_t value) {
  _internal_set_frame_to_show_map_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_to_show_map_idx)
}

// .UncompressedHeader.FrameType frame_type = 6;
inline void UncompressedHeader::clear_frame_type() {
  _impl_.frame_type_ = 0;
}
inline ::UncompressedHeader_FrameType UncompressedHeader::_internal_frame_type() const {
  return static_cast< ::UncompressedHeader_FrameType >(_impl_.frame_type_);
}
inline ::UncompressedHeader_FrameType UncompressedHeader::frame_type() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_type)
  return _internal_frame_type();
}
inline void UncompressedHeader::_internal_set_frame_type(::UncompressedHeader_FrameType value) {
  
  _impl_.frame_type_ = value;
}
inline void UncompressedHeader::set_frame_type(::UncompressedHeader_FrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_type)
}

// .VP9BitField show_frame = 7;
inline void UncompressedHeader::clear_show_frame() {
  _impl_.show_frame_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_show_frame() const {
  return static_cast< ::VP9BitField >(_impl_.show_frame_);
}
inline ::VP9BitField UncompressedHeader::show_frame() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.show_frame)
  return _internal_show_frame();
}
inline void UncompressedHeader::_internal_set_show_frame(::VP9BitField value) {
  
  _impl_.show_frame_ = value;
}
inline void UncompressedHeader::set_show_frame(::VP9BitField value) {
  _internal_set_show_frame(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.show_frame)
}

// .VP9BitField error_resilient_mode = 8;
inline void UncompressedHeader::clear_error_resilient_mode() {
  _impl_.error_resilient_mode_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_error_resilient_mode() const {
  return static_cast< ::VP9BitField >(_impl_.error_resilient_mode_);
}
inline ::VP9BitField UncompressedHeader::error_resilient_mode() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.error_resilient_mode)
  return _internal_error_resilient_mode();
}
inline void UncompressedHeader::_internal_set_error_resilient_mode(::VP9BitField value) {
  
  _impl_.error_resilient_mode_ = value;
}
inline void UncompressedHeader::set_error_resilient_mode(::VP9BitField value) {
  _internal_set_error_resilient_mode(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.error_resilient_mode)
}

// uint32 frame_sync_code = 9;
inline void UncompressedHeader::clear_frame_sync_code() {
  _impl_.frame_sync_code_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_sync_code() const {
  return _impl_.frame_sync_code_;
}
inline uint32_t UncompressedHeader::frame_sync_code() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_sync_code)
  return _internal_frame_sync_code();
}
inline void UncompressedHeader::_internal_set_frame_sync_code(uint32_t value) {

  _impl_.frame_sync_code_ = value;
}
inline void UncompressedHeader::set_frame_sync_code(uint32_t value) {
  _internal_set_frame_sync_code(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_sync_code)
}

// .UncompressedHeader.ColorConfig color_config = 10;
inline bool UncompressedHeader::_internal_has_color_config() const {
  return this != internal_default_instance() && _impl_.color_config_ != nullptr;
}
inline bool UncompressedHeader::has_color_config() const {
  return _internal_has_color_config();
}
inline void UncompressedHeader::clear_color_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_config_ != nullptr) {
    delete _impl_.color_config_;
  }
  _impl_.color_config_ = nullptr;
}
inline const ::UncompressedHeader_ColorConfig& UncompressedHeader::_internal_color_config() const {
  const ::UncompressedHeader_ColorConfig* p = _impl_.color_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_ColorConfig&>(
      ::_UncompressedHeader_ColorConfig_default_instance_);
}
inline const ::UncompressedHeader_ColorConfig& UncompressedHeader::color_config() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.color_config)
  return _internal_color_config();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_color_config(
    ::UncompressedHeader_ColorConfig* color_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_config_);
  }
  _impl_.color_config_ = color_config;
  if (color_config) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.color_config)
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::release_color_config() {
  
  ::UncompressedHeader_ColorConfig* temp = _impl_.color_config_;
  _impl_.color_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::unsafe_arena_release_color_config() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.color_config)
  
  ::UncompressedHeader_ColorConfig* temp = _impl_.color_config_;
  _impl_.color_config_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::_internal_mutable_color_config() {
  
  if (_impl_.color_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_ColorConfig>(GetArenaForAllocation());
    _impl_.color_config_ = p;
  }
  return _impl_.color_config_;
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::mutable_color_config() {
  ::UncompressedHeader_ColorConfig* _msg = _internal_mutable_color_config();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.color_config)
  return _msg;
}
inline void UncompressedHeader::set_allocated_color_config(::UncompressedHeader_ColorConfig* color_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_config_;
  }
  if (color_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color_config);
    if (message_arena != submessage_arena) {
      color_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color_config, submessage_arena);
    }

  } else {

  }
  _impl_.color_config_ = color_config;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.color_config)
}

// uint32 frame_size_found_ref = 11;
inline void UncompressedHeader::clear_frame_size_found_ref() {
  _impl_.frame_size_found_ref_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_size_found_ref() const {
  return _impl_.frame_size_found_ref_;
}
inline uint32_t UncompressedHeader::frame_size_found_ref() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_size_found_ref)
  return _internal_frame_size_found_ref();
}
inline void UncompressedHeader::_internal_set_frame_size_found_ref(uint32_t value) {

  _impl_.frame_size_found_ref_ = value;
}
inline void UncompressedHeader::set_frame_size_found_ref(uint32_t value) {
  _internal_set_frame_size_found_ref(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_size_found_ref)
}

// .UncompressedHeader.FrameSize frame_size = 12;
inline bool UncompressedHeader::_internal_has_frame_size() const {
  return this != internal_default_instance() && _impl_.frame_size_ != nullptr;
}
inline bool UncompressedHeader::has_frame_size() const {
  return _internal_has_frame_size();
}
inline void UncompressedHeader::clear_frame_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_size_ != nullptr) {
    delete _impl_.frame_size_;
  }
  _impl_.frame_size_ = nullptr;
}
inline const ::UncompressedHeader_FrameSize& UncompressedHeader::_internal_frame_size() const {
  const ::UncompressedHeader_FrameSize* p = _impl_.frame_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_FrameSize&>(
      ::_UncompressedHeader_FrameSize_default_instance_);
}
inline const ::UncompressedHeader_FrameSize& UncompressedHeader::frame_size() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_size)
  return _internal_frame_size();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_frame_size(
    ::UncompressedHeader_FrameSize* frame_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_size_);
  }
  _impl_.frame_size_ = frame_size;
  if (frame_size) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.frame_size)
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::release_frame_size() {
  
  ::UncompressedHeader_FrameSize* temp = _impl_.frame_size_;
  _impl_.frame_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::unsafe_arena_release_frame_size() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.frame_size)
  
  ::UncompressedHeader_FrameSize* temp = _impl_.frame_size_;
  _impl_.frame_size_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::_internal_mutable_frame_size() {
  
  if (_impl_.frame_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_FrameSize>(GetArenaForAllocation());
    _impl_.frame_size_ = p;
  }
  return _impl_.frame_size_;
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::mutable_frame_size() {
  ::UncompressedHeader_FrameSize* _msg = _internal_mutable_frame_size();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.frame_size)
  return _msg;
}
inline void UncompressedHeader::set_allocated_frame_size(::UncompressedHeader_FrameSize* frame_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_size_;
  }
  if (frame_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_size);
    if (message_arena != submessage_arena) {
      frame_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_size, submessage_arena);
    }

  } else {

  }
  _impl_.frame_size_ = frame_size;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.frame_size)
}

// .UncompressedHeader.RenderSize render_size = 13;
inline bool UncompressedHeader::_internal_has_render_size() const {
  return this != internal_default_instance() && _impl_.render_size_ != nullptr;
}
inline bool UncompressedHeader::has_render_size() const {
  return _internal_has_render_size();
}
inline void UncompressedHeader::clear_render_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.render_size_ != nullptr) {
    delete _impl_.render_size_;
  }
  _impl_.render_size_ = nullptr;
}
inline const ::UncompressedHeader_RenderSize& UncompressedHeader::_internal_render_size() const {
  const ::UncompressedHeader_RenderSize* p = _impl_.render_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_RenderSize&>(
      ::_UncompressedHeader_RenderSize_default_instance_);
}
inline const ::UncompressedHeader_RenderSize& UncompressedHeader::render_size() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.render_size)
  return _internal_render_size();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_render_size(
    ::UncompressedHeader_RenderSize* render_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.render_size_);
  }
  _impl_.render_size_ = render_size;
  if (render_size) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.render_size)
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::release_render_size() {
  
  ::UncompressedHeader_RenderSize* temp = _impl_.render_size_;
  _impl_.render_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::unsafe_arena_release_render_size() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.render_size)
  
  ::UncompressedHeader_RenderSize* temp = _impl_.render_size_;
  _impl_.render_size_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::_internal_mutable_render_size() {
  
  if (_impl_.render_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_RenderSize>(GetArenaForAllocation());
    _impl_.render_size_ = p;
  }
  return _impl_.render_size_;
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::mutable_render_size() {
  ::UncompressedHeader_RenderSize* _msg = _internal_mutable_render_size();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.render_size)
  return _msg;
}
inline void UncompressedHeader::set_allocated_render_size(::UncompressedHeader_RenderSize* render_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.render_size_;
  }
  if (render_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(render_size);
    if (message_arena != submessage_arena) {
      render_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, render_size, submessage_arena);
    }

  } else {

  }
  _impl_.render_size_ = render_size;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.render_size)
}

// .VP9BitField intra_only = 14;
inline void UncompressedHeader::clear_intra_only() {
  _impl_.intra_only_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_intra_only() const {
  return static_cast< ::VP9BitField >(_impl_.intra_only_);
}
inline ::VP9BitField UncompressedHeader::intra_only() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.intra_only)
  return _internal_intra_only();
}
inline void UncompressedHeader::_internal_set_intra_only(::VP9BitField value) {
  
  _impl_.intra_only_ = value;
}
inline void UncompressedHeader::set_intra_only(::VP9BitField value) {
  _internal_set_intra_only(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.intra_only)
}

// uint32 reset_frame_context = 15;
inline void UncompressedHeader::clear_reset_frame_context() {
  _impl_.reset_frame_context_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_reset_frame_context() const {
  return _impl_.reset_frame_context_;
}
inline uint32_t UncompressedHeader::reset_frame_context() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.reset_frame_context)
  return _internal_reset_frame_context();
}
inline void UncompressedHeader::_internal_set_reset_frame_context(uint32_t value) {

  _impl_.reset_frame_context_ = value;
}
inline void UncompressedHeader::set_reset_frame_context(uint32_t value) {
  _internal_set_reset_frame_context(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.reset_frame_context)
}

// uint32 refresh_frame_flags = 16;
inline void UncompressedHeader::clear_refresh_frame_flags() {
  _impl_.refresh_frame_flags_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_refresh_frame_flags() const {
  return _impl_.refresh_frame_flags_;
}
inline uint32_t UncompressedHeader::refresh_frame_flags() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.refresh_frame_flags)
  return _internal_refresh_frame_flags();
}
inline void UncompressedHeader::_internal_set_refresh_frame_flags(uint32_t value) {

  _impl_.refresh_frame_flags_ = value;
}
inline void UncompressedHeader::set_refresh_frame_flags(uint32_t value) {
  _internal_set_refresh_frame_flags(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.refresh_frame_flags)
}

// repeated uint32 ref_frame_idx = 17;
inline int UncompressedHeader::_internal_ref_frame_idx_size() const {
  return _impl_.ref_frame_idx_.size();
}
inline int UncompressedHeader::ref_frame_idx_size() const {
  return _internal_ref_frame_idx_size();
}
inline void UncompressedHeader::clear_ref_frame_idx() {
  _impl_.ref_frame_idx_.Clear();
}
inline uint32_t UncompressedHeader::_internal_ref_frame_idx(int index) const {
  return _impl_.ref_frame_idx_.Get(index);
}
inline uint32_t UncompressedHeader::ref_frame_idx(int index) const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ref_frame_idx)
  return _internal_ref_frame_idx(index);
}
inline void UncompressedHeader::set_ref_frame_idx(int index, uint32_t value) {
  _impl_.ref_frame_idx_.Set(index, value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ref_frame_idx)
}
inline void UncompressedHeader::_internal_add_ref_frame_idx(uint32_t value) {
  _impl_.ref_frame_idx_.Add(value);
}
inline void UncompressedHeader::add_ref_frame_idx(uint32_t value) {
  _internal_add_ref_frame_idx(value);
  // @@protoc_insertion_point(field_add:UncompressedHeader.ref_frame_idx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UncompressedHeader::_internal_ref_frame_idx() const {
  return _impl_.ref_frame_idx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
UncompressedHeader::ref_frame_idx() const {
  // @@protoc_insertion_point(field_list:UncompressedHeader.ref_frame_idx)
  return _internal_ref_frame_idx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UncompressedHeader::_internal_mutable_ref_frame_idx() {
  return &_impl_.ref_frame_idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
UncompressedHeader::mutable_ref_frame_idx() {
  // @@protoc_insertion_point(field_mutable_list:UncompressedHeader.ref_frame_idx)
  return _internal_mutable_ref_frame_idx();
}

// repeated .VP9BitField ref_frame_sign_bias = 18;
inline int UncompressedHeader::_internal_ref_frame_sign_bias_size() const {
  return _impl_.ref_frame_sign_bias_.size();
}
inline int UncompressedHeader::ref_frame_sign_bias_size() const {
  return _internal_ref_frame_sign_bias_size();
}
inline void UncompressedHeader::clear_ref_frame_sign_bias() {
  _impl_.ref_frame_sign_bias_.Clear();
}
inline ::VP9BitField UncompressedHeader::_internal_ref_frame_sign_bias(int index) const {
  return static_cast< ::VP9BitField >(_impl_.ref_frame_sign_bias_.Get(index));
}
inline ::VP9BitField UncompressedHeader::ref_frame_sign_bias(int index) const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ref_frame_sign_bias)
  return _internal_ref_frame_sign_bias(index);
}
inline void UncompressedHeader::set_ref_frame_sign_bias(int index, ::VP9BitField value) {
  _impl_.ref_frame_sign_bias_.Set(index, value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ref_frame_sign_bias)
}
inline void UncompressedHeader::_internal_add_ref_frame_sign_bias(::VP9BitField value) {
  _impl_.ref_frame_sign_bias_.Add(value);
}
inline void UncompressedHeader::add_ref_frame_sign_bias(::VP9BitField value) {
  _internal_add_ref_frame_sign_bias(value);
  // @@protoc_insertion_point(field_add:UncompressedHeader.ref_frame_sign_bias)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UncompressedHeader::ref_frame_sign_bias() const {
  // @@protoc_insertion_point(field_list:UncompressedHeader.ref_frame_sign_bias)
  return _impl_.ref_frame_sign_bias_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UncompressedHeader::_internal_mutable_ref_frame_sign_bias() {
  return &_impl_.ref_frame_sign_bias_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UncompressedHeader::mutable_ref_frame_sign_bias() {
  // @@protoc_insertion_point(field_mutable_list:UncompressedHeader.ref_frame_sign_bias)
  return _internal_mutable_ref_frame_sign_bias();
}

// .VP9BitField allow_high_precision_mv = 19;
inline void UncompressedHeader::clear_allow_high_precision_mv() {
  _impl_.allow_high_precision_mv_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_allow_high_precision_mv() const {
  return static_cast< ::VP9BitField >(_impl_.allow_high_precision_mv_);
}
inline ::VP9BitField UncompressedHeader::allow_high_precision_mv() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.allow_high_precision_mv)
  return _internal_allow_high_precision_mv();
}
inline void UncompressedHeader::_internal_set_allow_high_precision_mv(::VP9BitField value) {
  
  _impl_.allow_high_precision_mv_ = value;
}
inline void UncompressedHeader::set_allow_high_precision_mv(::VP9BitField value) {
  _internal_set_allow_high_precision_mv(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.allow_high_precision_mv)
}

// .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
inline bool UncompressedHeader::_internal_has_read_interpolation_filter() const {
  return this != internal_default_instance() && _impl_.read_interpolation_filter_ != nullptr;
}
inline bool UncompressedHeader::has_read_interpolation_filter() const {
  return _internal_has_read_interpolation_filter();
}
inline void UncompressedHeader::clear_read_interpolation_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_interpolation_filter_ != nullptr) {
    delete _impl_.read_interpolation_filter_;
  }
  _impl_.read_interpolation_filter_ = nullptr;
}
inline const ::UncompressedHeader_ReadInterpolationFilter& UncompressedHeader::_internal_read_interpolation_filter() const {
  const ::UncompressedHeader_ReadInterpolationFilter* p = _impl_.read_interpolation_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_ReadInterpolationFilter&>(
      ::_UncompressedHeader_ReadInterpolationFilter_default_instance_);
}
inline const ::UncompressedHeader_ReadInterpolationFilter& UncompressedHeader::read_interpolation_filter() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.read_interpolation_filter)
  return _internal_read_interpolation_filter();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_read_interpolation_filter(
    ::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_interpolation_filter_);
  }
  _impl_.read_interpolation_filter_ = read_interpolation_filter;
  if (read_interpolation_filter) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.read_interpolation_filter)
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::release_read_interpolation_filter() {
  
  ::UncompressedHeader_ReadInterpolationFilter* temp = _impl_.read_interpolation_filter_;
  _impl_.read_interpolation_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::unsafe_arena_release_read_interpolation_filter() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.read_interpolation_filter)
  
  ::UncompressedHeader_ReadInterpolationFilter* temp = _impl_.read_interpolation_filter_;
  _impl_.read_interpolation_filter_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::_internal_mutable_read_interpolation_filter() {
  
  if (_impl_.read_interpolation_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_ReadInterpolationFilter>(GetArenaForAllocation());
    _impl_.read_interpolation_filter_ = p;
  }
  return _impl_.read_interpolation_filter_;
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::mutable_read_interpolation_filter() {
  ::UncompressedHeader_ReadInterpolationFilter* _msg = _internal_mutable_read_interpolation_filter();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.read_interpolation_filter)
  return _msg;
}
inline void UncompressedHeader::set_allocated_read_interpolation_filter(::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_interpolation_filter_;
  }
  if (read_interpolation_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_interpolation_filter);
    if (message_arena != submessage_arena) {
      read_interpolation_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_interpolation_filter, submessage_arena);
    }

  } else {

  }
  _impl_.read_interpolation_filter_ = read_interpolation_filter;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.read_interpolation_filter)
}

// .VP9BitField refresh_frame_context = 21;
inline void UncompressedHeader::clear_refresh_frame_context() {
  _impl_.refresh_frame_context_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_refresh_frame_context() const {
  return static_cast< ::VP9BitField >(_impl_.refresh_frame_context_);
}
inline ::VP9BitField UncompressedHeader::refresh_frame_context() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.refresh_frame_context)
  return _internal_refresh_frame_context();
}
inline void UncompressedHeader::_internal_set_refresh_frame_context(::VP9BitField value) {
  
  _impl_.refresh_frame_context_ = value;
}
inline void UncompressedHeader::set_refresh_frame_context(::VP9BitField value) {
  _internal_set_refresh_frame_context(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.refresh_frame_context)
}

// .VP9BitField frame_parallel_decoding_mode = 22;
inline void UncompressedHeader::clear_frame_parallel_decoding_mode() {
  _impl_.frame_parallel_decoding_mode_ = 0;
}
inline ::VP9BitField UncompressedHeader::_internal_frame_parallel_decoding_mode() const {
  return static_cast< ::VP9BitField >(_impl_.frame_parallel_decoding_mode_);
}
inline ::VP9BitField UncompressedHeader::frame_parallel_decoding_mode() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_parallel_decoding_mode)
  return _internal_frame_parallel_decoding_mode();
}
inline void UncompressedHeader::_internal_set_frame_parallel_decoding_mode(::VP9BitField value) {
  
  _impl_.frame_parallel_decoding_mode_ = value;
}
inline void UncompressedHeader::set_frame_parallel_decoding_mode(::VP9BitField value) {
  _internal_set_frame_parallel_decoding_mode(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_parallel_decoding_mode)
}

// uint32 frame_context_idx = 23;
inline void UncompressedHeader::clear_frame_context_idx() {
  _impl_.frame_context_idx_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_context_idx() const {
  return _impl_.frame_context_idx_;
}
inline uint32_t UncompressedHeader::frame_context_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_context_idx)
  return _internal_frame_context_idx();
}
inline void UncompressedHeader::_internal_set_frame_context_idx(uint32_t value) {

  _impl_.frame_context_idx_ = value;
}
inline void UncompressedHeader::set_frame_context_idx(uint32_t value) {
  _internal_set_frame_context_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_context_idx)
}

// .UncompressedHeader.LoopFilterParams loop_filter_params = 24;
inline bool UncompressedHeader::_internal_has_loop_filter_params() const {
  return this != internal_default_instance() && _impl_.loop_filter_params_ != nullptr;
}
inline bool UncompressedHeader::has_loop_filter_params() const {
  return _internal_has_loop_filter_params();
}
inline void UncompressedHeader::clear_loop_filter_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_params_ != nullptr) {
    delete _impl_.loop_filter_params_;
  }
  _impl_.loop_filter_params_ = nullptr;
}
inline const ::UncompressedHeader_LoopFilterParams& UncompressedHeader::_internal_loop_filter_params() const {
  const ::UncompressedHeader_LoopFilterParams* p = _impl_.loop_filter_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_LoopFilterParams&>(
      ::_UncompressedHeader_LoopFilterParams_default_instance_);
}
inline const ::UncompressedHeader_LoopFilterParams& UncompressedHeader::loop_filter_params() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.loop_filter_params)
  return _internal_loop_filter_params();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_loop_filter_params(
    ::UncompressedHeader_LoopFilterParams* loop_filter_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_filter_params_);
  }
  _impl_.loop_filter_params_ = loop_filter_params;
  if (loop_filter_params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.loop_filter_params)
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::release_loop_filter_params() {
  
  ::UncompressedHeader_LoopFilterParams* temp = _impl_.loop_filter_params_;
  _impl_.loop_filter_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::unsafe_arena_release_loop_filter_params() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.loop_filter_params)
  
  ::UncompressedHeader_LoopFilterParams* temp = _impl_.loop_filter_params_;
  _impl_.loop_filter_params_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::_internal_mutable_loop_filter_params() {
  
  if (_impl_.loop_filter_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_LoopFilterParams>(GetArenaForAllocation());
    _impl_.loop_filter_params_ = p;
  }
  return _impl_.loop_filter_params_;
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::mutable_loop_filter_params() {
  ::UncompressedHeader_LoopFilterParams* _msg = _internal_mutable_loop_filter_params();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.loop_filter_params)
  return _msg;
}
inline void UncompressedHeader::set_allocated_loop_filter_params(::UncompressedHeader_LoopFilterParams* loop_filter_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_filter_params_;
  }
  if (loop_filter_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_filter_params);
    if (message_arena != submessage_arena) {
      loop_filter_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_filter_params, submessage_arena);
    }

  } else {

  }
  _impl_.loop_filter_params_ = loop_filter_params;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.loop_filter_params)
}

// .UncompressedHeader.QuantizationParams quantization_params = 25;
inline bool UncompressedHeader::_internal_has_quantization_params() const {
  return this != internal_default_instance() && _impl_.quantization_params_ != nullptr;
}
inline bool UncompressedHeader::has_quantization_params() const {
  return _internal_has_quantization_params();
}
inline void UncompressedHeader::clear_quantization_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.quantization_params_ != nullptr) {
    delete _impl_.quantization_params_;
  }
  _impl_.quantization_params_ = nullptr;
}
inline const ::UncompressedHeader_QuantizationParams& UncompressedHeader::_internal_quantization_params() const {
  const ::UncompressedHeader_QuantizationParams* p = _impl_.quantization_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_QuantizationParams&>(
      ::_UncompressedHeader_QuantizationParams_default_instance_);
}
inline const ::UncompressedHeader_QuantizationParams& UncompressedHeader::quantization_params() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.quantization_params)
  return _internal_quantization_params();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_quantization_params(
    ::UncompressedHeader_QuantizationParams* quantization_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quantization_params_);
  }
  _impl_.quantization_params_ = quantization_params;
  if (quantization_params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.quantization_params)
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::release_quantization_params() {
  
  ::UncompressedHeader_QuantizationParams* temp = _impl_.quantization_params_;
  _impl_.quantization_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::unsafe_arena_release_quantization_params() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.quantization_params)
  
  ::UncompressedHeader_QuantizationParams* temp = _impl_.quantization_params_;
  _impl_.quantization_params_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::_internal_mutable_quantization_params() {
  
  if (_impl_.quantization_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_QuantizationParams>(GetArenaForAllocation());
    _impl_.quantization_params_ = p;
  }
  return _impl_.quantization_params_;
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::mutable_quantization_params() {
  ::UncompressedHeader_QuantizationParams* _msg = _internal_mutable_quantization_params();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.quantization_params)
  return _msg;
}
inline void UncompressedHeader::set_allocated_quantization_params(::UncompressedHeader_QuantizationParams* quantization_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quantization_params_;
  }
  if (quantization_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quantization_params);
    if (message_arena != submessage_arena) {
      quantization_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quantization_params, submessage_arena);
    }

  } else {

  }
  _impl_.quantization_params_ = quantization_params;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.quantization_params)
}

// .UncompressedHeader.SegmentationParams segmentation_params = 26;
inline bool UncompressedHeader::_internal_has_segmentation_params() const {
  return this != internal_default_instance() && _impl_.segmentation_params_ != nullptr;
}
inline bool UncompressedHeader::has_segmentation_params() const {
  return _internal_has_segmentation_params();
}
inline void UncompressedHeader::clear_segmentation_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.segmentation_params_ != nullptr) {
    delete _impl_.segmentation_params_;
  }
  _impl_.segmentation_params_ = nullptr;
}
inline const ::UncompressedHeader_SegmentationParams& UncompressedHeader::_internal_segmentation_params() const {
  const ::UncompressedHeader_SegmentationParams* p = _impl_.segmentation_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_SegmentationParams&>(
      ::_UncompressedHeader_SegmentationParams_default_instance_);
}
inline const ::UncompressedHeader_SegmentationParams& UncompressedHeader::segmentation_params() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.segmentation_params)
  return _internal_segmentation_params();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_segmentation_params(
    ::UncompressedHeader_SegmentationParams* segmentation_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segmentation_params_);
  }
  _impl_.segmentation_params_ = segmentation_params;
  if (segmentation_params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.segmentation_params)
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::release_segmentation_params() {
  
  ::UncompressedHeader_SegmentationParams* temp = _impl_.segmentation_params_;
  _impl_.segmentation_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::unsafe_arena_release_segmentation_params() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.segmentation_params)
  
  ::UncompressedHeader_SegmentationParams* temp = _impl_.segmentation_params_;
  _impl_.segmentation_params_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::_internal_mutable_segmentation_params() {
  
  if (_impl_.segmentation_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_SegmentationParams>(GetArenaForAllocation());
    _impl_.segmentation_params_ = p;
  }
  return _impl_.segmentation_params_;
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::mutable_segmentation_params() {
  ::UncompressedHeader_SegmentationParams* _msg = _internal_mutable_segmentation_params();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.segmentation_params)
  return _msg;
}
inline void UncompressedHeader::set_allocated_segmentation_params(::UncompressedHeader_SegmentationParams* segmentation_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.segmentation_params_;
  }
  if (segmentation_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(segmentation_params);
    if (message_arena != submessage_arena) {
      segmentation_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segmentation_params, submessage_arena);
    }

  } else {

  }
  _impl_.segmentation_params_ = segmentation_params;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.segmentation_params)
}

// .UncompressedHeader.TileInfo tile_info = 27;
inline bool UncompressedHeader::_internal_has_tile_info() const {
  return this != internal_default_instance() && _impl_.tile_info_ != nullptr;
}
inline bool UncompressedHeader::has_tile_info() const {
  return _internal_has_tile_info();
}
inline void UncompressedHeader::clear_tile_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.tile_info_ != nullptr) {
    delete _impl_.tile_info_;
  }
  _impl_.tile_info_ = nullptr;
}
inline const ::UncompressedHeader_TileInfo& UncompressedHeader::_internal_tile_info() const {
  const ::UncompressedHeader_TileInfo* p = _impl_.tile_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_TileInfo&>(
      ::_UncompressedHeader_TileInfo_default_instance_);
}
inline const ::UncompressedHeader_TileInfo& UncompressedHeader::tile_info() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.tile_info)
  return _internal_tile_info();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_tile_info(
    ::UncompressedHeader_TileInfo* tile_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tile_info_);
  }
  _impl_.tile_info_ = tile_info;
  if (tile_info) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.tile_info)
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::release_tile_info() {
  
  ::UncompressedHeader_TileInfo* temp = _impl_.tile_info_;
  _impl_.tile_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::unsafe_arena_release_tile_info() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.tile_info)
  
  ::UncompressedHeader_TileInfo* temp = _impl_.tile_info_;
  _impl_.tile_info_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::_internal_mutable_tile_info() {
  
  if (_impl_.tile_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_TileInfo>(GetArenaForAllocation());
    _impl_.tile_info_ = p;
  }
  return _impl_.tile_info_;
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::mutable_tile_info() {
  ::UncompressedHeader_TileInfo* _msg = _internal_mutable_tile_info();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.tile_info)
  return _msg;
}
inline void UncompressedHeader::set_allocated_tile_info(::UncompressedHeader_TileInfo* tile_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tile_info_;
  }
  if (tile_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tile_info);
    if (message_arena != submessage_arena) {
      tile_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tile_info, submessage_arena);
    }

  } else {

  }
  _impl_.tile_info_ = tile_info;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.tile_info)
}

// uint32 header_size_in_bytes = 28;
inline void UncompressedHeader::clear_header_size_in_bytes() {
  _impl_.header_size_in_bytes_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_header_size_in_bytes() const {
  return _impl_.header_size_in_bytes_;
}
inline uint32_t UncompressedHeader::header_size_in_bytes() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.header_size_in_bytes)
  return _internal_header_size_in_bytes();
}
inline void UncompressedHeader::_internal_set_header_size_in_bytes(uint32_t value) {

  _impl_.header_size_in_bytes_ = value;
}
inline void UncompressedHeader::set_header_size_in_bytes(uint32_t value) {
  _internal_set_header_size_in_bytes(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.header_size_in_bytes)
}

// -------------------------------------------------------------------

// CompressedHeader_ReadTxMode

// .CompressedHeader.TxMode tx_mode = 1;
inline void CompressedHeader_ReadTxMode::clear_tx_mode() {
  _impl_.tx_mode_ = 0;
}
inline ::CompressedHeader_TxMode CompressedHeader_ReadTxMode::_internal_tx_mode() const {
  return static_cast< ::CompressedHeader_TxMode >(_impl_.tx_mode_);
}
inline ::CompressedHeader_TxMode CompressedHeader_ReadTxMode::tx_mode() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadTxMode.tx_mode)
  return _internal_tx_mode();
}
inline void CompressedHeader_ReadTxMode::_internal_set_tx_mode(::CompressedHeader_TxMode value) {
  
  _impl_.tx_mode_ = value;
}
inline void CompressedHeader_ReadTxMode::set_tx_mode(::CompressedHeader_TxMode value) {
  _internal_set_tx_mode(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.ReadTxMode.tx_mode)
}

// .VP9BitField tx_mode_select = 2;
inline void CompressedHeader_ReadTxMode::clear_tx_mode_select() {
  _impl_.tx_mode_select_ = 0;
}
inline ::VP9BitField CompressedHeader_ReadTxMode::_internal_tx_mode_select() const {
  return static_cast< ::VP9BitField >(_impl_.tx_mode_select_);
}
inline ::VP9BitField CompressedHeader_ReadTxMode::tx_mode_select() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadTxMode.tx_mode_select)
  return _internal_tx_mode_select();
}
inline void CompressedHeader_ReadTxMode::_internal_set_tx_mode_select(::VP9BitField value) {
  
  _impl_.tx_mode_select_ = value;
}
inline void CompressedHeader_ReadTxMode::set_tx_mode_select(::VP9BitField value) {
  _internal_set_tx_mode_select(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.ReadTxMode.tx_mode_select)
}

// -------------------------------------------------------------------

// CompressedHeader_DecodeTermSubexp

// .VP9BitField bit_1 = 1;
inline void CompressedHeader_DecodeTermSubexp::clear_bit_1() {
  _impl_.bit_1_ = 0;
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::_internal_bit_1() const {
  return static_cast< ::VP9BitField >(_impl_.bit_1_);
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::bit_1() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.bit_1)
  return _internal_bit_1();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_bit_1(::VP9BitField value) {
  
  _impl_.bit_1_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_bit_1(::VP9BitField value) {
  _internal_set_bit_1(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.bit_1)
}

// uint32 sub_exp_val = 2;
inline void CompressedHeader_DecodeTermSubexp::clear_sub_exp_val() {
  _impl_.sub_exp_val_ = 0u;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::_internal_sub_exp_val() const {
  return _impl_.sub_exp_val_;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::sub_exp_val() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.sub_exp_val)
  return _internal_sub_exp_val();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_sub_exp_val(uint32_t value) {

  _impl_.sub_exp_val_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_sub_exp_val(uint32_t value) {
  _internal_set_sub_exp_val(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.sub_exp_val)
}

// .VP9BitField bit_2 = 3;
inline void CompressedHeader_DecodeTermSubexp::clear_bit_2() {
  _impl_.bit_2_ = 0;
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::_internal_bit_2() const {
  return static_cast< ::VP9BitField >(_impl_.bit_2_);
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::bit_2() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.bit_2)
  return _internal_bit_2();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_bit_2(::VP9BitField value) {
  
  _impl_.bit_2_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_bit_2(::VP9BitField value) {
  _internal_set_bit_2(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.bit_2)
}

// uint32 sub_exp_Val_minus_16 = 4;
inline void CompressedHeader_DecodeTermSubexp::clear_sub_exp_val_minus_16() {
  _impl_.sub_exp_val_minus_16_ = 0u;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::_internal_sub_exp_val_minus_16() const {
  return _impl_.sub_exp_val_minus_16_;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::sub_exp_val_minus_16() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.sub_exp_Val_minus_16)
  return _internal_sub_exp_val_minus_16();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_sub_exp_val_minus_16(uint32_t value) {

  _impl_.sub_exp_val_minus_16_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_sub_exp_val_minus_16(uint32_t value) {
  _internal_set_sub_exp_val_minus_16(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.sub_exp_Val_minus_16)
}

// .VP9BitField bit_3 = 5;
inline void CompressedHeader_DecodeTermSubexp::clear_bit_3() {
  _impl_.bit_3_ = 0;
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::_internal_bit_3() const {
  return static_cast< ::VP9BitField >(_impl_.bit_3_);
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::bit_3() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.bit_3)
  return _internal_bit_3();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_bit_3(::VP9BitField value) {
  
  _impl_.bit_3_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_bit_3(::VP9BitField value) {
  _internal_set_bit_3(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.bit_3)
}

// uint32 sub_exp_val_minus_32 = 6;
inline void CompressedHeader_DecodeTermSubexp::clear_sub_exp_val_minus_32() {
  _impl_.sub_exp_val_minus_32_ = 0u;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::_internal_sub_exp_val_minus_32() const {
  return _impl_.sub_exp_val_minus_32_;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::sub_exp_val_minus_32() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.sub_exp_val_minus_32)
  return _internal_sub_exp_val_minus_32();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_sub_exp_val_minus_32(uint32_t value) {

  _impl_.sub_exp_val_minus_32_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_sub_exp_val_minus_32(uint32_t value) {
  _internal_set_sub_exp_val_minus_32(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.sub_exp_val_minus_32)
}

// uint32 v = 7;
inline void CompressedHeader_DecodeTermSubexp::clear_v() {
  _impl_.v_ = 0u;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::_internal_v() const {
  return _impl_.v_;
}
inline uint32_t CompressedHeader_DecodeTermSubexp::v() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.v)
  return _internal_v();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_v(uint32_t value) {

  _impl_.v_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_v(uint32_t value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.v)
}

// .VP9BitField bit_4 = 8;
inline void CompressedHeader_DecodeTermSubexp::clear_bit_4() {
  _impl_.bit_4_ = 0;
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::_internal_bit_4() const {
  return static_cast< ::VP9BitField >(_impl_.bit_4_);
}
inline ::VP9BitField CompressedHeader_DecodeTermSubexp::bit_4() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DecodeTermSubexp.bit_4)
  return _internal_bit_4();
}
inline void CompressedHeader_DecodeTermSubexp::_internal_set_bit_4(::VP9BitField value) {
  
  _impl_.bit_4_ = value;
}
inline void CompressedHeader_DecodeTermSubexp::set_bit_4(::VP9BitField value) {
  _internal_set_bit_4(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DecodeTermSubexp.bit_4)
}

// -------------------------------------------------------------------

// CompressedHeader_DiffUpdateProb

// .VP9BitField update_prob = 1;
inline void CompressedHeader_DiffUpdateProb::clear_update_prob() {
  _impl_.update_prob_ = 0;
}
inline ::VP9BitField CompressedHeader_DiffUpdateProb::_internal_update_prob() const {
  return static_cast< ::VP9BitField >(_impl_.update_prob_);
}
inline ::VP9BitField CompressedHeader_DiffUpdateProb::update_prob() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DiffUpdateProb.update_prob)
  return _internal_update_prob();
}
inline void CompressedHeader_DiffUpdateProb::_internal_set_update_prob(::VP9BitField value) {
  
  _impl_.update_prob_ = value;
}
inline void CompressedHeader_DiffUpdateProb::set_update_prob(::VP9BitField value) {
  _internal_set_update_prob(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.DiffUpdateProb.update_prob)
}

// .CompressedHeader.DecodeTermSubexp decode_term_subexp = 2;
inline bool CompressedHeader_DiffUpdateProb::_internal_has_decode_term_subexp() const {
  return this != internal_default_instance() && _impl_.decode_term_subexp_ != nullptr;
}
inline bool CompressedHeader_DiffUpdateProb::has_decode_term_subexp() const {
  return _internal_has_decode_term_subexp();
}
inline void CompressedHeader_DiffUpdateProb::clear_decode_term_subexp() {
  if (GetArenaForAllocation() == nullptr && _impl_.decode_term_subexp_ != nullptr) {
    delete _impl_.decode_term_subexp_;
  }
  _impl_.decode_term_subexp_ = nullptr;
}
inline const ::CompressedHeader_DecodeTermSubexp& CompressedHeader_DiffUpdateProb::_internal_decode_term_subexp() const {
  const ::CompressedHeader_DecodeTermSubexp* p = _impl_.decode_term_subexp_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_DecodeTermSubexp&>(
      ::_CompressedHeader_DecodeTermSubexp_default_instance_);
}
inline const ::CompressedHeader_DecodeTermSubexp& CompressedHeader_DiffUpdateProb::decode_term_subexp() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.DiffUpdateProb.decode_term_subexp)
  return _internal_decode_term_subexp();
}
inline void CompressedHeader_DiffUpdateProb::unsafe_arena_set_allocated_decode_term_subexp(
    ::CompressedHeader_DecodeTermSubexp* decode_term_subexp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.decode_term_subexp_);
  }
  _impl_.decode_term_subexp_ = decode_term_subexp;
  if (decode_term_subexp) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.DiffUpdateProb.decode_term_subexp)
}
inline ::CompressedHeader_DecodeTermSubexp* CompressedHeader_DiffUpdateProb::release_decode_term_subexp() {
  
  ::CompressedHeader_DecodeTermSubexp* temp = _impl_.decode_term_subexp_;
  _impl_.decode_term_subexp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_DecodeTermSubexp* CompressedHeader_DiffUpdateProb::unsafe_arena_release_decode_term_subexp() {
  // @@protoc_insertion_point(field_release:CompressedHeader.DiffUpdateProb.decode_term_subexp)
  
  ::CompressedHeader_DecodeTermSubexp* temp = _impl_.decode_term_subexp_;
  _impl_.decode_term_subexp_ = nullptr;
  return temp;
}
inline ::CompressedHeader_DecodeTermSubexp* CompressedHeader_DiffUpdateProb::_internal_mutable_decode_term_subexp() {
  
  if (_impl_.decode_term_subexp_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_DecodeTermSubexp>(GetArenaForAllocation());
    _impl_.decode_term_subexp_ = p;
  }
  return _impl_.decode_term_subexp_;
}
inline ::CompressedHeader_DecodeTermSubexp* CompressedHeader_DiffUpdateProb::mutable_decode_term_subexp() {
  ::CompressedHeader_DecodeTermSubexp* _msg = _internal_mutable_decode_term_subexp();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.DiffUpdateProb.decode_term_subexp)
  return _msg;
}
inline void CompressedHeader_DiffUpdateProb::set_allocated_decode_term_subexp(::CompressedHeader_DecodeTermSubexp* decode_term_subexp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.decode_term_subexp_;
  }
  if (decode_term_subexp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(decode_term_subexp);
    if (message_arena != submessage_arena) {
      decode_term_subexp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decode_term_subexp, submessage_arena);
    }

  } else {

  }
  _impl_.decode_term_subexp_ = decode_term_subexp;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.DiffUpdateProb.decode_term_subexp)
}

// -------------------------------------------------------------------

// CompressedHeader_TxModeProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_TxModeProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_TxModeProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_TxModeProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_TxModeProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.TxModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_TxModeProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.TxModeProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_TxModeProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_TxModeProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.TxModeProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_TxModeProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_TxModeProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.TxModeProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_TxModeProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.TxModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop

// .VP9BitField update_probs = 1;
inline void CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::clear_update_probs() {
  _impl_.update_probs_ = 0;
}
inline ::VP9BitField CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::_internal_update_probs() const {
  return static_cast< ::VP9BitField >(_impl_.update_probs_);
}
inline ::VP9BitField CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::update_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.update_probs)
  return _internal_update_probs();
}
inline void CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::_internal_set_update_probs(::VP9BitField value) {
  
  _impl_.update_probs_ = value;
}
inline void CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::set_update_probs(::VP9BitField value) {
  _internal_set_update_probs(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.update_probs)
}

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 2;
inline int CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadCoefProbs

// repeated .CompressedHeader.ReadCoefProbs.ReadCoefProbsLoop read_coef_probs = 1;
inline int CompressedHeader_ReadCoefProbs::_internal_read_coef_probs_size() const {
  return _impl_.read_coef_probs_.size();
}
inline int CompressedHeader_ReadCoefProbs::read_coef_probs_size() const {
  return _internal_read_coef_probs_size();
}
inline void CompressedHeader_ReadCoefProbs::clear_read_coef_probs() {
  _impl_.read_coef_probs_.Clear();
}
inline ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* CompressedHeader_ReadCoefProbs::mutable_read_coef_probs(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadCoefProbs.read_coef_probs)
  return _impl_.read_coef_probs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop >*
CompressedHeader_ReadCoefProbs::mutable_read_coef_probs() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadCoefProbs.read_coef_probs)
  return &_impl_.read_coef_probs_;
}
inline const ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& CompressedHeader_ReadCoefProbs::_internal_read_coef_probs(int index) const {
  return _impl_.read_coef_probs_.Get(index);
}
inline const ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop& CompressedHeader_ReadCoefProbs::read_coef_probs(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadCoefProbs.read_coef_probs)
  return _internal_read_coef_probs(index);
}
inline ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* CompressedHeader_ReadCoefProbs::_internal_add_read_coef_probs() {
  return _impl_.read_coef_probs_.Add();
}
inline ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* CompressedHeader_ReadCoefProbs::add_read_coef_probs() {
  ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop* _add = _internal_add_read_coef_probs();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadCoefProbs.read_coef_probs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_ReadCoefProbs_ReadCoefProbsLoop >&
CompressedHeader_ReadCoefProbs::read_coef_probs() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadCoefProbs.read_coef_probs)
  return _impl_.read_coef_probs_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadSkipProb

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_ReadSkipProb::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadSkipProb::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadSkipProb::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadSkipProb::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadSkipProb.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadSkipProb::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadSkipProb.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadSkipProb::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadSkipProb::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadSkipProb.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadSkipProb::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadSkipProb::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadSkipProb.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadSkipProb::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadSkipProb.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadInterModeProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_ReadInterModeProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadInterModeProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadInterModeProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadInterModeProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadInterModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadInterModeProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadInterModeProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadInterModeProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadInterModeProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadInterModeProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadInterModeProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadInterModeProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadInterModeProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadInterModeProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadInterModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadInterpFilterProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_ReadInterpFilterProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadInterpFilterProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadInterpFilterProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadInterpFilterProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadInterpFilterProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadInterpFilterProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadInterpFilterProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadInterpFilterProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadInterpFilterProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadInterpFilterProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadInterpFilterProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadInterpFilterProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadInterpFilterProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadInterpFilterProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadInterpFilterProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadIsInterProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_ReadIsInterProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadIsInterProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadIsInterProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadIsInterProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadIsInterProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadIsInterProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadIsInterProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadIsInterProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadIsInterProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadIsInterProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadIsInterProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadIsInterProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadIsInterProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadIsInterProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadIsInterProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_FrameReferenceMode

// .VP9BitField non_single_reference = 1;
inline void CompressedHeader_FrameReferenceMode::clear_non_single_reference() {
  _impl_.non_single_reference_ = 0;
}
inline ::VP9BitField CompressedHeader_FrameReferenceMode::_internal_non_single_reference() const {
  return static_cast< ::VP9BitField >(_impl_.non_single_reference_);
}
inline ::VP9BitField CompressedHeader_FrameReferenceMode::non_single_reference() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.FrameReferenceMode.non_single_reference)
  return _internal_non_single_reference();
}
inline void CompressedHeader_FrameReferenceMode::_internal_set_non_single_reference(::VP9BitField value) {
  
  _impl_.non_single_reference_ = value;
}
inline void CompressedHeader_FrameReferenceMode::set_non_single_reference(::VP9BitField value) {
  _internal_set_non_single_reference(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.FrameReferenceMode.non_single_reference)
}

// .VP9BitField reference_select = 2;
inline void CompressedHeader_FrameReferenceMode::clear_reference_select() {
  _impl_.reference_select_ = 0;
}
inline ::VP9BitField CompressedHeader_FrameReferenceMode::_internal_reference_select() const {
  return static_cast< ::VP9BitField >(_impl_.reference_select_);
}
inline ::VP9BitField CompressedHeader_FrameReferenceMode::reference_select() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.FrameReferenceMode.reference_select)
  return _internal_reference_select();
}
inline void CompressedHeader_FrameReferenceMode::_internal_set_reference_select(::VP9BitField value) {
  
  _impl_.reference_select_ = value;
}
inline void CompressedHeader_FrameReferenceMode::set_reference_select(::VP9BitField value) {
  _internal_set_reference_select(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.FrameReferenceMode.reference_select)
}

// -------------------------------------------------------------------

// CompressedHeader_FrameReferenceModeProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_FrameReferenceModeProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_FrameReferenceModeProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_FrameReferenceModeProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_FrameReferenceModeProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.FrameReferenceModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_FrameReferenceModeProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.FrameReferenceModeProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_FrameReferenceModeProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_FrameReferenceModeProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.FrameReferenceModeProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_FrameReferenceModeProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_FrameReferenceModeProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.FrameReferenceModeProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_FrameReferenceModeProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.FrameReferenceModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadYModeProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_ReadYModeProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadYModeProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadYModeProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadYModeProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadYModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadYModeProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadYModeProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadYModeProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadYModeProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadYModeProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadYModeProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadYModeProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadYModeProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadYModeProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadYModeProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_ReadPartitionProbs

// repeated .CompressedHeader.DiffUpdateProb diff_update_prob = 1;
inline int CompressedHeader_ReadPartitionProbs::_internal_diff_update_prob_size() const {
  return _impl_.diff_update_prob_.size();
}
inline int CompressedHeader_ReadPartitionProbs::diff_update_prob_size() const {
  return _internal_diff_update_prob_size();
}
inline void CompressedHeader_ReadPartitionProbs::clear_diff_update_prob() {
  _impl_.diff_update_prob_.Clear();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadPartitionProbs::mutable_diff_update_prob(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.ReadPartitionProbs.diff_update_prob)
  return _impl_.diff_update_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >*
CompressedHeader_ReadPartitionProbs::mutable_diff_update_prob() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.ReadPartitionProbs.diff_update_prob)
  return &_impl_.diff_update_prob_;
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadPartitionProbs::_internal_diff_update_prob(int index) const {
  return _impl_.diff_update_prob_.Get(index);
}
inline const ::CompressedHeader_DiffUpdateProb& CompressedHeader_ReadPartitionProbs::diff_update_prob(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.ReadPartitionProbs.diff_update_prob)
  return _internal_diff_update_prob(index);
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadPartitionProbs::_internal_add_diff_update_prob() {
  return _impl_.diff_update_prob_.Add();
}
inline ::CompressedHeader_DiffUpdateProb* CompressedHeader_ReadPartitionProbs::add_diff_update_prob() {
  ::CompressedHeader_DiffUpdateProb* _add = _internal_add_diff_update_prob();
  // @@protoc_insertion_point(field_add:CompressedHeader.ReadPartitionProbs.diff_update_prob)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_DiffUpdateProb >&
CompressedHeader_ReadPartitionProbs::diff_update_prob() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.ReadPartitionProbs.diff_update_prob)
  return _impl_.diff_update_prob_;
}

// -------------------------------------------------------------------

// CompressedHeader_MvProbs_MvProbsLoop

// .VP9BitField update_mv_prob = 1;
inline void CompressedHeader_MvProbs_MvProbsLoop::clear_update_mv_prob() {
  _impl_.update_mv_prob_ = 0;
}
inline ::VP9BitField CompressedHeader_MvProbs_MvProbsLoop::_internal_update_mv_prob() const {
  return static_cast< ::VP9BitField >(_impl_.update_mv_prob_);
}
inline ::VP9BitField CompressedHeader_MvProbs_MvProbsLoop::update_mv_prob() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.MvProbs.MvProbsLoop.update_mv_prob)
  return _internal_update_mv_prob();
}
inline void CompressedHeader_MvProbs_MvProbsLoop::_internal_set_update_mv_prob(::VP9BitField value) {
  
  _impl_.update_mv_prob_ = value;
}
inline void CompressedHeader_MvProbs_MvProbsLoop::set_update_mv_prob(::VP9BitField value) {
  _internal_set_update_mv_prob(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.MvProbs.MvProbsLoop.update_mv_prob)
}

// uint32 mv_prob = 2;
inline void CompressedHeader_MvProbs_MvProbsLoop::clear_mv_prob() {
  _impl_.mv_prob_ = 0u;
}
inline uint32_t CompressedHeader_MvProbs_MvProbsLoop::_internal_mv_prob() const {
  return _impl_.mv_prob_;
}
inline uint32_t CompressedHeader_MvProbs_MvProbsLoop::mv_prob() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.MvProbs.MvProbsLoop.mv_prob)
  return _internal_mv_prob();
}
inline void CompressedHeader_MvProbs_MvProbsLoop::_internal_set_mv_prob(uint32_t value) {

  _impl_.mv_prob_ = value;
}
inline void CompressedHeader_MvProbs_MvProbsLoop::set_mv_prob(uint32_t value) {
  _internal_set_mv_prob(value);
  // @@protoc_insertion_point(field_set:CompressedHeader.MvProbs.MvProbsLoop.mv_prob)
}

// -------------------------------------------------------------------

// CompressedHeader_MvProbs

// repeated .CompressedHeader.MvProbs.MvProbsLoop mv_probs = 1;
inline int CompressedHeader_MvProbs::_internal_mv_probs_size() const {
  return _impl_.mv_probs_.size();
}
inline int CompressedHeader_MvProbs::mv_probs_size() const {
  return _internal_mv_probs_size();
}
inline void CompressedHeader_MvProbs::clear_mv_probs() {
  _impl_.mv_probs_.Clear();
}
inline ::CompressedHeader_MvProbs_MvProbsLoop* CompressedHeader_MvProbs::mutable_mv_probs(int index) {
  // @@protoc_insertion_point(field_mutable:CompressedHeader.MvProbs.mv_probs)
  return _impl_.mv_probs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_MvProbs_MvProbsLoop >*
CompressedHeader_MvProbs::mutable_mv_probs() {
  // @@protoc_insertion_point(field_mutable_list:CompressedHeader.MvProbs.mv_probs)
  return &_impl_.mv_probs_;
}
inline const ::CompressedHeader_MvProbs_MvProbsLoop& CompressedHeader_MvProbs::_internal_mv_probs(int index) const {
  return _impl_.mv_probs_.Get(index);
}
inline const ::CompressedHeader_MvProbs_MvProbsLoop& CompressedHeader_MvProbs::mv_probs(int index) const {
  // @@protoc_insertion_point(field_get:CompressedHeader.MvProbs.mv_probs)
  return _internal_mv_probs(index);
}
inline ::CompressedHeader_MvProbs_MvProbsLoop* CompressedHeader_MvProbs::_internal_add_mv_probs() {
  return _impl_.mv_probs_.Add();
}
inline ::CompressedHeader_MvProbs_MvProbsLoop* CompressedHeader_MvProbs::add_mv_probs() {
  ::CompressedHeader_MvProbs_MvProbsLoop* _add = _internal_add_mv_probs();
  // @@protoc_insertion_point(field_add:CompressedHeader.MvProbs.mv_probs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CompressedHeader_MvProbs_MvProbsLoop >&
CompressedHeader_MvProbs::mv_probs() const {
  // @@protoc_insertion_point(field_list:CompressedHeader.MvProbs.mv_probs)
  return _impl_.mv_probs_;
}

// -------------------------------------------------------------------

// CompressedHeader

// .CompressedHeader.ReadTxMode read_tx_mode = 1;
inline bool CompressedHeader::_internal_has_read_tx_mode() const {
  return this != internal_default_instance() && _impl_.read_tx_mode_ != nullptr;
}
inline bool CompressedHeader::has_read_tx_mode() const {
  return _internal_has_read_tx_mode();
}
inline void CompressedHeader::clear_read_tx_mode() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_tx_mode_ != nullptr) {
    delete _impl_.read_tx_mode_;
  }
  _impl_.read_tx_mode_ = nullptr;
}
inline const ::CompressedHeader_ReadTxMode& CompressedHeader::_internal_read_tx_mode() const {
  const ::CompressedHeader_ReadTxMode* p = _impl_.read_tx_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadTxMode&>(
      ::_CompressedHeader_ReadTxMode_default_instance_);
}
inline const ::CompressedHeader_ReadTxMode& CompressedHeader::read_tx_mode() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_tx_mode)
  return _internal_read_tx_mode();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_tx_mode(
    ::CompressedHeader_ReadTxMode* read_tx_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_tx_mode_);
  }
  _impl_.read_tx_mode_ = read_tx_mode;
  if (read_tx_mode) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_tx_mode)
}
inline ::CompressedHeader_ReadTxMode* CompressedHeader::release_read_tx_mode() {
  
  ::CompressedHeader_ReadTxMode* temp = _impl_.read_tx_mode_;
  _impl_.read_tx_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadTxMode* CompressedHeader::unsafe_arena_release_read_tx_mode() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_tx_mode)
  
  ::CompressedHeader_ReadTxMode* temp = _impl_.read_tx_mode_;
  _impl_.read_tx_mode_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadTxMode* CompressedHeader::_internal_mutable_read_tx_mode() {
  
  if (_impl_.read_tx_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadTxMode>(GetArenaForAllocation());
    _impl_.read_tx_mode_ = p;
  }
  return _impl_.read_tx_mode_;
}
inline ::CompressedHeader_ReadTxMode* CompressedHeader::mutable_read_tx_mode() {
  ::CompressedHeader_ReadTxMode* _msg = _internal_mutable_read_tx_mode();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_tx_mode)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_tx_mode(::CompressedHeader_ReadTxMode* read_tx_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_tx_mode_;
  }
  if (read_tx_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_tx_mode);
    if (message_arena != submessage_arena) {
      read_tx_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_tx_mode, submessage_arena);
    }

  } else {

  }
  _impl_.read_tx_mode_ = read_tx_mode;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_tx_mode)
}

// .CompressedHeader.TxModeProbs tx_mode_probs = 2;
inline bool CompressedHeader::_internal_has_tx_mode_probs() const {
  return this != internal_default_instance() && _impl_.tx_mode_probs_ != nullptr;
}
inline bool CompressedHeader::has_tx_mode_probs() const {
  return _internal_has_tx_mode_probs();
}
inline void CompressedHeader::clear_tx_mode_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.tx_mode_probs_ != nullptr) {
    delete _impl_.tx_mode_probs_;
  }
  _impl_.tx_mode_probs_ = nullptr;
}
inline const ::CompressedHeader_TxModeProbs& CompressedHeader::_internal_tx_mode_probs() const {
  const ::CompressedHeader_TxModeProbs* p = _impl_.tx_mode_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_TxModeProbs&>(
      ::_CompressedHeader_TxModeProbs_default_instance_);
}
inline const ::CompressedHeader_TxModeProbs& CompressedHeader::tx_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.tx_mode_probs)
  return _internal_tx_mode_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_tx_mode_probs(
    ::CompressedHeader_TxModeProbs* tx_mode_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_mode_probs_);
  }
  _impl_.tx_mode_probs_ = tx_mode_probs;
  if (tx_mode_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.tx_mode_probs)
}
inline ::CompressedHeader_TxModeProbs* CompressedHeader::release_tx_mode_probs() {
  
  ::CompressedHeader_TxModeProbs* temp = _impl_.tx_mode_probs_;
  _impl_.tx_mode_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_TxModeProbs* CompressedHeader::unsafe_arena_release_tx_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.tx_mode_probs)
  
  ::CompressedHeader_TxModeProbs* temp = _impl_.tx_mode_probs_;
  _impl_.tx_mode_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_TxModeProbs* CompressedHeader::_internal_mutable_tx_mode_probs() {
  
  if (_impl_.tx_mode_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_TxModeProbs>(GetArenaForAllocation());
    _impl_.tx_mode_probs_ = p;
  }
  return _impl_.tx_mode_probs_;
}
inline ::CompressedHeader_TxModeProbs* CompressedHeader::mutable_tx_mode_probs() {
  ::CompressedHeader_TxModeProbs* _msg = _internal_mutable_tx_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.tx_mode_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_tx_mode_probs(::CompressedHeader_TxModeProbs* tx_mode_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tx_mode_probs_;
  }
  if (tx_mode_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tx_mode_probs);
    if (message_arena != submessage_arena) {
      tx_mode_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_mode_probs, submessage_arena);
    }

  } else {

  }
  _impl_.tx_mode_probs_ = tx_mode_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.tx_mode_probs)
}

// .CompressedHeader.ReadCoefProbs read_coef_probs = 3;
inline bool CompressedHeader::_internal_has_read_coef_probs() const {
  return this != internal_default_instance() && _impl_.read_coef_probs_ != nullptr;
}
inline bool CompressedHeader::has_read_coef_probs() const {
  return _internal_has_read_coef_probs();
}
inline void CompressedHeader::clear_read_coef_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_coef_probs_ != nullptr) {
    delete _impl_.read_coef_probs_;
  }
  _impl_.read_coef_probs_ = nullptr;
}
inline const ::CompressedHeader_ReadCoefProbs& CompressedHeader::_internal_read_coef_probs() const {
  const ::CompressedHeader_ReadCoefProbs* p = _impl_.read_coef_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadCoefProbs&>(
      ::_CompressedHeader_ReadCoefProbs_default_instance_);
}
inline const ::CompressedHeader_ReadCoefProbs& CompressedHeader::read_coef_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_coef_probs)
  return _internal_read_coef_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_coef_probs(
    ::CompressedHeader_ReadCoefProbs* read_coef_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_coef_probs_);
  }
  _impl_.read_coef_probs_ = read_coef_probs;
  if (read_coef_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_coef_probs)
}
inline ::CompressedHeader_ReadCoefProbs* CompressedHeader::release_read_coef_probs() {
  
  ::CompressedHeader_ReadCoefProbs* temp = _impl_.read_coef_probs_;
  _impl_.read_coef_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadCoefProbs* CompressedHeader::unsafe_arena_release_read_coef_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_coef_probs)
  
  ::CompressedHeader_ReadCoefProbs* temp = _impl_.read_coef_probs_;
  _impl_.read_coef_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadCoefProbs* CompressedHeader::_internal_mutable_read_coef_probs() {
  
  if (_impl_.read_coef_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadCoefProbs>(GetArenaForAllocation());
    _impl_.read_coef_probs_ = p;
  }
  return _impl_.read_coef_probs_;
}
inline ::CompressedHeader_ReadCoefProbs* CompressedHeader::mutable_read_coef_probs() {
  ::CompressedHeader_ReadCoefProbs* _msg = _internal_mutable_read_coef_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_coef_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_coef_probs(::CompressedHeader_ReadCoefProbs* read_coef_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_coef_probs_;
  }
  if (read_coef_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_coef_probs);
    if (message_arena != submessage_arena) {
      read_coef_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_coef_probs, submessage_arena);
    }

  } else {

  }
  _impl_.read_coef_probs_ = read_coef_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_coef_probs)
}

// .CompressedHeader.ReadSkipProb read_skip_prob = 4;
inline bool CompressedHeader::_internal_has_read_skip_prob() const {
  return this != internal_default_instance() && _impl_.read_skip_prob_ != nullptr;
}
inline bool CompressedHeader::has_read_skip_prob() const {
  return _internal_has_read_skip_prob();
}
inline void CompressedHeader::clear_read_skip_prob() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_skip_prob_ != nullptr) {
    delete _impl_.read_skip_prob_;
  }
  _impl_.read_skip_prob_ = nullptr;
}
inline const ::CompressedHeader_ReadSkipProb& CompressedHeader::_internal_read_skip_prob() const {
  const ::CompressedHeader_ReadSkipProb* p = _impl_.read_skip_prob_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadSkipProb&>(
      ::_CompressedHeader_ReadSkipProb_default_instance_);
}
inline const ::CompressedHeader_ReadSkipProb& CompressedHeader::read_skip_prob() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_skip_prob)
  return _internal_read_skip_prob();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_skip_prob(
    ::CompressedHeader_ReadSkipProb* read_skip_prob) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_skip_prob_);
  }
  _impl_.read_skip_prob_ = read_skip_prob;
  if (read_skip_prob) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_skip_prob)
}
inline ::CompressedHeader_ReadSkipProb* CompressedHeader::release_read_skip_prob() {
  
  ::CompressedHeader_ReadSkipProb* temp = _impl_.read_skip_prob_;
  _impl_.read_skip_prob_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadSkipProb* CompressedHeader::unsafe_arena_release_read_skip_prob() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_skip_prob)
  
  ::CompressedHeader_ReadSkipProb* temp = _impl_.read_skip_prob_;
  _impl_.read_skip_prob_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadSkipProb* CompressedHeader::_internal_mutable_read_skip_prob() {
  
  if (_impl_.read_skip_prob_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadSkipProb>(GetArenaForAllocation());
    _impl_.read_skip_prob_ = p;
  }
  return _impl_.read_skip_prob_;
}
inline ::CompressedHeader_ReadSkipProb* CompressedHeader::mutable_read_skip_prob() {
  ::CompressedHeader_ReadSkipProb* _msg = _internal_mutable_read_skip_prob();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_skip_prob)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_skip_prob(::CompressedHeader_ReadSkipProb* read_skip_prob) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_skip_prob_;
  }
  if (read_skip_prob) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_skip_prob);
    if (message_arena != submessage_arena) {
      read_skip_prob = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_skip_prob, submessage_arena);
    }

  } else {

  }
  _impl_.read_skip_prob_ = read_skip_prob;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_skip_prob)
}

// .CompressedHeader.ReadInterModeProbs read_inter_mode_probs = 5;
inline bool CompressedHeader::_internal_has_read_inter_mode_probs() const {
  return this != internal_default_instance() && _impl_.read_inter_mode_probs_ != nullptr;
}
inline bool CompressedHeader::has_read_inter_mode_probs() const {
  return _internal_has_read_inter_mode_probs();
}
inline void CompressedHeader::clear_read_inter_mode_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_inter_mode_probs_ != nullptr) {
    delete _impl_.read_inter_mode_probs_;
  }
  _impl_.read_inter_mode_probs_ = nullptr;
}
inline const ::CompressedHeader_ReadInterModeProbs& CompressedHeader::_internal_read_inter_mode_probs() const {
  const ::CompressedHeader_ReadInterModeProbs* p = _impl_.read_inter_mode_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadInterModeProbs&>(
      ::_CompressedHeader_ReadInterModeProbs_default_instance_);
}
inline const ::CompressedHeader_ReadInterModeProbs& CompressedHeader::read_inter_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_inter_mode_probs)
  return _internal_read_inter_mode_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_inter_mode_probs(
    ::CompressedHeader_ReadInterModeProbs* read_inter_mode_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_inter_mode_probs_);
  }
  _impl_.read_inter_mode_probs_ = read_inter_mode_probs;
  if (read_inter_mode_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_inter_mode_probs)
}
inline ::CompressedHeader_ReadInterModeProbs* CompressedHeader::release_read_inter_mode_probs() {
  
  ::CompressedHeader_ReadInterModeProbs* temp = _impl_.read_inter_mode_probs_;
  _impl_.read_inter_mode_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadInterModeProbs* CompressedHeader::unsafe_arena_release_read_inter_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_inter_mode_probs)
  
  ::CompressedHeader_ReadInterModeProbs* temp = _impl_.read_inter_mode_probs_;
  _impl_.read_inter_mode_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadInterModeProbs* CompressedHeader::_internal_mutable_read_inter_mode_probs() {
  
  if (_impl_.read_inter_mode_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadInterModeProbs>(GetArenaForAllocation());
    _impl_.read_inter_mode_probs_ = p;
  }
  return _impl_.read_inter_mode_probs_;
}
inline ::CompressedHeader_ReadInterModeProbs* CompressedHeader::mutable_read_inter_mode_probs() {
  ::CompressedHeader_ReadInterModeProbs* _msg = _internal_mutable_read_inter_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_inter_mode_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_inter_mode_probs(::CompressedHeader_ReadInterModeProbs* read_inter_mode_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_inter_mode_probs_;
  }
  if (read_inter_mode_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_inter_mode_probs);
    if (message_arena != submessage_arena) {
      read_inter_mode_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_inter_mode_probs, submessage_arena);
    }

  } else {

  }
  _impl_.read_inter_mode_probs_ = read_inter_mode_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_inter_mode_probs)
}

// .CompressedHeader.ReadInterpFilterProbs read_interp_filter_probs = 6;
inline bool CompressedHeader::_internal_has_read_interp_filter_probs() const {
  return this != internal_default_instance() && _impl_.read_interp_filter_probs_ != nullptr;
}
inline bool CompressedHeader::has_read_interp_filter_probs() const {
  return _internal_has_read_interp_filter_probs();
}
inline void CompressedHeader::clear_read_interp_filter_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_interp_filter_probs_ != nullptr) {
    delete _impl_.read_interp_filter_probs_;
  }
  _impl_.read_interp_filter_probs_ = nullptr;
}
inline const ::CompressedHeader_ReadInterpFilterProbs& CompressedHeader::_internal_read_interp_filter_probs() const {
  const ::CompressedHeader_ReadInterpFilterProbs* p = _impl_.read_interp_filter_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadInterpFilterProbs&>(
      ::_CompressedHeader_ReadInterpFilterProbs_default_instance_);
}
inline const ::CompressedHeader_ReadInterpFilterProbs& CompressedHeader::read_interp_filter_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_interp_filter_probs)
  return _internal_read_interp_filter_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_interp_filter_probs(
    ::CompressedHeader_ReadInterpFilterProbs* read_interp_filter_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_interp_filter_probs_);
  }
  _impl_.read_interp_filter_probs_ = read_interp_filter_probs;
  if (read_interp_filter_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_interp_filter_probs)
}
inline ::CompressedHeader_ReadInterpFilterProbs* CompressedHeader::release_read_interp_filter_probs() {
  
  ::CompressedHeader_ReadInterpFilterProbs* temp = _impl_.read_interp_filter_probs_;
  _impl_.read_interp_filter_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadInterpFilterProbs* CompressedHeader::unsafe_arena_release_read_interp_filter_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_interp_filter_probs)
  
  ::CompressedHeader_ReadInterpFilterProbs* temp = _impl_.read_interp_filter_probs_;
  _impl_.read_interp_filter_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadInterpFilterProbs* CompressedHeader::_internal_mutable_read_interp_filter_probs() {
  
  if (_impl_.read_interp_filter_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadInterpFilterProbs>(GetArenaForAllocation());
    _impl_.read_interp_filter_probs_ = p;
  }
  return _impl_.read_interp_filter_probs_;
}
inline ::CompressedHeader_ReadInterpFilterProbs* CompressedHeader::mutable_read_interp_filter_probs() {
  ::CompressedHeader_ReadInterpFilterProbs* _msg = _internal_mutable_read_interp_filter_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_interp_filter_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_interp_filter_probs(::CompressedHeader_ReadInterpFilterProbs* read_interp_filter_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_interp_filter_probs_;
  }
  if (read_interp_filter_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_interp_filter_probs);
    if (message_arena != submessage_arena) {
      read_interp_filter_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_interp_filter_probs, submessage_arena);
    }

  } else {

  }
  _impl_.read_interp_filter_probs_ = read_interp_filter_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_interp_filter_probs)
}

// .CompressedHeader.ReadIsInterProbs read_is_inter_probs = 7;
inline bool CompressedHeader::_internal_has_read_is_inter_probs() const {
  return this != internal_default_instance() && _impl_.read_is_inter_probs_ != nullptr;
}
inline bool CompressedHeader::has_read_is_inter_probs() const {
  return _internal_has_read_is_inter_probs();
}
inline void CompressedHeader::clear_read_is_inter_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_is_inter_probs_ != nullptr) {
    delete _impl_.read_is_inter_probs_;
  }
  _impl_.read_is_inter_probs_ = nullptr;
}
inline const ::CompressedHeader_ReadIsInterProbs& CompressedHeader::_internal_read_is_inter_probs() const {
  const ::CompressedHeader_ReadIsInterProbs* p = _impl_.read_is_inter_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadIsInterProbs&>(
      ::_CompressedHeader_ReadIsInterProbs_default_instance_);
}
inline const ::CompressedHeader_ReadIsInterProbs& CompressedHeader::read_is_inter_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_is_inter_probs)
  return _internal_read_is_inter_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_is_inter_probs(
    ::CompressedHeader_ReadIsInterProbs* read_is_inter_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_is_inter_probs_);
  }
  _impl_.read_is_inter_probs_ = read_is_inter_probs;
  if (read_is_inter_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_is_inter_probs)
}
inline ::CompressedHeader_ReadIsInterProbs* CompressedHeader::release_read_is_inter_probs() {
  
  ::CompressedHeader_ReadIsInterProbs* temp = _impl_.read_is_inter_probs_;
  _impl_.read_is_inter_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadIsInterProbs* CompressedHeader::unsafe_arena_release_read_is_inter_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_is_inter_probs)
  
  ::CompressedHeader_ReadIsInterProbs* temp = _impl_.read_is_inter_probs_;
  _impl_.read_is_inter_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadIsInterProbs* CompressedHeader::_internal_mutable_read_is_inter_probs() {
  
  if (_impl_.read_is_inter_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadIsInterProbs>(GetArenaForAllocation());
    _impl_.read_is_inter_probs_ = p;
  }
  return _impl_.read_is_inter_probs_;
}
inline ::CompressedHeader_ReadIsInterProbs* CompressedHeader::mutable_read_is_inter_probs() {
  ::CompressedHeader_ReadIsInterProbs* _msg = _internal_mutable_read_is_inter_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_is_inter_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_is_inter_probs(::CompressedHeader_ReadIsInterProbs* read_is_inter_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_is_inter_probs_;
  }
  if (read_is_inter_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_is_inter_probs);
    if (message_arena != submessage_arena) {
      read_is_inter_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_is_inter_probs, submessage_arena);
    }

  } else {

  }
  _impl_.read_is_inter_probs_ = read_is_inter_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_is_inter_probs)
}

// .CompressedHeader.FrameReferenceMode frame_reference_mode = 8;
inline bool CompressedHeader::_internal_has_frame_reference_mode() const {
  return this != internal_default_instance() && _impl_.frame_reference_mode_ != nullptr;
}
inline bool CompressedHeader::has_frame_reference_mode() const {
  return _internal_has_frame_reference_mode();
}
inline void CompressedHeader::clear_frame_reference_mode() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_reference_mode_ != nullptr) {
    delete _impl_.frame_reference_mode_;
  }
  _impl_.frame_reference_mode_ = nullptr;
}
inline const ::CompressedHeader_FrameReferenceMode& CompressedHeader::_internal_frame_reference_mode() const {
  const ::CompressedHeader_FrameReferenceMode* p = _impl_.frame_reference_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_FrameReferenceMode&>(
      ::_CompressedHeader_FrameReferenceMode_default_instance_);
}
inline const ::CompressedHeader_FrameReferenceMode& CompressedHeader::frame_reference_mode() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.frame_reference_mode)
  return _internal_frame_reference_mode();
}
inline void CompressedHeader::unsafe_arena_set_allocated_frame_reference_mode(
    ::CompressedHeader_FrameReferenceMode* frame_reference_mode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_reference_mode_);
  }
  _impl_.frame_reference_mode_ = frame_reference_mode;
  if (frame_reference_mode) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.frame_reference_mode)
}
inline ::CompressedHeader_FrameReferenceMode* CompressedHeader::release_frame_reference_mode() {
  
  ::CompressedHeader_FrameReferenceMode* temp = _impl_.frame_reference_mode_;
  _impl_.frame_reference_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_FrameReferenceMode* CompressedHeader::unsafe_arena_release_frame_reference_mode() {
  // @@protoc_insertion_point(field_release:CompressedHeader.frame_reference_mode)
  
  ::CompressedHeader_FrameReferenceMode* temp = _impl_.frame_reference_mode_;
  _impl_.frame_reference_mode_ = nullptr;
  return temp;
}
inline ::CompressedHeader_FrameReferenceMode* CompressedHeader::_internal_mutable_frame_reference_mode() {
  
  if (_impl_.frame_reference_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_FrameReferenceMode>(GetArenaForAllocation());
    _impl_.frame_reference_mode_ = p;
  }
  return _impl_.frame_reference_mode_;
}
inline ::CompressedHeader_FrameReferenceMode* CompressedHeader::mutable_frame_reference_mode() {
  ::CompressedHeader_FrameReferenceMode* _msg = _internal_mutable_frame_reference_mode();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.frame_reference_mode)
  return _msg;
}
inline void CompressedHeader::set_allocated_frame_reference_mode(::CompressedHeader_FrameReferenceMode* frame_reference_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_reference_mode_;
  }
  if (frame_reference_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_reference_mode);
    if (message_arena != submessage_arena) {
      frame_reference_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_reference_mode, submessage_arena);
    }

  } else {

  }
  _impl_.frame_reference_mode_ = frame_reference_mode;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.frame_reference_mode)
}

// .CompressedHeader.FrameReferenceModeProbs frame_reference_mode_probs = 9;
inline bool CompressedHeader::_internal_has_frame_reference_mode_probs() const {
  return this != internal_default_instance() && _impl_.frame_reference_mode_probs_ != nullptr;
}
inline bool CompressedHeader::has_frame_reference_mode_probs() const {
  return _internal_has_frame_reference_mode_probs();
}
inline void CompressedHeader::clear_frame_reference_mode_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_reference_mode_probs_ != nullptr) {
    delete _impl_.frame_reference_mode_probs_;
  }
  _impl_.frame_reference_mode_probs_ = nullptr;
}
inline const ::CompressedHeader_FrameReferenceModeProbs& CompressedHeader::_internal_frame_reference_mode_probs() const {
  const ::CompressedHeader_FrameReferenceModeProbs* p = _impl_.frame_reference_mode_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_FrameReferenceModeProbs&>(
      ::_CompressedHeader_FrameReferenceModeProbs_default_instance_);
}
inline const ::CompressedHeader_FrameReferenceModeProbs& CompressedHeader::frame_reference_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.frame_reference_mode_probs)
  return _internal_frame_reference_mode_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_frame_reference_mode_probs(
    ::CompressedHeader_FrameReferenceModeProbs* frame_reference_mode_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_reference_mode_probs_);
  }
  _impl_.frame_reference_mode_probs_ = frame_reference_mode_probs;
  if (frame_reference_mode_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.frame_reference_mode_probs)
}
inline ::CompressedHeader_FrameReferenceModeProbs* CompressedHeader::release_frame_reference_mode_probs() {
  
  ::CompressedHeader_FrameReferenceModeProbs* temp = _impl_.frame_reference_mode_probs_;
  _impl_.frame_reference_mode_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_FrameReferenceModeProbs* CompressedHeader::unsafe_arena_release_frame_reference_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.frame_reference_mode_probs)
  
  ::CompressedHeader_FrameReferenceModeProbs* temp = _impl_.frame_reference_mode_probs_;
  _impl_.frame_reference_mode_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_FrameReferenceModeProbs* CompressedHeader::_internal_mutable_frame_reference_mode_probs() {
  
  if (_impl_.frame_reference_mode_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_FrameReferenceModeProbs>(GetArenaForAllocation());
    _impl_.frame_reference_mode_probs_ = p;
  }
  return _impl_.frame_reference_mode_probs_;
}
inline ::CompressedHeader_FrameReferenceModeProbs* CompressedHeader::mutable_frame_reference_mode_probs() {
  ::CompressedHeader_FrameReferenceModeProbs* _msg = _internal_mutable_frame_reference_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.frame_reference_mode_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_frame_reference_mode_probs(::CompressedHeader_FrameReferenceModeProbs* frame_reference_mode_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_reference_mode_probs_;
  }
  if (frame_reference_mode_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_reference_mode_probs);
    if (message_arena != submessage_arena) {
      frame_reference_mode_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_reference_mode_probs, submessage_arena);
    }

  } else {

  }
  _impl_.frame_reference_mode_probs_ = frame_reference_mode_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.frame_reference_mode_probs)
}

// .CompressedHeader.ReadYModeProbs read_y_mode_probs = 10;
inline bool CompressedHeader::_internal_has_read_y_mode_probs() const {
  return this != internal_default_instance() && _impl_.read_y_mode_probs_ != nullptr;
}
inline bool CompressedHeader::has_read_y_mode_probs() const {
  return _internal_has_read_y_mode_probs();
}
inline void CompressedHeader::clear_read_y_mode_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_y_mode_probs_ != nullptr) {
    delete _impl_.read_y_mode_probs_;
  }
  _impl_.read_y_mode_probs_ = nullptr;
}
inline const ::CompressedHeader_ReadYModeProbs& CompressedHeader::_internal_read_y_mode_probs() const {
  const ::CompressedHeader_ReadYModeProbs* p = _impl_.read_y_mode_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadYModeProbs&>(
      ::_CompressedHeader_ReadYModeProbs_default_instance_);
}
inline const ::CompressedHeader_ReadYModeProbs& CompressedHeader::read_y_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_y_mode_probs)
  return _internal_read_y_mode_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_y_mode_probs(
    ::CompressedHeader_ReadYModeProbs* read_y_mode_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_y_mode_probs_);
  }
  _impl_.read_y_mode_probs_ = read_y_mode_probs;
  if (read_y_mode_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_y_mode_probs)
}
inline ::CompressedHeader_ReadYModeProbs* CompressedHeader::release_read_y_mode_probs() {
  
  ::CompressedHeader_ReadYModeProbs* temp = _impl_.read_y_mode_probs_;
  _impl_.read_y_mode_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadYModeProbs* CompressedHeader::unsafe_arena_release_read_y_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_y_mode_probs)
  
  ::CompressedHeader_ReadYModeProbs* temp = _impl_.read_y_mode_probs_;
  _impl_.read_y_mode_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadYModeProbs* CompressedHeader::_internal_mutable_read_y_mode_probs() {
  
  if (_impl_.read_y_mode_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadYModeProbs>(GetArenaForAllocation());
    _impl_.read_y_mode_probs_ = p;
  }
  return _impl_.read_y_mode_probs_;
}
inline ::CompressedHeader_ReadYModeProbs* CompressedHeader::mutable_read_y_mode_probs() {
  ::CompressedHeader_ReadYModeProbs* _msg = _internal_mutable_read_y_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_y_mode_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_y_mode_probs(::CompressedHeader_ReadYModeProbs* read_y_mode_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_y_mode_probs_;
  }
  if (read_y_mode_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_y_mode_probs);
    if (message_arena != submessage_arena) {
      read_y_mode_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_y_mode_probs, submessage_arena);
    }

  } else {

  }
  _impl_.read_y_mode_probs_ = read_y_mode_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_y_mode_probs)
}

// .CompressedHeader.ReadPartitionProbs read_partition_probs = 11;
inline bool CompressedHeader::_internal_has_read_partition_probs() const {
  return this != internal_default_instance() && _impl_.read_partition_probs_ != nullptr;
}
inline bool CompressedHeader::has_read_partition_probs() const {
  return _internal_has_read_partition_probs();
}
inline void CompressedHeader::clear_read_partition_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_partition_probs_ != nullptr) {
    delete _impl_.read_partition_probs_;
  }
  _impl_.read_partition_probs_ = nullptr;
}
inline const ::CompressedHeader_ReadPartitionProbs& CompressedHeader::_internal_read_partition_probs() const {
  const ::CompressedHeader_ReadPartitionProbs* p = _impl_.read_partition_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_ReadPartitionProbs&>(
      ::_CompressedHeader_ReadPartitionProbs_default_instance_);
}
inline const ::CompressedHeader_ReadPartitionProbs& CompressedHeader::read_partition_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_partition_probs)
  return _internal_read_partition_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_read_partition_probs(
    ::CompressedHeader_ReadPartitionProbs* read_partition_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_partition_probs_);
  }
  _impl_.read_partition_probs_ = read_partition_probs;
  if (read_partition_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.read_partition_probs)
}
inline ::CompressedHeader_ReadPartitionProbs* CompressedHeader::release_read_partition_probs() {
  
  ::CompressedHeader_ReadPartitionProbs* temp = _impl_.read_partition_probs_;
  _impl_.read_partition_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_ReadPartitionProbs* CompressedHeader::unsafe_arena_release_read_partition_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_partition_probs)
  
  ::CompressedHeader_ReadPartitionProbs* temp = _impl_.read_partition_probs_;
  _impl_.read_partition_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_ReadPartitionProbs* CompressedHeader::_internal_mutable_read_partition_probs() {
  
  if (_impl_.read_partition_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_ReadPartitionProbs>(GetArenaForAllocation());
    _impl_.read_partition_probs_ = p;
  }
  return _impl_.read_partition_probs_;
}
inline ::CompressedHeader_ReadPartitionProbs* CompressedHeader::mutable_read_partition_probs() {
  ::CompressedHeader_ReadPartitionProbs* _msg = _internal_mutable_read_partition_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_partition_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_read_partition_probs(::CompressedHeader_ReadPartitionProbs* read_partition_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_partition_probs_;
  }
  if (read_partition_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_partition_probs);
    if (message_arena != submessage_arena) {
      read_partition_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_partition_probs, submessage_arena);
    }

  } else {

  }
  _impl_.read_partition_probs_ = read_partition_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_partition_probs)
}

// .CompressedHeader.MvProbs mv_probs = 12;
inline bool CompressedHeader::_internal_has_mv_probs() const {
  return this != internal_default_instance() && _impl_.mv_probs_ != nullptr;
}
inline bool CompressedHeader::has_mv_probs() const {
  return _internal_has_mv_probs();
}
inline void CompressedHeader::clear_mv_probs() {
  if (GetArenaForAllocation() == nullptr && _impl_.mv_probs_ != nullptr) {
    delete _impl_.mv_probs_;
  }
  _impl_.mv_probs_ = nullptr;
}
inline const ::CompressedHeader_MvProbs& CompressedHeader::_internal_mv_probs() const {
  const ::CompressedHeader_MvProbs* p = _impl_.mv_probs_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader_MvProbs&>(
      ::_CompressedHeader_MvProbs_default_instance_);
}
inline const ::CompressedHeader_MvProbs& CompressedHeader::mv_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.mv_probs)
  return _internal_mv_probs();
}
inline void CompressedHeader::unsafe_arena_set_allocated_mv_probs(
    ::CompressedHeader_MvProbs* mv_probs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mv_probs_);
  }
  _impl_.mv_probs_ = mv_probs;
  if (mv_probs) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CompressedHeader.mv_probs)
}
inline ::CompressedHeader_MvProbs* CompressedHeader::release_mv_probs() {
  
  ::CompressedHeader_MvProbs* temp = _impl_.mv_probs_;
  _impl_.mv_probs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader_MvProbs* CompressedHeader::unsafe_arena_release_mv_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.mv_probs)
  
  ::CompressedHeader_MvProbs* temp = _impl_.mv_probs_;
  _impl_.mv_probs_ = nullptr;
  return temp;
}
inline ::CompressedHeader_MvProbs* CompressedHeader::_internal_mutable_mv_probs() {
  
  if (_impl_.mv_probs_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader_MvProbs>(GetArenaForAllocation());
    _impl_.mv_probs_ = p;
  }
  return _impl_.mv_probs_;
}
inline ::CompressedHeader_MvProbs* CompressedHeader::mutable_mv_probs() {
  ::CompressedHeader_MvProbs* _msg = _internal_mutable_mv_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.mv_probs)
  return _msg;
}
inline void CompressedHeader::set_allocated_mv_probs(::CompressedHeader_MvProbs* mv_probs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mv_probs_;
  }
  if (mv_probs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mv_probs);
    if (message_arena != submessage_arena) {
      mv_probs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mv_probs, submessage_arena);
    }

  } else {

  }
  _impl_.mv_probs_ = mv_probs;
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.mv_probs)
}

// -------------------------------------------------------------------

// Tile

// uint32 tile_size = 1;
inline void Tile::clear_tile_size() {
  _impl_.tile_size_ = 0u;
}
inline uint32_t Tile::_internal_tile_size() const {
  return _impl_.tile_size_;
}
inline uint32_t Tile::tile_size() const {
  // @@protoc_insertion_point(field_get:Tile.tile_size)
  return _internal_tile_size();
}
inline void Tile::_internal_set_tile_size(uint32_t value) {

  _impl_.tile_size_ = value;
}
inline void Tile::set_tile_size(uint32_t value) {
  _internal_set_tile_size(value);
  // @@protoc_insertion_point(field_set:Tile.tile_size)
}

// bytes partition = 2;
inline void Tile::clear_partition() {
  _impl_.partition_.ClearToEmpty();
}
inline const std::string& Tile::partition() const {
  // @@protoc_insertion_point(field_get:Tile.partition)
  return _internal_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tile::set_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Tile.partition)
}
inline std::string* Tile::mutable_partition() {
  std::string* _s = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:Tile.partition)
  return _s;
}
inline const std::string& Tile::_internal_partition() const {
  return _impl_.partition_.Get();
}
inline void Tile::_internal_set_partition(const std::string& value) {

  _impl_.partition_.Set(value, GetArenaForAllocation());
}
inline std::string* Tile::_internal_mutable_partition() {

  return _impl_.partition_.Mutable(GetArenaForAllocation());
}
inline std::string* Tile::release_partition() {
  // @@protoc_insertion_point(field_release:Tile.partition)
  return _impl_.partition_.Release();
}
inline void Tile::set_allocated_partition(std::string* partition) {
  if (partition != nullptr) {

  } else {

  }
  _impl_.partition_.SetAllocated(partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_.IsDefault()) {
    _impl_.partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Tile.partition)
}

// -------------------------------------------------------------------

// VP9Frame

// .UncompressedHeader uncompressed_header = 1;
inline bool VP9Frame::_internal_has_uncompressed_header() const {
  return this != internal_default_instance() && _impl_.uncompressed_header_ != nullptr;
}
inline bool VP9Frame::has_uncompressed_header() const {
  return _internal_has_uncompressed_header();
}
inline void VP9Frame::clear_uncompressed_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.uncompressed_header_ != nullptr) {
    delete _impl_.uncompressed_header_;
  }
  _impl_.uncompressed_header_ = nullptr;
}
inline const ::UncompressedHeader& VP9Frame::_internal_uncompressed_header() const {
  const ::UncompressedHeader* p = _impl_.uncompressed_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader&>(
      ::_UncompressedHeader_default_instance_);
}
inline const ::UncompressedHeader& VP9Frame::uncompressed_header() const {
  // @@protoc_insertion_point(field_get:VP9Frame.uncompressed_header)
  return _internal_uncompressed_header();
}
inline void VP9Frame::unsafe_arena_set_allocated_uncompressed_header(
    ::UncompressedHeader* uncompressed_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uncompressed_header_);
  }
  _impl_.uncompressed_header_ = uncompressed_header;
  if (uncompressed_header) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VP9Frame.uncompressed_header)
}
inline ::UncompressedHeader* VP9Frame::release_uncompressed_header() {
  
  ::UncompressedHeader* temp = _impl_.uncompressed_header_;
  _impl_.uncompressed_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader* VP9Frame::unsafe_arena_release_uncompressed_header() {
  // @@protoc_insertion_point(field_release:VP9Frame.uncompressed_header)
  
  ::UncompressedHeader* temp = _impl_.uncompressed_header_;
  _impl_.uncompressed_header_ = nullptr;
  return temp;
}
inline ::UncompressedHeader* VP9Frame::_internal_mutable_uncompressed_header() {
  
  if (_impl_.uncompressed_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader>(GetArenaForAllocation());
    _impl_.uncompressed_header_ = p;
  }
  return _impl_.uncompressed_header_;
}
inline ::UncompressedHeader* VP9Frame::mutable_uncompressed_header() {
  ::UncompressedHeader* _msg = _internal_mutable_uncompressed_header();
  // @@protoc_insertion_point(field_mutable:VP9Frame.uncompressed_header)
  return _msg;
}
inline void VP9Frame::set_allocated_uncompressed_header(::UncompressedHeader* uncompressed_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uncompressed_header_;
  }
  if (uncompressed_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uncompressed_header);
    if (message_arena != submessage_arena) {
      uncompressed_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uncompressed_header, submessage_arena);
    }

  } else {

  }
  _impl_.uncompressed_header_ = uncompressed_header;
  // @@protoc_insertion_point(field_set_allocated:VP9Frame.uncompressed_header)
}

// .CompressedHeader compressed_header = 2;
inline bool VP9Frame::_internal_has_compressed_header() const {
  return this != internal_default_instance() && _impl_.compressed_header_ != nullptr;
}
inline bool VP9Frame::has_compressed_header() const {
  return _internal_has_compressed_header();
}
inline void VP9Frame::clear_compressed_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.compressed_header_ != nullptr) {
    delete _impl_.compressed_header_;
  }
  _impl_.compressed_header_ = nullptr;
}
inline const ::CompressedHeader& VP9Frame::_internal_compressed_header() const {
  const ::CompressedHeader* p = _impl_.compressed_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader&>(
      ::_CompressedHeader_default_instance_);
}
inline const ::CompressedHeader& VP9Frame::compressed_header() const {
  // @@protoc_insertion_point(field_get:VP9Frame.compressed_header)
  return _internal_compressed_header();
}
inline void VP9Frame::unsafe_arena_set_allocated_compressed_header(
    ::CompressedHeader* compressed_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compressed_header_);
  }
  _impl_.compressed_header_ = compressed_header;
  if (compressed_header) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VP9Frame.compressed_header)
}
inline ::CompressedHeader* VP9Frame::release_compressed_header() {
  
  ::CompressedHeader* temp = _impl_.compressed_header_;
  _impl_.compressed_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader* VP9Frame::unsafe_arena_release_compressed_header() {
  // @@protoc_insertion_point(field_release:VP9Frame.compressed_header)
  
  ::CompressedHeader* temp = _impl_.compressed_header_;
  _impl_.compressed_header_ = nullptr;
  return temp;
}
inline ::CompressedHeader* VP9Frame::_internal_mutable_compressed_header() {
  
  if (_impl_.compressed_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader>(GetArenaForAllocation());
    _impl_.compressed_header_ = p;
  }
  return _impl_.compressed_header_;
}
inline ::CompressedHeader* VP9Frame::mutable_compressed_header() {
  ::CompressedHeader* _msg = _internal_mutable_compressed_header();
  // @@protoc_insertion_point(field_mutable:VP9Frame.compressed_header)
  return _msg;
}
inline void VP9Frame::set_allocated_compressed_header(::CompressedHeader* compressed_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compressed_header_;
  }
  if (compressed_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compressed_header);
    if (message_arena != submessage_arena) {
      compressed_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compressed_header, submessage_arena);
    }

  } else {

  }
  _impl_.compressed_header_ = compressed_header;
  // @@protoc_insertion_point(field_set_allocated:VP9Frame.compressed_header)
}

// repeated .Tile tiles = 3;
inline int VP9Frame::_internal_tiles_size() const {
  return _impl_.tiles_.size();
}
inline int VP9Frame::tiles_size() const {
  return _internal_tiles_size();
}
inline void VP9Frame::clear_tiles() {
  _impl_.tiles_.Clear();
}
inline ::Tile* VP9Frame::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:VP9Frame.tiles)
  return _impl_.tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
VP9Frame::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:VP9Frame.tiles)
  return &_impl_.tiles_;
}
inline const ::Tile& VP9Frame::_internal_tiles(int index) const {
  return _impl_.tiles_.Get(index);
}
inline const ::Tile& VP9Frame::tiles(int index) const {
  // @@protoc_insertion_point(field_get:VP9Frame.tiles)
  return _internal_tiles(index);
}
inline ::Tile* VP9Frame::_internal_add_tiles() {
  return _impl_.tiles_.Add();
}
inline ::Tile* VP9Frame::add_tiles() {
  ::Tile* _add = _internal_add_tiles();
  // @@protoc_insertion_point(field_add:VP9Frame.tiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
VP9Frame::tiles() const {
  // @@protoc_insertion_point(field_list:VP9Frame.tiles)
  return _impl_.tiles_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::UncompressedHeader_ColorConfig_ColorSpace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UncompressedHeader_ColorConfig_ColorSpace>() {
  return ::UncompressedHeader_ColorConfig_ColorSpace_descriptor();
}
template <> struct is_proto_enum< ::UncompressedHeader_FrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UncompressedHeader_FrameType>() {
  return ::UncompressedHeader_FrameType_descriptor();
}
template <> struct is_proto_enum< ::UncompressedHeader_InterpolationFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UncompressedHeader_InterpolationFilter>() {
  return ::UncompressedHeader_InterpolationFilter_descriptor();
}
template <> struct is_proto_enum< ::CompressedHeader_TxMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CompressedHeader_TxMode>() {
  return ::CompressedHeader_TxMode_descriptor();
}
template <> struct is_proto_enum< ::VP9BitField> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VP9BitField>() {
  return ::VP9BitField_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_vp9_2eproto_2epb_2eh
