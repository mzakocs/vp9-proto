// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vp9.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vp9_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_vp9_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 3021000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_vp9_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vp9_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_vp9_2eproto;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Block_InterFrameModeInfo;
struct Block_InterFrameModeInfoDefaultTypeInternal;
extern Block_InterFrameModeInfoDefaultTypeInternal _Block_InterFrameModeInfo_default_instance_;
class Block_IntraFrameModeInfo;
struct Block_IntraFrameModeInfoDefaultTypeInternal;
extern Block_IntraFrameModeInfoDefaultTypeInternal _Block_IntraFrameModeInfo_default_instance_;
class CompressedHeader;
struct CompressedHeaderDefaultTypeInternal;
extern CompressedHeaderDefaultTypeInternal _CompressedHeader_default_instance_;
class Partition;
struct PartitionDefaultTypeInternal;
extern PartitionDefaultTypeInternal _Partition_default_instance_;
class Tile;
struct TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class UncompressedHeader;
struct UncompressedHeaderDefaultTypeInternal;
extern UncompressedHeaderDefaultTypeInternal _UncompressedHeader_default_instance_;
class UncompressedHeader_ColorConfig;
struct UncompressedHeader_ColorConfigDefaultTypeInternal;
extern UncompressedHeader_ColorConfigDefaultTypeInternal _UncompressedHeader_ColorConfig_default_instance_;
class UncompressedHeader_FrameSize;
struct UncompressedHeader_FrameSizeDefaultTypeInternal;
extern UncompressedHeader_FrameSizeDefaultTypeInternal _UncompressedHeader_FrameSize_default_instance_;
class UncompressedHeader_LoopFilterParams;
struct UncompressedHeader_LoopFilterParamsDefaultTypeInternal;
extern UncompressedHeader_LoopFilterParamsDefaultTypeInternal _UncompressedHeader_LoopFilterParams_default_instance_;
class UncompressedHeader_QuantizationParams;
struct UncompressedHeader_QuantizationParamsDefaultTypeInternal;
extern UncompressedHeader_QuantizationParamsDefaultTypeInternal _UncompressedHeader_QuantizationParams_default_instance_;
class UncompressedHeader_ReadInterpolationFilter;
struct UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal;
extern UncompressedHeader_ReadInterpolationFilterDefaultTypeInternal _UncompressedHeader_ReadInterpolationFilter_default_instance_;
class UncompressedHeader_RenderSize;
struct UncompressedHeader_RenderSizeDefaultTypeInternal;
extern UncompressedHeader_RenderSizeDefaultTypeInternal _UncompressedHeader_RenderSize_default_instance_;
class UncompressedHeader_SegmentationParams;
struct UncompressedHeader_SegmentationParamsDefaultTypeInternal;
extern UncompressedHeader_SegmentationParamsDefaultTypeInternal _UncompressedHeader_SegmentationParams_default_instance_;
class UncompressedHeader_TileInfo;
struct UncompressedHeader_TileInfoDefaultTypeInternal;
extern UncompressedHeader_TileInfoDefaultTypeInternal _UncompressedHeader_TileInfo_default_instance_;
class VP9Frame;
struct VP9FrameDefaultTypeInternal;
extern VP9FrameDefaultTypeInternal _VP9Frame_default_instance_;
class VP9SignedInteger;
struct VP9SignedIntegerDefaultTypeInternal;
extern VP9SignedIntegerDefaultTypeInternal _VP9SignedInteger_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::Block* Arena::CreateMaybeMessage<::Block>(Arena*);
template <>
::Block_InterFrameModeInfo* Arena::CreateMaybeMessage<::Block_InterFrameModeInfo>(Arena*);
template <>
::Block_IntraFrameModeInfo* Arena::CreateMaybeMessage<::Block_IntraFrameModeInfo>(Arena*);
template <>
::CompressedHeader* Arena::CreateMaybeMessage<::CompressedHeader>(Arena*);
template <>
::Partition* Arena::CreateMaybeMessage<::Partition>(Arena*);
template <>
::Tile* Arena::CreateMaybeMessage<::Tile>(Arena*);
template <>
::UncompressedHeader* Arena::CreateMaybeMessage<::UncompressedHeader>(Arena*);
template <>
::UncompressedHeader_ColorConfig* Arena::CreateMaybeMessage<::UncompressedHeader_ColorConfig>(Arena*);
template <>
::UncompressedHeader_FrameSize* Arena::CreateMaybeMessage<::UncompressedHeader_FrameSize>(Arena*);
template <>
::UncompressedHeader_LoopFilterParams* Arena::CreateMaybeMessage<::UncompressedHeader_LoopFilterParams>(Arena*);
template <>
::UncompressedHeader_QuantizationParams* Arena::CreateMaybeMessage<::UncompressedHeader_QuantizationParams>(Arena*);
template <>
::UncompressedHeader_ReadInterpolationFilter* Arena::CreateMaybeMessage<::UncompressedHeader_ReadInterpolationFilter>(Arena*);
template <>
::UncompressedHeader_RenderSize* Arena::CreateMaybeMessage<::UncompressedHeader_RenderSize>(Arena*);
template <>
::UncompressedHeader_SegmentationParams* Arena::CreateMaybeMessage<::UncompressedHeader_SegmentationParams>(Arena*);
template <>
::UncompressedHeader_TileInfo* Arena::CreateMaybeMessage<::UncompressedHeader_TileInfo>(Arena*);
template <>
::VP9Frame* Arena::CreateMaybeMessage<::VP9Frame>(Arena*);
template <>
::VP9SignedInteger* Arena::CreateMaybeMessage<::VP9SignedInteger>(Arena*);
PROTOBUF_NAMESPACE_CLOSE


// ===================================================================


// -------------------------------------------------------------------

class VP9SignedInteger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VP9SignedInteger) */ {
 public:
  inline VP9SignedInteger() : VP9SignedInteger(nullptr) {}
  ~VP9SignedInteger() override;
  explicit PROTOBUF_CONSTEXPR VP9SignedInteger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VP9SignedInteger(const VP9SignedInteger& from);
  VP9SignedInteger(VP9SignedInteger&& from) noexcept
    : VP9SignedInteger() {
    *this = ::std::move(from);
  }

  inline VP9SignedInteger& operator=(const VP9SignedInteger& from) {
    CopyFrom(from);
    return *this;
  }
  inline VP9SignedInteger& operator=(VP9SignedInteger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VP9SignedInteger& default_instance() {
    return *internal_default_instance();
  }
  static inline const VP9SignedInteger* internal_default_instance() {
    return reinterpret_cast<const VP9SignedInteger*>(
               &_VP9SignedInteger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VP9SignedInteger& a, VP9SignedInteger& b) {
    a.Swap(&b);
  }
  inline void Swap(VP9SignedInteger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VP9SignedInteger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VP9SignedInteger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VP9SignedInteger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VP9SignedInteger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VP9SignedInteger& from) {
    VP9SignedInteger::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VP9SignedInteger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "VP9SignedInteger";
  }
  protected:
  explicit VP9SignedInteger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kSignFieldNumber = 2,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 sign = 2;
  void clear_sign();
  uint32_t sign() const;
  void set_sign(uint32_t value);
  private:
  uint32_t _internal_sign() const;
  void _internal_set_sign(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VP9SignedInteger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    uint32_t sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_ColorConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.ColorConfig) */ {
 public:
  inline UncompressedHeader_ColorConfig() : UncompressedHeader_ColorConfig(nullptr) {}
  ~UncompressedHeader_ColorConfig() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_ColorConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_ColorConfig(const UncompressedHeader_ColorConfig& from);
  UncompressedHeader_ColorConfig(UncompressedHeader_ColorConfig&& from) noexcept
    : UncompressedHeader_ColorConfig() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_ColorConfig& operator=(const UncompressedHeader_ColorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_ColorConfig& operator=(UncompressedHeader_ColorConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_ColorConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_ColorConfig* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_ColorConfig*>(
               &_UncompressedHeader_ColorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UncompressedHeader_ColorConfig& a, UncompressedHeader_ColorConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_ColorConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_ColorConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_ColorConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_ColorConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_ColorConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_ColorConfig& from) {
    UncompressedHeader_ColorConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_ColorConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.ColorConfig";
  }
  protected:
  explicit UncompressedHeader_ColorConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTenOrTwelveBitFieldNumber = 1,
    kColorSpaceFieldNumber = 2,
    kColorRangeFieldNumber = 3,
    kSubsamplingXFieldNumber = 4,
    kSubsamplingYFieldNumber = 5,
    kReservedZeroFieldNumber = 6,
  };
  // uint32 ten_or_twelve_bit = 1;
  void clear_ten_or_twelve_bit();
  uint32_t ten_or_twelve_bit() const;
  void set_ten_or_twelve_bit(uint32_t value);
  private:
  uint32_t _internal_ten_or_twelve_bit() const;
  void _internal_set_ten_or_twelve_bit(uint32_t value);
  public:

  // uint32 color_space = 2;
  void clear_color_space();
  uint32_t color_space() const;
  void set_color_space(uint32_t value);
  private:
  uint32_t _internal_color_space() const;
  void _internal_set_color_space(uint32_t value);
  public:

  // uint32 color_range = 3;
  void clear_color_range();
  uint32_t color_range() const;
  void set_color_range(uint32_t value);
  private:
  uint32_t _internal_color_range() const;
  void _internal_set_color_range(uint32_t value);
  public:

  // uint32 subsampling_x = 4;
  void clear_subsampling_x();
  uint32_t subsampling_x() const;
  void set_subsampling_x(uint32_t value);
  private:
  uint32_t _internal_subsampling_x() const;
  void _internal_set_subsampling_x(uint32_t value);
  public:

  // uint32 subsampling_y = 5;
  void clear_subsampling_y();
  uint32_t subsampling_y() const;
  void set_subsampling_y(uint32_t value);
  private:
  uint32_t _internal_subsampling_y() const;
  void _internal_set_subsampling_y(uint32_t value);
  public:

  // uint32 reserved_zero = 6;
  void clear_reserved_zero();
  uint32_t reserved_zero() const;
  void set_reserved_zero(uint32_t value);
  private:
  uint32_t _internal_reserved_zero() const;
  void _internal_set_reserved_zero(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.ColorConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t ten_or_twelve_bit_;
    uint32_t color_space_;
    uint32_t color_range_;
    uint32_t subsampling_x_;
    uint32_t subsampling_y_;
    uint32_t reserved_zero_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_FrameSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.FrameSize) */ {
 public:
  inline UncompressedHeader_FrameSize() : UncompressedHeader_FrameSize(nullptr) {}
  ~UncompressedHeader_FrameSize() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_FrameSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_FrameSize(const UncompressedHeader_FrameSize& from);
  UncompressedHeader_FrameSize(UncompressedHeader_FrameSize&& from) noexcept
    : UncompressedHeader_FrameSize() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_FrameSize& operator=(const UncompressedHeader_FrameSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_FrameSize& operator=(UncompressedHeader_FrameSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_FrameSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_FrameSize* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_FrameSize*>(
               &_UncompressedHeader_FrameSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UncompressedHeader_FrameSize& a, UncompressedHeader_FrameSize& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_FrameSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_FrameSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_FrameSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_FrameSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_FrameSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_FrameSize& from) {
    UncompressedHeader_FrameSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_FrameSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.FrameSize";
  }
  protected:
  explicit UncompressedHeader_FrameSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameWidthMinus1FieldNumber = 1,
    kFrameHeightMinus1FieldNumber = 2,
  };
  // uint32 frame_width_minus_1 = 1;
  void clear_frame_width_minus_1();
  uint32_t frame_width_minus_1() const;
  void set_frame_width_minus_1(uint32_t value);
  private:
  uint32_t _internal_frame_width_minus_1() const;
  void _internal_set_frame_width_minus_1(uint32_t value);
  public:

  // uint32 frame_height_minus_1 = 2;
  void clear_frame_height_minus_1();
  uint32_t frame_height_minus_1() const;
  void set_frame_height_minus_1(uint32_t value);
  private:
  uint32_t _internal_frame_height_minus_1() const;
  void _internal_set_frame_height_minus_1(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.FrameSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t frame_width_minus_1_;
    uint32_t frame_height_minus_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_RenderSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.RenderSize) */ {
 public:
  inline UncompressedHeader_RenderSize() : UncompressedHeader_RenderSize(nullptr) {}
  ~UncompressedHeader_RenderSize() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_RenderSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_RenderSize(const UncompressedHeader_RenderSize& from);
  UncompressedHeader_RenderSize(UncompressedHeader_RenderSize&& from) noexcept
    : UncompressedHeader_RenderSize() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_RenderSize& operator=(const UncompressedHeader_RenderSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_RenderSize& operator=(UncompressedHeader_RenderSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_RenderSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_RenderSize* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_RenderSize*>(
               &_UncompressedHeader_RenderSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UncompressedHeader_RenderSize& a, UncompressedHeader_RenderSize& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_RenderSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_RenderSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_RenderSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_RenderSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_RenderSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_RenderSize& from) {
    UncompressedHeader_RenderSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_RenderSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.RenderSize";
  }
  protected:
  explicit UncompressedHeader_RenderSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRenderAndFrameSizeDifferentFieldNumber = 1,
    kRenderWidthMinus1FieldNumber = 2,
    kRenderHeightMinus1FieldNumber = 3,
  };
  // uint32 render_and_frame_size_different = 1;
  void clear_render_and_frame_size_different();
  uint32_t render_and_frame_size_different() const;
  void set_render_and_frame_size_different(uint32_t value);
  private:
  uint32_t _internal_render_and_frame_size_different() const;
  void _internal_set_render_and_frame_size_different(uint32_t value);
  public:

  // uint32 render_width_minus_1 = 2;
  void clear_render_width_minus_1();
  uint32_t render_width_minus_1() const;
  void set_render_width_minus_1(uint32_t value);
  private:
  uint32_t _internal_render_width_minus_1() const;
  void _internal_set_render_width_minus_1(uint32_t value);
  public:

  // uint32 render_height_minus_1 = 3;
  void clear_render_height_minus_1();
  uint32_t render_height_minus_1() const;
  void set_render_height_minus_1(uint32_t value);
  private:
  uint32_t _internal_render_height_minus_1() const;
  void _internal_set_render_height_minus_1(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.RenderSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t render_and_frame_size_different_;
    uint32_t render_width_minus_1_;
    uint32_t render_height_minus_1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_ReadInterpolationFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.ReadInterpolationFilter) */ {
 public:
  inline UncompressedHeader_ReadInterpolationFilter() : UncompressedHeader_ReadInterpolationFilter(nullptr) {}
  ~UncompressedHeader_ReadInterpolationFilter() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_ReadInterpolationFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_ReadInterpolationFilter(const UncompressedHeader_ReadInterpolationFilter& from);
  UncompressedHeader_ReadInterpolationFilter(UncompressedHeader_ReadInterpolationFilter&& from) noexcept
    : UncompressedHeader_ReadInterpolationFilter() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_ReadInterpolationFilter& operator=(const UncompressedHeader_ReadInterpolationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_ReadInterpolationFilter& operator=(UncompressedHeader_ReadInterpolationFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_ReadInterpolationFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_ReadInterpolationFilter* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_ReadInterpolationFilter*>(
               &_UncompressedHeader_ReadInterpolationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UncompressedHeader_ReadInterpolationFilter& a, UncompressedHeader_ReadInterpolationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_ReadInterpolationFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_ReadInterpolationFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_ReadInterpolationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_ReadInterpolationFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_ReadInterpolationFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_ReadInterpolationFilter& from) {
    UncompressedHeader_ReadInterpolationFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_ReadInterpolationFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.ReadInterpolationFilter";
  }
  protected:
  explicit UncompressedHeader_ReadInterpolationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsFilterSwitchableFieldNumber = 1,
    kRawInterpolationFilterFieldNumber = 2,
  };
  // uint32 is_filter_switchable = 1;
  void clear_is_filter_switchable();
  uint32_t is_filter_switchable() const;
  void set_is_filter_switchable(uint32_t value);
  private:
  uint32_t _internal_is_filter_switchable() const;
  void _internal_set_is_filter_switchable(uint32_t value);
  public:

  // uint32 raw_interpolation_filter = 2;
  void clear_raw_interpolation_filter();
  uint32_t raw_interpolation_filter() const;
  void set_raw_interpolation_filter(uint32_t value);
  private:
  uint32_t _internal_raw_interpolation_filter() const;
  void _internal_set_raw_interpolation_filter(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.ReadInterpolationFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t is_filter_switchable_;
    uint32_t raw_interpolation_filter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_LoopFilterParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.LoopFilterParams) */ {
 public:
  inline UncompressedHeader_LoopFilterParams() : UncompressedHeader_LoopFilterParams(nullptr) {}
  ~UncompressedHeader_LoopFilterParams() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_LoopFilterParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_LoopFilterParams(const UncompressedHeader_LoopFilterParams& from);
  UncompressedHeader_LoopFilterParams(UncompressedHeader_LoopFilterParams&& from) noexcept
    : UncompressedHeader_LoopFilterParams() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_LoopFilterParams& operator=(const UncompressedHeader_LoopFilterParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_LoopFilterParams& operator=(UncompressedHeader_LoopFilterParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_LoopFilterParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_LoopFilterParams* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_LoopFilterParams*>(
               &_UncompressedHeader_LoopFilterParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UncompressedHeader_LoopFilterParams& a, UncompressedHeader_LoopFilterParams& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_LoopFilterParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_LoopFilterParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_LoopFilterParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_LoopFilterParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_LoopFilterParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_LoopFilterParams& from) {
    UncompressedHeader_LoopFilterParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_LoopFilterParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.LoopFilterParams";
  }
  protected:
  explicit UncompressedHeader_LoopFilterParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoopFilterRefDeltasFieldNumber = 6,
    kLoopFilterModeDeltasFieldNumber = 8,
    kLoopFilterLevelFieldNumber = 1,
    kLoopFilterSharpnessFieldNumber = 2,
    kLoopFilterDeltaEnabledFieldNumber = 3,
    kLoopFilterDeltaUpdateFieldNumber = 4,
    kUpdateRefDeltaFieldNumber = 5,
    kUpdateModeDeltaFieldNumber = 7,
  };
  // .VP9SignedInteger loop_filter_ref_deltas = 6;
  bool has_loop_filter_ref_deltas() const;
  private:
  bool _internal_has_loop_filter_ref_deltas() const;
  public:
  void clear_loop_filter_ref_deltas();
  const ::VP9SignedInteger& loop_filter_ref_deltas() const;
  PROTOBUF_NODISCARD ::VP9SignedInteger* release_loop_filter_ref_deltas();
  ::VP9SignedInteger* mutable_loop_filter_ref_deltas();
  void set_allocated_loop_filter_ref_deltas(::VP9SignedInteger* loop_filter_ref_deltas);
  private:
  const ::VP9SignedInteger& _internal_loop_filter_ref_deltas() const;
  ::VP9SignedInteger* _internal_mutable_loop_filter_ref_deltas();
  public:
  void unsafe_arena_set_allocated_loop_filter_ref_deltas(
      ::VP9SignedInteger* loop_filter_ref_deltas);
  ::VP9SignedInteger* unsafe_arena_release_loop_filter_ref_deltas();

  // .VP9SignedInteger loop_filter_mode_deltas = 8;
  bool has_loop_filter_mode_deltas() const;
  private:
  bool _internal_has_loop_filter_mode_deltas() const;
  public:
  void clear_loop_filter_mode_deltas();
  const ::VP9SignedInteger& loop_filter_mode_deltas() const;
  PROTOBUF_NODISCARD ::VP9SignedInteger* release_loop_filter_mode_deltas();
  ::VP9SignedInteger* mutable_loop_filter_mode_deltas();
  void set_allocated_loop_filter_mode_deltas(::VP9SignedInteger* loop_filter_mode_deltas);
  private:
  const ::VP9SignedInteger& _internal_loop_filter_mode_deltas() const;
  ::VP9SignedInteger* _internal_mutable_loop_filter_mode_deltas();
  public:
  void unsafe_arena_set_allocated_loop_filter_mode_deltas(
      ::VP9SignedInteger* loop_filter_mode_deltas);
  ::VP9SignedInteger* unsafe_arena_release_loop_filter_mode_deltas();

  // uint32 loop_filter_level = 1;
  void clear_loop_filter_level();
  uint32_t loop_filter_level() const;
  void set_loop_filter_level(uint32_t value);
  private:
  uint32_t _internal_loop_filter_level() const;
  void _internal_set_loop_filter_level(uint32_t value);
  public:

  // uint32 loop_filter_sharpness = 2;
  void clear_loop_filter_sharpness();
  uint32_t loop_filter_sharpness() const;
  void set_loop_filter_sharpness(uint32_t value);
  private:
  uint32_t _internal_loop_filter_sharpness() const;
  void _internal_set_loop_filter_sharpness(uint32_t value);
  public:

  // uint32 loop_filter_delta_enabled = 3;
  void clear_loop_filter_delta_enabled();
  uint32_t loop_filter_delta_enabled() const;
  void set_loop_filter_delta_enabled(uint32_t value);
  private:
  uint32_t _internal_loop_filter_delta_enabled() const;
  void _internal_set_loop_filter_delta_enabled(uint32_t value);
  public:

  // uint32 loop_filter_delta_update = 4;
  void clear_loop_filter_delta_update();
  uint32_t loop_filter_delta_update() const;
  void set_loop_filter_delta_update(uint32_t value);
  private:
  uint32_t _internal_loop_filter_delta_update() const;
  void _internal_set_loop_filter_delta_update(uint32_t value);
  public:

  // uint32 update_ref_delta = 5;
  void clear_update_ref_delta();
  uint32_t update_ref_delta() const;
  void set_update_ref_delta(uint32_t value);
  private:
  uint32_t _internal_update_ref_delta() const;
  void _internal_set_update_ref_delta(uint32_t value);
  public:

  // uint32 update_mode_delta = 7;
  void clear_update_mode_delta();
  uint32_t update_mode_delta() const;
  void set_update_mode_delta(uint32_t value);
  private:
  uint32_t _internal_update_mode_delta() const;
  void _internal_set_update_mode_delta(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.LoopFilterParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::VP9SignedInteger* loop_filter_ref_deltas_;
    ::VP9SignedInteger* loop_filter_mode_deltas_;
    uint32_t loop_filter_level_;
    uint32_t loop_filter_sharpness_;
    uint32_t loop_filter_delta_enabled_;
    uint32_t loop_filter_delta_update_;
    uint32_t update_ref_delta_;
    uint32_t update_mode_delta_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_QuantizationParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.QuantizationParams) */ {
 public:
  inline UncompressedHeader_QuantizationParams() : UncompressedHeader_QuantizationParams(nullptr) {}
  ~UncompressedHeader_QuantizationParams() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_QuantizationParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_QuantizationParams(const UncompressedHeader_QuantizationParams& from);
  UncompressedHeader_QuantizationParams(UncompressedHeader_QuantizationParams&& from) noexcept
    : UncompressedHeader_QuantizationParams() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_QuantizationParams& operator=(const UncompressedHeader_QuantizationParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_QuantizationParams& operator=(UncompressedHeader_QuantizationParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_QuantizationParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_QuantizationParams* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_QuantizationParams*>(
               &_UncompressedHeader_QuantizationParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UncompressedHeader_QuantizationParams& a, UncompressedHeader_QuantizationParams& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_QuantizationParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_QuantizationParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_QuantizationParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_QuantizationParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_QuantizationParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_QuantizationParams& from) {
    UncompressedHeader_QuantizationParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_QuantizationParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.QuantizationParams";
  }
  protected:
  explicit UncompressedHeader_QuantizationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseQIdxFieldNumber = 1,
  };
  // uint32 base_q_idx = 1;
  void clear_base_q_idx();
  uint32_t base_q_idx() const;
  void set_base_q_idx(uint32_t value);
  private:
  uint32_t _internal_base_q_idx() const;
  void _internal_set_base_q_idx(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.QuantizationParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t base_q_idx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_SegmentationParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.SegmentationParams) */ {
 public:
  inline UncompressedHeader_SegmentationParams() : UncompressedHeader_SegmentationParams(nullptr) {}
  ~UncompressedHeader_SegmentationParams() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_SegmentationParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_SegmentationParams(const UncompressedHeader_SegmentationParams& from);
  UncompressedHeader_SegmentationParams(UncompressedHeader_SegmentationParams&& from) noexcept
    : UncompressedHeader_SegmentationParams() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_SegmentationParams& operator=(const UncompressedHeader_SegmentationParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_SegmentationParams& operator=(UncompressedHeader_SegmentationParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_SegmentationParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_SegmentationParams* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_SegmentationParams*>(
               &_UncompressedHeader_SegmentationParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UncompressedHeader_SegmentationParams& a, UncompressedHeader_SegmentationParams& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_SegmentationParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_SegmentationParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_SegmentationParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_SegmentationParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_SegmentationParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_SegmentationParams& from) {
    UncompressedHeader_SegmentationParams::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_SegmentationParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.SegmentationParams";
  }
  protected:
  explicit UncompressedHeader_SegmentationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureValueFieldNumber = 7,
    kSegmentationEnabledFieldNumber = 1,
    kSegmentationUpdateMapFieldNumber = 2,
    kSegmentationTemporalUpdateFieldNumber = 3,
    kSegmentationUpdateDataFieldNumber = 4,
    kSegmentationAbsOrDeltaUpdateFieldNumber = 5,
    kFeatureEnabledFieldNumber = 6,
    kFeatureSignFieldNumber = 8,
  };
  // bytes feature_value = 7;
  void clear_feature_value();
  const std::string& feature_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feature_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feature_value();
  PROTOBUF_NODISCARD std::string* release_feature_value();
  void set_allocated_feature_value(std::string* feature_value);
  private:
  const std::string& _internal_feature_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feature_value(const std::string& value);
  std::string* _internal_mutable_feature_value();
  public:

  // uint32 segmentation_enabled = 1;
  void clear_segmentation_enabled();
  uint32_t segmentation_enabled() const;
  void set_segmentation_enabled(uint32_t value);
  private:
  uint32_t _internal_segmentation_enabled() const;
  void _internal_set_segmentation_enabled(uint32_t value);
  public:

  // uint32 segmentation_update_map = 2;
  void clear_segmentation_update_map();
  uint32_t segmentation_update_map() const;
  void set_segmentation_update_map(uint32_t value);
  private:
  uint32_t _internal_segmentation_update_map() const;
  void _internal_set_segmentation_update_map(uint32_t value);
  public:

  // uint32 segmentation_temporal_update = 3;
  void clear_segmentation_temporal_update();
  uint32_t segmentation_temporal_update() const;
  void set_segmentation_temporal_update(uint32_t value);
  private:
  uint32_t _internal_segmentation_temporal_update() const;
  void _internal_set_segmentation_temporal_update(uint32_t value);
  public:

  // uint32 segmentation_update_data = 4;
  void clear_segmentation_update_data();
  uint32_t segmentation_update_data() const;
  void set_segmentation_update_data(uint32_t value);
  private:
  uint32_t _internal_segmentation_update_data() const;
  void _internal_set_segmentation_update_data(uint32_t value);
  public:

  // uint32 segmentation_abs_or_delta_update = 5;
  void clear_segmentation_abs_or_delta_update();
  uint32_t segmentation_abs_or_delta_update() const;
  void set_segmentation_abs_or_delta_update(uint32_t value);
  private:
  uint32_t _internal_segmentation_abs_or_delta_update() const;
  void _internal_set_segmentation_abs_or_delta_update(uint32_t value);
  public:

  // uint32 feature_enabled = 6;
  void clear_feature_enabled();
  uint32_t feature_enabled() const;
  void set_feature_enabled(uint32_t value);
  private:
  uint32_t _internal_feature_enabled() const;
  void _internal_set_feature_enabled(uint32_t value);
  public:

  // uint32 feature_sign = 8;
  void clear_feature_sign();
  uint32_t feature_sign() const;
  void set_feature_sign(uint32_t value);
  private:
  uint32_t _internal_feature_sign() const;
  void _internal_set_feature_sign(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.SegmentationParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_value_;
    uint32_t segmentation_enabled_;
    uint32_t segmentation_update_map_;
    uint32_t segmentation_temporal_update_;
    uint32_t segmentation_update_data_;
    uint32_t segmentation_abs_or_delta_update_;
    uint32_t feature_enabled_;
    uint32_t feature_sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader_TileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader.TileInfo) */ {
 public:
  inline UncompressedHeader_TileInfo() : UncompressedHeader_TileInfo(nullptr) {}
  ~UncompressedHeader_TileInfo() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader_TileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader_TileInfo(const UncompressedHeader_TileInfo& from);
  UncompressedHeader_TileInfo(UncompressedHeader_TileInfo&& from) noexcept
    : UncompressedHeader_TileInfo() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader_TileInfo& operator=(const UncompressedHeader_TileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader_TileInfo& operator=(UncompressedHeader_TileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader_TileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader_TileInfo* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader_TileInfo*>(
               &_UncompressedHeader_TileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UncompressedHeader_TileInfo& a, UncompressedHeader_TileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader_TileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader_TileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader_TileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader_TileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader_TileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader_TileInfo& from) {
    UncompressedHeader_TileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader_TileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader.TileInfo";
  }
  protected:
  explicit UncompressedHeader_TileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncrementTileColsLog2FieldNumber = 1,
    kTileRowsLog2FieldNumber = 2,
    kIncrementTileRowsLog2FieldNumber = 3,
  };
  // uint32 increment_tile_cols_log2 = 1;
  void clear_increment_tile_cols_log2();
  uint32_t increment_tile_cols_log2() const;
  void set_increment_tile_cols_log2(uint32_t value);
  private:
  uint32_t _internal_increment_tile_cols_log2() const;
  void _internal_set_increment_tile_cols_log2(uint32_t value);
  public:

  // uint32 tile_rows_log2 = 2;
  void clear_tile_rows_log2();
  uint32_t tile_rows_log2() const;
  void set_tile_rows_log2(uint32_t value);
  private:
  uint32_t _internal_tile_rows_log2() const;
  void _internal_set_tile_rows_log2(uint32_t value);
  public:

  // uint32 increment_tile_rows_Log2 = 3;
  void clear_increment_tile_rows_log2();
  uint32_t increment_tile_rows_log2() const;
  void set_increment_tile_rows_log2(uint32_t value);
  private:
  uint32_t _internal_increment_tile_rows_log2() const;
  void _internal_set_increment_tile_rows_log2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader.TileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t increment_tile_cols_log2_;
    uint32_t tile_rows_log2_;
    uint32_t increment_tile_rows_log2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class UncompressedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UncompressedHeader) */ {
 public:
  inline UncompressedHeader() : UncompressedHeader(nullptr) {}
  ~UncompressedHeader() override;
  explicit PROTOBUF_CONSTEXPR UncompressedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UncompressedHeader(const UncompressedHeader& from);
  UncompressedHeader(UncompressedHeader&& from) noexcept
    : UncompressedHeader() {
    *this = ::std::move(from);
  }

  inline UncompressedHeader& operator=(const UncompressedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline UncompressedHeader& operator=(UncompressedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UncompressedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const UncompressedHeader* internal_default_instance() {
    return reinterpret_cast<const UncompressedHeader*>(
               &_UncompressedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UncompressedHeader& a, UncompressedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(UncompressedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UncompressedHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UncompressedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UncompressedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UncompressedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UncompressedHeader& from) {
    UncompressedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UncompressedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UncompressedHeader";
  }
  protected:
  explicit UncompressedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UncompressedHeader_ColorConfig ColorConfig;
  typedef UncompressedHeader_FrameSize FrameSize;
  typedef UncompressedHeader_RenderSize RenderSize;
  typedef UncompressedHeader_ReadInterpolationFilter ReadInterpolationFilter;
  typedef UncompressedHeader_LoopFilterParams LoopFilterParams;
  typedef UncompressedHeader_QuantizationParams QuantizationParams;
  typedef UncompressedHeader_SegmentationParams SegmentationParams;
  typedef UncompressedHeader_TileInfo TileInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kColorConfigFieldNumber = 10,
    kFrameSizeFieldNumber = 12,
    kRenderSizeFieldNumber = 13,
    kReadInterpolationFilterFieldNumber = 20,
    kLoopFilterParamsFieldNumber = 23,
    kQuantizationParamsFieldNumber = 24,
    kSegmentationParamsFieldNumber = 25,
    kTileInfoFieldNumber = 26,
    kMarkerFieldNumber = 1,
    kProfileFieldNumber = 2,
    kReservedZeroFieldNumber = 3,
    kShowExistingFrameFieldNumber = 4,
    kFrameToShowMapIdxFieldNumber = 5,
    kFrameTypeFieldNumber = 6,
    kShowFrameFieldNumber = 7,
    kErrorResilientModeFieldNumber = 8,
    kFrameSyncCodeFieldNumber = 9,
    kFrameSizeFoundRefFieldNumber = 11,
    kIntraOnlyFieldNumber = 14,
    kResetFrameContextFieldNumber = 15,
    kRefreshFrameFlagsFieldNumber = 16,
    kRefFrameIdxFieldNumber = 17,
    kRefFrameSignBiasFieldNumber = 18,
    kAllowHighPrecisionMvFieldNumber = 19,
    kFrameParallelDecodingModeFieldNumber = 21,
    kFrameContextIdxFieldNumber = 22,
    kHeaderSizeInBytesFieldNumber = 27,
  };
  // .UncompressedHeader.ColorConfig color_config = 10;
  bool has_color_config() const;
  private:
  bool _internal_has_color_config() const;
  public:
  void clear_color_config();
  const ::UncompressedHeader_ColorConfig& color_config() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_ColorConfig* release_color_config();
  ::UncompressedHeader_ColorConfig* mutable_color_config();
  void set_allocated_color_config(::UncompressedHeader_ColorConfig* color_config);
  private:
  const ::UncompressedHeader_ColorConfig& _internal_color_config() const;
  ::UncompressedHeader_ColorConfig* _internal_mutable_color_config();
  public:
  void unsafe_arena_set_allocated_color_config(
      ::UncompressedHeader_ColorConfig* color_config);
  ::UncompressedHeader_ColorConfig* unsafe_arena_release_color_config();

  // .UncompressedHeader.FrameSize frame_size = 12;
  bool has_frame_size() const;
  private:
  bool _internal_has_frame_size() const;
  public:
  void clear_frame_size();
  const ::UncompressedHeader_FrameSize& frame_size() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_FrameSize* release_frame_size();
  ::UncompressedHeader_FrameSize* mutable_frame_size();
  void set_allocated_frame_size(::UncompressedHeader_FrameSize* frame_size);
  private:
  const ::UncompressedHeader_FrameSize& _internal_frame_size() const;
  ::UncompressedHeader_FrameSize* _internal_mutable_frame_size();
  public:
  void unsafe_arena_set_allocated_frame_size(
      ::UncompressedHeader_FrameSize* frame_size);
  ::UncompressedHeader_FrameSize* unsafe_arena_release_frame_size();

  // .UncompressedHeader.RenderSize render_size = 13;
  bool has_render_size() const;
  private:
  bool _internal_has_render_size() const;
  public:
  void clear_render_size();
  const ::UncompressedHeader_RenderSize& render_size() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_RenderSize* release_render_size();
  ::UncompressedHeader_RenderSize* mutable_render_size();
  void set_allocated_render_size(::UncompressedHeader_RenderSize* render_size);
  private:
  const ::UncompressedHeader_RenderSize& _internal_render_size() const;
  ::UncompressedHeader_RenderSize* _internal_mutable_render_size();
  public:
  void unsafe_arena_set_allocated_render_size(
      ::UncompressedHeader_RenderSize* render_size);
  ::UncompressedHeader_RenderSize* unsafe_arena_release_render_size();

  // .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
  bool has_read_interpolation_filter() const;
  private:
  bool _internal_has_read_interpolation_filter() const;
  public:
  void clear_read_interpolation_filter();
  const ::UncompressedHeader_ReadInterpolationFilter& read_interpolation_filter() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_ReadInterpolationFilter* release_read_interpolation_filter();
  ::UncompressedHeader_ReadInterpolationFilter* mutable_read_interpolation_filter();
  void set_allocated_read_interpolation_filter(::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter);
  private:
  const ::UncompressedHeader_ReadInterpolationFilter& _internal_read_interpolation_filter() const;
  ::UncompressedHeader_ReadInterpolationFilter* _internal_mutable_read_interpolation_filter();
  public:
  void unsafe_arena_set_allocated_read_interpolation_filter(
      ::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter);
  ::UncompressedHeader_ReadInterpolationFilter* unsafe_arena_release_read_interpolation_filter();

  // .UncompressedHeader.LoopFilterParams loop_filter_params = 23;
  bool has_loop_filter_params() const;
  private:
  bool _internal_has_loop_filter_params() const;
  public:
  void clear_loop_filter_params();
  const ::UncompressedHeader_LoopFilterParams& loop_filter_params() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_LoopFilterParams* release_loop_filter_params();
  ::UncompressedHeader_LoopFilterParams* mutable_loop_filter_params();
  void set_allocated_loop_filter_params(::UncompressedHeader_LoopFilterParams* loop_filter_params);
  private:
  const ::UncompressedHeader_LoopFilterParams& _internal_loop_filter_params() const;
  ::UncompressedHeader_LoopFilterParams* _internal_mutable_loop_filter_params();
  public:
  void unsafe_arena_set_allocated_loop_filter_params(
      ::UncompressedHeader_LoopFilterParams* loop_filter_params);
  ::UncompressedHeader_LoopFilterParams* unsafe_arena_release_loop_filter_params();

  // .UncompressedHeader.QuantizationParams quantization_params = 24;
  bool has_quantization_params() const;
  private:
  bool _internal_has_quantization_params() const;
  public:
  void clear_quantization_params();
  const ::UncompressedHeader_QuantizationParams& quantization_params() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_QuantizationParams* release_quantization_params();
  ::UncompressedHeader_QuantizationParams* mutable_quantization_params();
  void set_allocated_quantization_params(::UncompressedHeader_QuantizationParams* quantization_params);
  private:
  const ::UncompressedHeader_QuantizationParams& _internal_quantization_params() const;
  ::UncompressedHeader_QuantizationParams* _internal_mutable_quantization_params();
  public:
  void unsafe_arena_set_allocated_quantization_params(
      ::UncompressedHeader_QuantizationParams* quantization_params);
  ::UncompressedHeader_QuantizationParams* unsafe_arena_release_quantization_params();

  // .UncompressedHeader.SegmentationParams segmentation_params = 25;
  bool has_segmentation_params() const;
  private:
  bool _internal_has_segmentation_params() const;
  public:
  void clear_segmentation_params();
  const ::UncompressedHeader_SegmentationParams& segmentation_params() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_SegmentationParams* release_segmentation_params();
  ::UncompressedHeader_SegmentationParams* mutable_segmentation_params();
  void set_allocated_segmentation_params(::UncompressedHeader_SegmentationParams* segmentation_params);
  private:
  const ::UncompressedHeader_SegmentationParams& _internal_segmentation_params() const;
  ::UncompressedHeader_SegmentationParams* _internal_mutable_segmentation_params();
  public:
  void unsafe_arena_set_allocated_segmentation_params(
      ::UncompressedHeader_SegmentationParams* segmentation_params);
  ::UncompressedHeader_SegmentationParams* unsafe_arena_release_segmentation_params();

  // .UncompressedHeader.TileInfo tile_info = 26;
  bool has_tile_info() const;
  private:
  bool _internal_has_tile_info() const;
  public:
  void clear_tile_info();
  const ::UncompressedHeader_TileInfo& tile_info() const;
  PROTOBUF_NODISCARD ::UncompressedHeader_TileInfo* release_tile_info();
  ::UncompressedHeader_TileInfo* mutable_tile_info();
  void set_allocated_tile_info(::UncompressedHeader_TileInfo* tile_info);
  private:
  const ::UncompressedHeader_TileInfo& _internal_tile_info() const;
  ::UncompressedHeader_TileInfo* _internal_mutable_tile_info();
  public:
  void unsafe_arena_set_allocated_tile_info(
      ::UncompressedHeader_TileInfo* tile_info);
  ::UncompressedHeader_TileInfo* unsafe_arena_release_tile_info();

  // uint32 marker = 1;
  void clear_marker();
  uint32_t marker() const;
  void set_marker(uint32_t value);
  private:
  uint32_t _internal_marker() const;
  void _internal_set_marker(uint32_t value);
  public:

  // uint32 profile = 2;
  void clear_profile();
  uint32_t profile() const;
  void set_profile(uint32_t value);
  private:
  uint32_t _internal_profile() const;
  void _internal_set_profile(uint32_t value);
  public:

  // uint32 reserved_zero = 3;
  void clear_reserved_zero();
  uint32_t reserved_zero() const;
  void set_reserved_zero(uint32_t value);
  private:
  uint32_t _internal_reserved_zero() const;
  void _internal_set_reserved_zero(uint32_t value);
  public:

  // uint32 show_existing_frame = 4;
  void clear_show_existing_frame();
  uint32_t show_existing_frame() const;
  void set_show_existing_frame(uint32_t value);
  private:
  uint32_t _internal_show_existing_frame() const;
  void _internal_set_show_existing_frame(uint32_t value);
  public:

  // uint32 frame_to_show_map_idx = 5;
  void clear_frame_to_show_map_idx();
  uint32_t frame_to_show_map_idx() const;
  void set_frame_to_show_map_idx(uint32_t value);
  private:
  uint32_t _internal_frame_to_show_map_idx() const;
  void _internal_set_frame_to_show_map_idx(uint32_t value);
  public:

  // uint32 frame_type = 6;
  void clear_frame_type();
  uint32_t frame_type() const;
  void set_frame_type(uint32_t value);
  private:
  uint32_t _internal_frame_type() const;
  void _internal_set_frame_type(uint32_t value);
  public:

  // uint32 show_frame = 7;
  void clear_show_frame();
  uint32_t show_frame() const;
  void set_show_frame(uint32_t value);
  private:
  uint32_t _internal_show_frame() const;
  void _internal_set_show_frame(uint32_t value);
  public:

  // uint32 error_resilient_mode = 8;
  void clear_error_resilient_mode();
  uint32_t error_resilient_mode() const;
  void set_error_resilient_mode(uint32_t value);
  private:
  uint32_t _internal_error_resilient_mode() const;
  void _internal_set_error_resilient_mode(uint32_t value);
  public:

  // uint32 frame_sync_code = 9;
  void clear_frame_sync_code();
  uint32_t frame_sync_code() const;
  void set_frame_sync_code(uint32_t value);
  private:
  uint32_t _internal_frame_sync_code() const;
  void _internal_set_frame_sync_code(uint32_t value);
  public:

  // uint32 frame_size_found_ref = 11;
  void clear_frame_size_found_ref();
  uint32_t frame_size_found_ref() const;
  void set_frame_size_found_ref(uint32_t value);
  private:
  uint32_t _internal_frame_size_found_ref() const;
  void _internal_set_frame_size_found_ref(uint32_t value);
  public:

  // uint32 intra_only = 14;
  void clear_intra_only();
  uint32_t intra_only() const;
  void set_intra_only(uint32_t value);
  private:
  uint32_t _internal_intra_only() const;
  void _internal_set_intra_only(uint32_t value);
  public:

  // uint32 reset_frame_context = 15;
  void clear_reset_frame_context();
  uint32_t reset_frame_context() const;
  void set_reset_frame_context(uint32_t value);
  private:
  uint32_t _internal_reset_frame_context() const;
  void _internal_set_reset_frame_context(uint32_t value);
  public:

  // uint32 refresh_frame_flags = 16;
  void clear_refresh_frame_flags();
  uint32_t refresh_frame_flags() const;
  void set_refresh_frame_flags(uint32_t value);
  private:
  uint32_t _internal_refresh_frame_flags() const;
  void _internal_set_refresh_frame_flags(uint32_t value);
  public:

  // uint32 ref_frame_idx = 17;
  void clear_ref_frame_idx();
  uint32_t ref_frame_idx() const;
  void set_ref_frame_idx(uint32_t value);
  private:
  uint32_t _internal_ref_frame_idx() const;
  void _internal_set_ref_frame_idx(uint32_t value);
  public:

  // uint32 ref_frame_sign_bias = 18;
  void clear_ref_frame_sign_bias();
  uint32_t ref_frame_sign_bias() const;
  void set_ref_frame_sign_bias(uint32_t value);
  private:
  uint32_t _internal_ref_frame_sign_bias() const;
  void _internal_set_ref_frame_sign_bias(uint32_t value);
  public:

  // uint32 allow_high_precision_mv = 19;
  void clear_allow_high_precision_mv();
  uint32_t allow_high_precision_mv() const;
  void set_allow_high_precision_mv(uint32_t value);
  private:
  uint32_t _internal_allow_high_precision_mv() const;
  void _internal_set_allow_high_precision_mv(uint32_t value);
  public:

  // uint32 frame_parallel_decoding_mode = 21;
  void clear_frame_parallel_decoding_mode();
  uint32_t frame_parallel_decoding_mode() const;
  void set_frame_parallel_decoding_mode(uint32_t value);
  private:
  uint32_t _internal_frame_parallel_decoding_mode() const;
  void _internal_set_frame_parallel_decoding_mode(uint32_t value);
  public:

  // uint32 frame_context_idx = 22;
  void clear_frame_context_idx();
  uint32_t frame_context_idx() const;
  void set_frame_context_idx(uint32_t value);
  private:
  uint32_t _internal_frame_context_idx() const;
  void _internal_set_frame_context_idx(uint32_t value);
  public:

  // uint32 header_size_in_bytes = 27;
  void clear_header_size_in_bytes();
  uint32_t header_size_in_bytes() const;
  void set_header_size_in_bytes(uint32_t value);
  private:
  uint32_t _internal_header_size_in_bytes() const;
  void _internal_set_header_size_in_bytes(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UncompressedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::UncompressedHeader_ColorConfig* color_config_;
    ::UncompressedHeader_FrameSize* frame_size_;
    ::UncompressedHeader_RenderSize* render_size_;
    ::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter_;
    ::UncompressedHeader_LoopFilterParams* loop_filter_params_;
    ::UncompressedHeader_QuantizationParams* quantization_params_;
    ::UncompressedHeader_SegmentationParams* segmentation_params_;
    ::UncompressedHeader_TileInfo* tile_info_;
    uint32_t marker_;
    uint32_t profile_;
    uint32_t reserved_zero_;
    uint32_t show_existing_frame_;
    uint32_t frame_to_show_map_idx_;
    uint32_t frame_type_;
    uint32_t show_frame_;
    uint32_t error_resilient_mode_;
    uint32_t frame_sync_code_;
    uint32_t frame_size_found_ref_;
    uint32_t intra_only_;
    uint32_t reset_frame_context_;
    uint32_t refresh_frame_flags_;
    uint32_t ref_frame_idx_;
    uint32_t ref_frame_sign_bias_;
    uint32_t allow_high_precision_mv_;
    uint32_t frame_parallel_decoding_mode_;
    uint32_t frame_context_idx_;
    uint32_t header_size_in_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class CompressedHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CompressedHeader) */ {
 public:
  inline CompressedHeader() : CompressedHeader(nullptr) {}
  ~CompressedHeader() override;
  explicit PROTOBUF_CONSTEXPR CompressedHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompressedHeader(const CompressedHeader& from);
  CompressedHeader(CompressedHeader&& from) noexcept
    : CompressedHeader() {
    *this = ::std::move(from);
  }

  inline CompressedHeader& operator=(const CompressedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompressedHeader& operator=(CompressedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompressedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompressedHeader* internal_default_instance() {
    return reinterpret_cast<const CompressedHeader*>(
               &_CompressedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CompressedHeader& a, CompressedHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CompressedHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompressedHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompressedHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompressedHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompressedHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompressedHeader& from) {
    CompressedHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompressedHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CompressedHeader";
  }
  protected:
  explicit CompressedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadTxModeFieldNumber = 1,
    kTxModeProbsFieldNumber = 2,
    kReadCoefProbsFieldNumber = 3,
    kReadSkipProbFieldNumber = 4,
    kReadInterModeProbsFieldNumber = 5,
    kReadInterpFilterProbsFieldNumber = 6,
    kReadIsInterProbsFieldNumber = 7,
    kFrameReferenceModeFieldNumber = 8,
    kFrameReferenceModeProbsFieldNumber = 9,
    kReadYModeProbsFieldNumber = 10,
    kReadPartitionProbsFieldNumber = 11,
    kMvProbsFieldNumber = 12,
  };
  // bytes read_tx_mode = 1;
  void clear_read_tx_mode();
  const std::string& read_tx_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_tx_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_tx_mode();
  PROTOBUF_NODISCARD std::string* release_read_tx_mode();
  void set_allocated_read_tx_mode(std::string* read_tx_mode);
  private:
  const std::string& _internal_read_tx_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_tx_mode(const std::string& value);
  std::string* _internal_mutable_read_tx_mode();
  public:

  // bytes tx_mode_probs = 2;
  void clear_tx_mode_probs();
  const std::string& tx_mode_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_mode_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_mode_probs();
  PROTOBUF_NODISCARD std::string* release_tx_mode_probs();
  void set_allocated_tx_mode_probs(std::string* tx_mode_probs);
  private:
  const std::string& _internal_tx_mode_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_mode_probs(const std::string& value);
  std::string* _internal_mutable_tx_mode_probs();
  public:

  // bytes read_coef_probs = 3;
  void clear_read_coef_probs();
  const std::string& read_coef_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_coef_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_coef_probs();
  PROTOBUF_NODISCARD std::string* release_read_coef_probs();
  void set_allocated_read_coef_probs(std::string* read_coef_probs);
  private:
  const std::string& _internal_read_coef_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_coef_probs(const std::string& value);
  std::string* _internal_mutable_read_coef_probs();
  public:

  // bytes read_skip_prob = 4;
  void clear_read_skip_prob();
  const std::string& read_skip_prob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_skip_prob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_skip_prob();
  PROTOBUF_NODISCARD std::string* release_read_skip_prob();
  void set_allocated_read_skip_prob(std::string* read_skip_prob);
  private:
  const std::string& _internal_read_skip_prob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_skip_prob(const std::string& value);
  std::string* _internal_mutable_read_skip_prob();
  public:

  // bytes read_inter_mode_probs = 5;
  void clear_read_inter_mode_probs();
  const std::string& read_inter_mode_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_inter_mode_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_inter_mode_probs();
  PROTOBUF_NODISCARD std::string* release_read_inter_mode_probs();
  void set_allocated_read_inter_mode_probs(std::string* read_inter_mode_probs);
  private:
  const std::string& _internal_read_inter_mode_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_inter_mode_probs(const std::string& value);
  std::string* _internal_mutable_read_inter_mode_probs();
  public:

  // bytes read_interp_filter_probs = 6;
  void clear_read_interp_filter_probs();
  const std::string& read_interp_filter_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_interp_filter_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_interp_filter_probs();
  PROTOBUF_NODISCARD std::string* release_read_interp_filter_probs();
  void set_allocated_read_interp_filter_probs(std::string* read_interp_filter_probs);
  private:
  const std::string& _internal_read_interp_filter_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_interp_filter_probs(const std::string& value);
  std::string* _internal_mutable_read_interp_filter_probs();
  public:

  // bytes read_is_inter_probs = 7;
  void clear_read_is_inter_probs();
  const std::string& read_is_inter_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_is_inter_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_is_inter_probs();
  PROTOBUF_NODISCARD std::string* release_read_is_inter_probs();
  void set_allocated_read_is_inter_probs(std::string* read_is_inter_probs);
  private:
  const std::string& _internal_read_is_inter_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_is_inter_probs(const std::string& value);
  std::string* _internal_mutable_read_is_inter_probs();
  public:

  // bytes frame_reference_mode = 8;
  void clear_frame_reference_mode();
  const std::string& frame_reference_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_reference_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_reference_mode();
  PROTOBUF_NODISCARD std::string* release_frame_reference_mode();
  void set_allocated_frame_reference_mode(std::string* frame_reference_mode);
  private:
  const std::string& _internal_frame_reference_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_reference_mode(const std::string& value);
  std::string* _internal_mutable_frame_reference_mode();
  public:

  // bytes frame_reference_mode_probs = 9;
  void clear_frame_reference_mode_probs();
  const std::string& frame_reference_mode_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame_reference_mode_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame_reference_mode_probs();
  PROTOBUF_NODISCARD std::string* release_frame_reference_mode_probs();
  void set_allocated_frame_reference_mode_probs(std::string* frame_reference_mode_probs);
  private:
  const std::string& _internal_frame_reference_mode_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_reference_mode_probs(const std::string& value);
  std::string* _internal_mutable_frame_reference_mode_probs();
  public:

  // bytes read_y_mode_probs = 10;
  void clear_read_y_mode_probs();
  const std::string& read_y_mode_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_y_mode_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_y_mode_probs();
  PROTOBUF_NODISCARD std::string* release_read_y_mode_probs();
  void set_allocated_read_y_mode_probs(std::string* read_y_mode_probs);
  private:
  const std::string& _internal_read_y_mode_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_y_mode_probs(const std::string& value);
  std::string* _internal_mutable_read_y_mode_probs();
  public:

  // bytes read_partition_probs = 11;
  void clear_read_partition_probs();
  const std::string& read_partition_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_partition_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_partition_probs();
  PROTOBUF_NODISCARD std::string* release_read_partition_probs();
  void set_allocated_read_partition_probs(std::string* read_partition_probs);
  private:
  const std::string& _internal_read_partition_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_partition_probs(const std::string& value);
  std::string* _internal_mutable_read_partition_probs();
  public:

  // bytes mv_probs = 12;
  void clear_mv_probs();
  const std::string& mv_probs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mv_probs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mv_probs();
  PROTOBUF_NODISCARD std::string* release_mv_probs();
  void set_allocated_mv_probs(std::string* mv_probs);
  private:
  const std::string& _internal_mv_probs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mv_probs(const std::string& value);
  std::string* _internal_mutable_mv_probs();
  public:

  // @@protoc_insertion_point(class_scope:CompressedHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_tx_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_mode_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_coef_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_skip_prob_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_inter_mode_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_interp_filter_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_is_inter_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_reference_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_reference_mode_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_y_mode_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_partition_probs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mv_probs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class Block_IntraFrameModeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Block.IntraFrameModeInfo) */ {
 public:
  inline Block_IntraFrameModeInfo() : Block_IntraFrameModeInfo(nullptr) {}
  ~Block_IntraFrameModeInfo() override;
  explicit PROTOBUF_CONSTEXPR Block_IntraFrameModeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block_IntraFrameModeInfo(const Block_IntraFrameModeInfo& from);
  Block_IntraFrameModeInfo(Block_IntraFrameModeInfo&& from) noexcept
    : Block_IntraFrameModeInfo() {
    *this = ::std::move(from);
  }

  inline Block_IntraFrameModeInfo& operator=(const Block_IntraFrameModeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block_IntraFrameModeInfo& operator=(Block_IntraFrameModeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block_IntraFrameModeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block_IntraFrameModeInfo* internal_default_instance() {
    return reinterpret_cast<const Block_IntraFrameModeInfo*>(
               &_Block_IntraFrameModeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Block_IntraFrameModeInfo& a, Block_IntraFrameModeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Block_IntraFrameModeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block_IntraFrameModeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block_IntraFrameModeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Block_IntraFrameModeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block_IntraFrameModeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Block_IntraFrameModeInfo& from) {
    Block_IntraFrameModeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block_IntraFrameModeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Block.IntraFrameModeInfo";
  }
  protected:
  explicit Block_IntraFrameModeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentIdFieldNumber = 1,
    kSkipFieldNumber = 2,
    kTxSizeFieldNumber = 3,
    kDefaultIntraModeFieldNumber = 4,
    kDefaultUvModeFieldNumber = 5,
  };
  // bytes segment_id = 1;
  void clear_segment_id();
  const std::string& segment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* segment_id);
  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(const std::string& value);
  std::string* _internal_mutable_segment_id();
  public:

  // bytes skip = 2;
  void clear_skip();
  const std::string& skip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skip();
  PROTOBUF_NODISCARD std::string* release_skip();
  void set_allocated_skip(std::string* skip);
  private:
  const std::string& _internal_skip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skip(const std::string& value);
  std::string* _internal_mutable_skip();
  public:

  // bytes tx_size = 3;
  void clear_tx_size();
  const std::string& tx_size() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_size(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_size();
  PROTOBUF_NODISCARD std::string* release_tx_size();
  void set_allocated_tx_size(std::string* tx_size);
  private:
  const std::string& _internal_tx_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_size(const std::string& value);
  std::string* _internal_mutable_tx_size();
  public:

  // bytes default_intra_mode = 4;
  void clear_default_intra_mode();
  const std::string& default_intra_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_intra_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_intra_mode();
  PROTOBUF_NODISCARD std::string* release_default_intra_mode();
  void set_allocated_default_intra_mode(std::string* default_intra_mode);
  private:
  const std::string& _internal_default_intra_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_intra_mode(const std::string& value);
  std::string* _internal_mutable_default_intra_mode();
  public:

  // bytes default_uv_mode = 5;
  void clear_default_uv_mode();
  const std::string& default_uv_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_uv_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_uv_mode();
  PROTOBUF_NODISCARD std::string* release_default_uv_mode();
  void set_allocated_default_uv_mode(std::string* default_uv_mode);
  private:
  const std::string& _internal_default_uv_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_uv_mode(const std::string& value);
  std::string* _internal_mutable_default_uv_mode();
  public:

  // @@protoc_insertion_point(class_scope:Block.IntraFrameModeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_intra_mode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_uv_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class Block_InterFrameModeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Block.InterFrameModeInfo) */ {
 public:
  inline Block_InterFrameModeInfo() : Block_InterFrameModeInfo(nullptr) {}
  ~Block_InterFrameModeInfo() override;
  explicit PROTOBUF_CONSTEXPR Block_InterFrameModeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block_InterFrameModeInfo(const Block_InterFrameModeInfo& from);
  Block_InterFrameModeInfo(Block_InterFrameModeInfo&& from) noexcept
    : Block_InterFrameModeInfo() {
    *this = ::std::move(from);
  }

  inline Block_InterFrameModeInfo& operator=(const Block_InterFrameModeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block_InterFrameModeInfo& operator=(Block_InterFrameModeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block_InterFrameModeInfo& default_instance() {
    return *internal_default_instance();
  }
  enum NextFrameCase {
    kIntraFrame = 5,
    kInterFrame = 6,
    NEXT_FRAME_NOT_SET = 0,
  };

  static inline const Block_InterFrameModeInfo* internal_default_instance() {
    return reinterpret_cast<const Block_InterFrameModeInfo*>(
               &_Block_InterFrameModeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Block_InterFrameModeInfo& a, Block_InterFrameModeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Block_InterFrameModeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block_InterFrameModeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block_InterFrameModeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Block_InterFrameModeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block_InterFrameModeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Block_InterFrameModeInfo& from) {
    Block_InterFrameModeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block_InterFrameModeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Block.InterFrameModeInfo";
  }
  protected:
  explicit Block_InterFrameModeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentIdFieldNumber = 1,
    kSkipFieldNumber = 2,
    kIsInterFieldNumber = 3,
    kTxSizeFieldNumber = 4,
    kIntraFrameFieldNumber = 5,
    kInterFrameFieldNumber = 6,
  };
  // bytes segment_id = 1;
  void clear_segment_id();
  const std::string& segment_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_segment_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_segment_id();
  PROTOBUF_NODISCARD std::string* release_segment_id();
  void set_allocated_segment_id(std::string* segment_id);
  private:
  const std::string& _internal_segment_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_segment_id(const std::string& value);
  std::string* _internal_mutable_segment_id();
  public:

  // bytes skip = 2;
  void clear_skip();
  const std::string& skip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_skip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_skip();
  PROTOBUF_NODISCARD std::string* release_skip();
  void set_allocated_skip(std::string* skip);
  private:
  const std::string& _internal_skip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skip(const std::string& value);
  std::string* _internal_mutable_skip();
  public:

  // bytes is_inter = 3;
  void clear_is_inter();
  const std::string& is_inter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_is_inter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_is_inter();
  PROTOBUF_NODISCARD std::string* release_is_inter();
  void set_allocated_is_inter(std::string* is_inter);
  private:
  const std::string& _internal_is_inter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_is_inter(const std::string& value);
  std::string* _internal_mutable_is_inter();
  public:

  // bytes tx_size = 4;
  void clear_tx_size();
  const std::string& tx_size() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_size(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_size();
  PROTOBUF_NODISCARD std::string* release_tx_size();
  void set_allocated_tx_size(std::string* tx_size);
  private:
  const std::string& _internal_tx_size() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_size(const std::string& value);
  std::string* _internal_mutable_tx_size();
  public:

  // .Block.IntraFrameModeInfo intra_frame = 5;
  bool has_intra_frame() const;
  private:
  bool _internal_has_intra_frame() const;
  public:
  void clear_intra_frame();
  const ::Block_IntraFrameModeInfo& intra_frame() const;
  PROTOBUF_NODISCARD ::Block_IntraFrameModeInfo* release_intra_frame();
  ::Block_IntraFrameModeInfo* mutable_intra_frame();
  void set_allocated_intra_frame(::Block_IntraFrameModeInfo* intra_frame);
  private:
  const ::Block_IntraFrameModeInfo& _internal_intra_frame() const;
  ::Block_IntraFrameModeInfo* _internal_mutable_intra_frame();
  public:
  void unsafe_arena_set_allocated_intra_frame(
      ::Block_IntraFrameModeInfo* intra_frame);
  ::Block_IntraFrameModeInfo* unsafe_arena_release_intra_frame();

  // .Block.InterFrameModeInfo inter_frame = 6;
  bool has_inter_frame() const;
  private:
  bool _internal_has_inter_frame() const;
  public:
  void clear_inter_frame();
  const ::Block_InterFrameModeInfo& inter_frame() const;
  PROTOBUF_NODISCARD ::Block_InterFrameModeInfo* release_inter_frame();
  ::Block_InterFrameModeInfo* mutable_inter_frame();
  void set_allocated_inter_frame(::Block_InterFrameModeInfo* inter_frame);
  private:
  const ::Block_InterFrameModeInfo& _internal_inter_frame() const;
  ::Block_InterFrameModeInfo* _internal_mutable_inter_frame();
  public:
  void unsafe_arena_set_allocated_inter_frame(
      ::Block_InterFrameModeInfo* inter_frame);
  ::Block_InterFrameModeInfo* unsafe_arena_release_inter_frame();

  void clear_next_frame();
  NextFrameCase next_frame_case() const;
  // @@protoc_insertion_point(class_scope:Block.InterFrameModeInfo)
 private:
  class _Internal;
  void set_has_intra_frame();
  void set_has_inter_frame();

  inline bool has_next_frame() const;
  inline void clear_has_next_frame();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segment_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr skip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr is_inter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_size_;
    union NextFrameUnion {
      constexpr NextFrameUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Block_IntraFrameModeInfo* intra_frame_;
      ::Block_InterFrameModeInfo* inter_frame_;
    } next_frame_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class Block final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  explicit PROTOBUF_CONSTEXPR Block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  enum ModeInfoCase {
    kIntraFrame = 1,
    kInterFrame = 2,
    MODE_INFO_NOT_SET = 0,
  };

  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Block& from) {
    Block::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Block_IntraFrameModeInfo IntraFrameModeInfo;
  typedef Block_InterFrameModeInfo InterFrameModeInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kResidualFieldNumber = 3,
    kIntraFrameFieldNumber = 1,
    kInterFrameFieldNumber = 2,
  };
  // bytes residual = 3;
  void clear_residual();
  const std::string& residual() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_residual(ArgT0&& arg0, ArgT... args);
  std::string* mutable_residual();
  PROTOBUF_NODISCARD std::string* release_residual();
  void set_allocated_residual(std::string* residual);
  private:
  const std::string& _internal_residual() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_residual(const std::string& value);
  std::string* _internal_mutable_residual();
  public:

  // .Block.IntraFrameModeInfo intra_frame = 1;
  bool has_intra_frame() const;
  private:
  bool _internal_has_intra_frame() const;
  public:
  void clear_intra_frame();
  const ::Block_IntraFrameModeInfo& intra_frame() const;
  PROTOBUF_NODISCARD ::Block_IntraFrameModeInfo* release_intra_frame();
  ::Block_IntraFrameModeInfo* mutable_intra_frame();
  void set_allocated_intra_frame(::Block_IntraFrameModeInfo* intra_frame);
  private:
  const ::Block_IntraFrameModeInfo& _internal_intra_frame() const;
  ::Block_IntraFrameModeInfo* _internal_mutable_intra_frame();
  public:
  void unsafe_arena_set_allocated_intra_frame(
      ::Block_IntraFrameModeInfo* intra_frame);
  ::Block_IntraFrameModeInfo* unsafe_arena_release_intra_frame();

  // .Block.InterFrameModeInfo inter_frame = 2;
  bool has_inter_frame() const;
  private:
  bool _internal_has_inter_frame() const;
  public:
  void clear_inter_frame();
  const ::Block_InterFrameModeInfo& inter_frame() const;
  PROTOBUF_NODISCARD ::Block_InterFrameModeInfo* release_inter_frame();
  ::Block_InterFrameModeInfo* mutable_inter_frame();
  void set_allocated_inter_frame(::Block_InterFrameModeInfo* inter_frame);
  private:
  const ::Block_InterFrameModeInfo& _internal_inter_frame() const;
  ::Block_InterFrameModeInfo* _internal_mutable_inter_frame();
  public:
  void unsafe_arena_set_allocated_inter_frame(
      ::Block_InterFrameModeInfo* inter_frame);
  ::Block_InterFrameModeInfo* unsafe_arena_release_inter_frame();

  void clear_mode_info();
  ModeInfoCase mode_info_case() const;
  // @@protoc_insertion_point(class_scope:Block)
 private:
  class _Internal;
  void set_has_intra_frame();
  void set_has_inter_frame();

  inline bool has_mode_info() const;
  inline void clear_has_mode_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr residual_;
    union ModeInfoUnion {
      constexpr ModeInfoUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::Block_IntraFrameModeInfo* intra_frame_;
      ::Block_InterFrameModeInfo* inter_frame_;
    } mode_info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class Partition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Partition) */ {
 public:
  inline Partition() : Partition(nullptr) {}
  ~Partition() override;
  explicit PROTOBUF_CONSTEXPR Partition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Partition(const Partition& from);
  Partition(Partition&& from) noexcept
    : Partition() {
    *this = ::std::move(from);
  }

  inline Partition& operator=(const Partition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Partition& operator=(Partition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Partition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Partition* internal_default_instance() {
    return reinterpret_cast<const Partition*>(
               &_Partition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Partition& a, Partition& b) {
    a.Swap(&b);
  }
  inline void Swap(Partition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Partition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Partition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Partition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Partition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Partition& from) {
    Partition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Partition";
  }
  protected:
  explicit Partition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionFieldNumber = 1,
    kBlockFieldNumber = 2,
  };
  // bytes partition = 1;
  void clear_partition();
  const std::string& partition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition();
  PROTOBUF_NODISCARD std::string* release_partition();
  void set_allocated_partition(std::string* partition);
  private:
  const std::string& _internal_partition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition(const std::string& value);
  std::string* _internal_mutable_partition();
  public:

  // .Block block = 2;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::Block& block() const;
  PROTOBUF_NODISCARD ::Block* release_block();
  ::Block* mutable_block();
  void set_allocated_block(::Block* block);
  private:
  const ::Block& _internal_block() const;
  ::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::Block* block);
  ::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:Partition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_;
    ::Block* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class Tile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  ~Tile() override;
  explicit PROTOBUF_CONSTEXPR Tile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tile& from) {
    Tile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionFieldNumber = 2,
    kTileSizeFieldNumber = 1,
  };
  // .Partition partition = 2;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  const ::Partition& partition() const;
  PROTOBUF_NODISCARD ::Partition* release_partition();
  ::Partition* mutable_partition();
  void set_allocated_partition(::Partition* partition);
  private:
  const ::Partition& _internal_partition() const;
  ::Partition* _internal_mutable_partition();
  public:
  void unsafe_arena_set_allocated_partition(
      ::Partition* partition);
  ::Partition* unsafe_arena_release_partition();

  // uint32 tile_size = 1;
  void clear_tile_size();
  uint32_t tile_size() const;
  void set_tile_size(uint32_t value);
  private:
  uint32_t _internal_tile_size() const;
  void _internal_set_tile_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Tile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Partition* partition_;
    uint32_t tile_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};// -------------------------------------------------------------------

class VP9Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VP9Frame) */ {
 public:
  inline VP9Frame() : VP9Frame(nullptr) {}
  ~VP9Frame() override;
  explicit PROTOBUF_CONSTEXPR VP9Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VP9Frame(const VP9Frame& from);
  VP9Frame(VP9Frame&& from) noexcept
    : VP9Frame() {
    *this = ::std::move(from);
  }

  inline VP9Frame& operator=(const VP9Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline VP9Frame& operator=(VP9Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VP9Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const VP9Frame* internal_default_instance() {
    return reinterpret_cast<const VP9Frame*>(
               &_VP9Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VP9Frame& a, VP9Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(VP9Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VP9Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VP9Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VP9Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VP9Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VP9Frame& from) {
    VP9Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VP9Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "VP9Frame";
  }
  protected:
  explicit VP9Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 5,
    kUncompressedHeaderFieldNumber = 1,
    kCompressedHeaderFieldNumber = 4,
    kTrailingBitsFieldNumber = 2,
    kPaddingBitFieldNumber = 3,
  };
  // repeated .Tile tiles = 5;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
      mutable_tiles();
  private:
  const ::Tile& _internal_tiles(int index) const;
  ::Tile* _internal_add_tiles();
  public:
  const ::Tile& tiles(int index) const;
  ::Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
      tiles() const;

  // .UncompressedHeader uncompressed_header = 1;
  bool has_uncompressed_header() const;
  private:
  bool _internal_has_uncompressed_header() const;
  public:
  void clear_uncompressed_header();
  const ::UncompressedHeader& uncompressed_header() const;
  PROTOBUF_NODISCARD ::UncompressedHeader* release_uncompressed_header();
  ::UncompressedHeader* mutable_uncompressed_header();
  void set_allocated_uncompressed_header(::UncompressedHeader* uncompressed_header);
  private:
  const ::UncompressedHeader& _internal_uncompressed_header() const;
  ::UncompressedHeader* _internal_mutable_uncompressed_header();
  public:
  void unsafe_arena_set_allocated_uncompressed_header(
      ::UncompressedHeader* uncompressed_header);
  ::UncompressedHeader* unsafe_arena_release_uncompressed_header();

  // .CompressedHeader compressed_header = 4;
  bool has_compressed_header() const;
  private:
  bool _internal_has_compressed_header() const;
  public:
  void clear_compressed_header();
  const ::CompressedHeader& compressed_header() const;
  PROTOBUF_NODISCARD ::CompressedHeader* release_compressed_header();
  ::CompressedHeader* mutable_compressed_header();
  void set_allocated_compressed_header(::CompressedHeader* compressed_header);
  private:
  const ::CompressedHeader& _internal_compressed_header() const;
  ::CompressedHeader* _internal_mutable_compressed_header();
  public:
  void unsafe_arena_set_allocated_compressed_header(
      ::CompressedHeader* compressed_header);
  ::CompressedHeader* unsafe_arena_release_compressed_header();

  // uint32 trailing_bits = 2;
  void clear_trailing_bits();
  uint32_t trailing_bits() const;
  void set_trailing_bits(uint32_t value);
  private:
  uint32_t _internal_trailing_bits() const;
  void _internal_set_trailing_bits(uint32_t value);
  public:

  // uint32 padding_bit = 3;
  void clear_padding_bit();
  uint32_t padding_bit() const;
  void set_padding_bit(uint32_t value);
  private:
  uint32_t _internal_padding_bit() const;
  void _internal_set_padding_bit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VP9Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile > tiles_;
    ::UncompressedHeader* uncompressed_header_;
    ::CompressedHeader* compressed_header_;
    uint32_t trailing_bits_;
    uint32_t padding_bit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vp9_2eproto;
};
// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// VP9SignedInteger

// bytes value = 1;
inline void VP9SignedInteger::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& VP9SignedInteger::value() const {
  // @@protoc_insertion_point(field_get:VP9SignedInteger.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VP9SignedInteger::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VP9SignedInteger.value)
}
inline std::string* VP9SignedInteger::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:VP9SignedInteger.value)
  return _s;
}
inline const std::string& VP9SignedInteger::_internal_value() const {
  return _impl_.value_.Get();
}
inline void VP9SignedInteger::_internal_set_value(const std::string& value) {

  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* VP9SignedInteger::_internal_mutable_value() {

  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* VP9SignedInteger::release_value() {
  // @@protoc_insertion_point(field_release:VP9SignedInteger.value)
  return _impl_.value_.Release();
}
inline void VP9SignedInteger::set_allocated_value(std::string* value) {
  if (value != nullptr) {

  } else {

  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VP9SignedInteger.value)
}

// uint32 sign = 2;
inline void VP9SignedInteger::clear_sign() {
  _impl_.sign_ = 0u;
}
inline uint32_t VP9SignedInteger::_internal_sign() const {
  return _impl_.sign_;
}
inline uint32_t VP9SignedInteger::sign() const {
  // @@protoc_insertion_point(field_get:VP9SignedInteger.sign)
  return _internal_sign();
}
inline void VP9SignedInteger::_internal_set_sign(uint32_t value) {

  _impl_.sign_ = value;
}
inline void VP9SignedInteger::set_sign(uint32_t value) {
  _internal_set_sign(value);
  // @@protoc_insertion_point(field_set:VP9SignedInteger.sign)
}

// -------------------------------------------------------------------

// UncompressedHeader_ColorConfig

// uint32 ten_or_twelve_bit = 1;
inline void UncompressedHeader_ColorConfig::clear_ten_or_twelve_bit() {
  _impl_.ten_or_twelve_bit_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_ten_or_twelve_bit() const {
  return _impl_.ten_or_twelve_bit_;
}
inline uint32_t UncompressedHeader_ColorConfig::ten_or_twelve_bit() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.ten_or_twelve_bit)
  return _internal_ten_or_twelve_bit();
}
inline void UncompressedHeader_ColorConfig::_internal_set_ten_or_twelve_bit(uint32_t value) {

  _impl_.ten_or_twelve_bit_ = value;
}
inline void UncompressedHeader_ColorConfig::set_ten_or_twelve_bit(uint32_t value) {
  _internal_set_ten_or_twelve_bit(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.ten_or_twelve_bit)
}

// uint32 color_space = 2;
inline void UncompressedHeader_ColorConfig::clear_color_space() {
  _impl_.color_space_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_color_space() const {
  return _impl_.color_space_;
}
inline uint32_t UncompressedHeader_ColorConfig::color_space() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.color_space)
  return _internal_color_space();
}
inline void UncompressedHeader_ColorConfig::_internal_set_color_space(uint32_t value) {

  _impl_.color_space_ = value;
}
inline void UncompressedHeader_ColorConfig::set_color_space(uint32_t value) {
  _internal_set_color_space(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.color_space)
}

// uint32 color_range = 3;
inline void UncompressedHeader_ColorConfig::clear_color_range() {
  _impl_.color_range_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_color_range() const {
  return _impl_.color_range_;
}
inline uint32_t UncompressedHeader_ColorConfig::color_range() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.color_range)
  return _internal_color_range();
}
inline void UncompressedHeader_ColorConfig::_internal_set_color_range(uint32_t value) {

  _impl_.color_range_ = value;
}
inline void UncompressedHeader_ColorConfig::set_color_range(uint32_t value) {
  _internal_set_color_range(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.color_range)
}

// uint32 subsampling_x = 4;
inline void UncompressedHeader_ColorConfig::clear_subsampling_x() {
  _impl_.subsampling_x_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_subsampling_x() const {
  return _impl_.subsampling_x_;
}
inline uint32_t UncompressedHeader_ColorConfig::subsampling_x() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.subsampling_x)
  return _internal_subsampling_x();
}
inline void UncompressedHeader_ColorConfig::_internal_set_subsampling_x(uint32_t value) {

  _impl_.subsampling_x_ = value;
}
inline void UncompressedHeader_ColorConfig::set_subsampling_x(uint32_t value) {
  _internal_set_subsampling_x(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.subsampling_x)
}

// uint32 subsampling_y = 5;
inline void UncompressedHeader_ColorConfig::clear_subsampling_y() {
  _impl_.subsampling_y_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_subsampling_y() const {
  return _impl_.subsampling_y_;
}
inline uint32_t UncompressedHeader_ColorConfig::subsampling_y() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.subsampling_y)
  return _internal_subsampling_y();
}
inline void UncompressedHeader_ColorConfig::_internal_set_subsampling_y(uint32_t value) {

  _impl_.subsampling_y_ = value;
}
inline void UncompressedHeader_ColorConfig::set_subsampling_y(uint32_t value) {
  _internal_set_subsampling_y(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.subsampling_y)
}

// uint32 reserved_zero = 6;
inline void UncompressedHeader_ColorConfig::clear_reserved_zero() {
  _impl_.reserved_zero_ = 0u;
}
inline uint32_t UncompressedHeader_ColorConfig::_internal_reserved_zero() const {
  return _impl_.reserved_zero_;
}
inline uint32_t UncompressedHeader_ColorConfig::reserved_zero() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ColorConfig.reserved_zero)
  return _internal_reserved_zero();
}
inline void UncompressedHeader_ColorConfig::_internal_set_reserved_zero(uint32_t value) {

  _impl_.reserved_zero_ = value;
}
inline void UncompressedHeader_ColorConfig::set_reserved_zero(uint32_t value) {
  _internal_set_reserved_zero(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ColorConfig.reserved_zero)
}

// -------------------------------------------------------------------

// UncompressedHeader_FrameSize

// uint32 frame_width_minus_1 = 1;
inline void UncompressedHeader_FrameSize::clear_frame_width_minus_1() {
  _impl_.frame_width_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_FrameSize::_internal_frame_width_minus_1() const {
  return _impl_.frame_width_minus_1_;
}
inline uint32_t UncompressedHeader_FrameSize::frame_width_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.FrameSize.frame_width_minus_1)
  return _internal_frame_width_minus_1();
}
inline void UncompressedHeader_FrameSize::_internal_set_frame_width_minus_1(uint32_t value) {

  _impl_.frame_width_minus_1_ = value;
}
inline void UncompressedHeader_FrameSize::set_frame_width_minus_1(uint32_t value) {
  _internal_set_frame_width_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.FrameSize.frame_width_minus_1)
}

// uint32 frame_height_minus_1 = 2;
inline void UncompressedHeader_FrameSize::clear_frame_height_minus_1() {
  _impl_.frame_height_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_FrameSize::_internal_frame_height_minus_1() const {
  return _impl_.frame_height_minus_1_;
}
inline uint32_t UncompressedHeader_FrameSize::frame_height_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.FrameSize.frame_height_minus_1)
  return _internal_frame_height_minus_1();
}
inline void UncompressedHeader_FrameSize::_internal_set_frame_height_minus_1(uint32_t value) {

  _impl_.frame_height_minus_1_ = value;
}
inline void UncompressedHeader_FrameSize::set_frame_height_minus_1(uint32_t value) {
  _internal_set_frame_height_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.FrameSize.frame_height_minus_1)
}

// -------------------------------------------------------------------

// UncompressedHeader_RenderSize

// uint32 render_and_frame_size_different = 1;
inline void UncompressedHeader_RenderSize::clear_render_and_frame_size_different() {
  _impl_.render_and_frame_size_different_ = 0u;
}
inline uint32_t UncompressedHeader_RenderSize::_internal_render_and_frame_size_different() const {
  return _impl_.render_and_frame_size_different_;
}
inline uint32_t UncompressedHeader_RenderSize::render_and_frame_size_different() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.RenderSize.render_and_frame_size_different)
  return _internal_render_and_frame_size_different();
}
inline void UncompressedHeader_RenderSize::_internal_set_render_and_frame_size_different(uint32_t value) {

  _impl_.render_and_frame_size_different_ = value;
}
inline void UncompressedHeader_RenderSize::set_render_and_frame_size_different(uint32_t value) {
  _internal_set_render_and_frame_size_different(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.RenderSize.render_and_frame_size_different)
}

// uint32 render_width_minus_1 = 2;
inline void UncompressedHeader_RenderSize::clear_render_width_minus_1() {
  _impl_.render_width_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_RenderSize::_internal_render_width_minus_1() const {
  return _impl_.render_width_minus_1_;
}
inline uint32_t UncompressedHeader_RenderSize::render_width_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.RenderSize.render_width_minus_1)
  return _internal_render_width_minus_1();
}
inline void UncompressedHeader_RenderSize::_internal_set_render_width_minus_1(uint32_t value) {

  _impl_.render_width_minus_1_ = value;
}
inline void UncompressedHeader_RenderSize::set_render_width_minus_1(uint32_t value) {
  _internal_set_render_width_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.RenderSize.render_width_minus_1)
}

// uint32 render_height_minus_1 = 3;
inline void UncompressedHeader_RenderSize::clear_render_height_minus_1() {
  _impl_.render_height_minus_1_ = 0u;
}
inline uint32_t UncompressedHeader_RenderSize::_internal_render_height_minus_1() const {
  return _impl_.render_height_minus_1_;
}
inline uint32_t UncompressedHeader_RenderSize::render_height_minus_1() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.RenderSize.render_height_minus_1)
  return _internal_render_height_minus_1();
}
inline void UncompressedHeader_RenderSize::_internal_set_render_height_minus_1(uint32_t value) {

  _impl_.render_height_minus_1_ = value;
}
inline void UncompressedHeader_RenderSize::set_render_height_minus_1(uint32_t value) {
  _internal_set_render_height_minus_1(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.RenderSize.render_height_minus_1)
}

// -------------------------------------------------------------------

// UncompressedHeader_ReadInterpolationFilter

// uint32 is_filter_switchable = 1;
inline void UncompressedHeader_ReadInterpolationFilter::clear_is_filter_switchable() {
  _impl_.is_filter_switchable_ = 0u;
}
inline uint32_t UncompressedHeader_ReadInterpolationFilter::_internal_is_filter_switchable() const {
  return _impl_.is_filter_switchable_;
}
inline uint32_t UncompressedHeader_ReadInterpolationFilter::is_filter_switchable() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ReadInterpolationFilter.is_filter_switchable)
  return _internal_is_filter_switchable();
}
inline void UncompressedHeader_ReadInterpolationFilter::_internal_set_is_filter_switchable(uint32_t value) {

  _impl_.is_filter_switchable_ = value;
}
inline void UncompressedHeader_ReadInterpolationFilter::set_is_filter_switchable(uint32_t value) {
  _internal_set_is_filter_switchable(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ReadInterpolationFilter.is_filter_switchable)
}

// uint32 raw_interpolation_filter = 2;
inline void UncompressedHeader_ReadInterpolationFilter::clear_raw_interpolation_filter() {
  _impl_.raw_interpolation_filter_ = 0u;
}
inline uint32_t UncompressedHeader_ReadInterpolationFilter::_internal_raw_interpolation_filter() const {
  return _impl_.raw_interpolation_filter_;
}
inline uint32_t UncompressedHeader_ReadInterpolationFilter::raw_interpolation_filter() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ReadInterpolationFilter.raw_interpolation_filter)
  return _internal_raw_interpolation_filter();
}
inline void UncompressedHeader_ReadInterpolationFilter::_internal_set_raw_interpolation_filter(uint32_t value) {

  _impl_.raw_interpolation_filter_ = value;
}
inline void UncompressedHeader_ReadInterpolationFilter::set_raw_interpolation_filter(uint32_t value) {
  _internal_set_raw_interpolation_filter(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ReadInterpolationFilter.raw_interpolation_filter)
}

// -------------------------------------------------------------------

// UncompressedHeader_LoopFilterParams

// uint32 loop_filter_level = 1;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_level() {
  _impl_.loop_filter_level_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_loop_filter_level() const {
  return _impl_.loop_filter_level_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::loop_filter_level() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_level)
  return _internal_loop_filter_level();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_level(uint32_t value) {

  _impl_.loop_filter_level_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_level(uint32_t value) {
  _internal_set_loop_filter_level(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_level)
}

// uint32 loop_filter_sharpness = 2;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_sharpness() {
  _impl_.loop_filter_sharpness_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_loop_filter_sharpness() const {
  return _impl_.loop_filter_sharpness_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::loop_filter_sharpness() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_sharpness)
  return _internal_loop_filter_sharpness();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_sharpness(uint32_t value) {

  _impl_.loop_filter_sharpness_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_sharpness(uint32_t value) {
  _internal_set_loop_filter_sharpness(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_sharpness)
}

// uint32 loop_filter_delta_enabled = 3;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_delta_enabled() {
  _impl_.loop_filter_delta_enabled_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_loop_filter_delta_enabled() const {
  return _impl_.loop_filter_delta_enabled_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::loop_filter_delta_enabled() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_delta_enabled)
  return _internal_loop_filter_delta_enabled();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_delta_enabled(uint32_t value) {

  _impl_.loop_filter_delta_enabled_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_delta_enabled(uint32_t value) {
  _internal_set_loop_filter_delta_enabled(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_delta_enabled)
}

// uint32 loop_filter_delta_update = 4;
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_delta_update() {
  _impl_.loop_filter_delta_update_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_loop_filter_delta_update() const {
  return _impl_.loop_filter_delta_update_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::loop_filter_delta_update() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_delta_update)
  return _internal_loop_filter_delta_update();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_loop_filter_delta_update(uint32_t value) {

  _impl_.loop_filter_delta_update_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_loop_filter_delta_update(uint32_t value) {
  _internal_set_loop_filter_delta_update(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.loop_filter_delta_update)
}

// uint32 update_ref_delta = 5;
inline void UncompressedHeader_LoopFilterParams::clear_update_ref_delta() {
  _impl_.update_ref_delta_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_update_ref_delta() const {
  return _impl_.update_ref_delta_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::update_ref_delta() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.update_ref_delta)
  return _internal_update_ref_delta();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_update_ref_delta(uint32_t value) {

  _impl_.update_ref_delta_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_update_ref_delta(uint32_t value) {
  _internal_set_update_ref_delta(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.update_ref_delta)
}

// .VP9SignedInteger loop_filter_ref_deltas = 6;
inline bool UncompressedHeader_LoopFilterParams::_internal_has_loop_filter_ref_deltas() const {
  return this != internal_default_instance() && _impl_.loop_filter_ref_deltas_ != nullptr;
}
inline bool UncompressedHeader_LoopFilterParams::has_loop_filter_ref_deltas() const {
  return _internal_has_loop_filter_ref_deltas();
}
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_ref_deltas() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_ref_deltas_ != nullptr) {
    delete _impl_.loop_filter_ref_deltas_;
  }
  _impl_.loop_filter_ref_deltas_ = nullptr;
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams::_internal_loop_filter_ref_deltas() const {
  const ::VP9SignedInteger* p = _impl_.loop_filter_ref_deltas_;
  return p != nullptr ? *p : reinterpret_cast<const ::VP9SignedInteger&>(
      ::_VP9SignedInteger_default_instance_);
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams::loop_filter_ref_deltas() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_ref_deltas)
  return _internal_loop_filter_ref_deltas();
}
inline void UncompressedHeader_LoopFilterParams::unsafe_arena_set_allocated_loop_filter_ref_deltas(
    ::VP9SignedInteger* loop_filter_ref_deltas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_filter_ref_deltas_);
  }
  _impl_.loop_filter_ref_deltas_ = loop_filter_ref_deltas;
  if (loop_filter_ref_deltas) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.LoopFilterParams.loop_filter_ref_deltas)
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::release_loop_filter_ref_deltas() {
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_ref_deltas_;
  _impl_.loop_filter_ref_deltas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::unsafe_arena_release_loop_filter_ref_deltas() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.LoopFilterParams.loop_filter_ref_deltas)
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_ref_deltas_;
  _impl_.loop_filter_ref_deltas_ = nullptr;
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::_internal_mutable_loop_filter_ref_deltas() {
  
  if (_impl_.loop_filter_ref_deltas_ == nullptr) {
    auto* p = CreateMaybeMessage<::VP9SignedInteger>(GetArenaForAllocation());
    _impl_.loop_filter_ref_deltas_ = p;
  }
  return _impl_.loop_filter_ref_deltas_;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::mutable_loop_filter_ref_deltas() {
  ::VP9SignedInteger* _msg = _internal_mutable_loop_filter_ref_deltas();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.LoopFilterParams.loop_filter_ref_deltas)
  return _msg;
}
inline void UncompressedHeader_LoopFilterParams::set_allocated_loop_filter_ref_deltas(::VP9SignedInteger* loop_filter_ref_deltas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_filter_ref_deltas_;
  }
  if (loop_filter_ref_deltas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_filter_ref_deltas);
    if (message_arena != submessage_arena) {
      loop_filter_ref_deltas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_filter_ref_deltas, submessage_arena);
    }

  } else {

  }
  _impl_.loop_filter_ref_deltas_ = loop_filter_ref_deltas;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.LoopFilterParams.loop_filter_ref_deltas)
}

// uint32 update_mode_delta = 7;
inline void UncompressedHeader_LoopFilterParams::clear_update_mode_delta() {
  _impl_.update_mode_delta_ = 0u;
}
inline uint32_t UncompressedHeader_LoopFilterParams::_internal_update_mode_delta() const {
  return _impl_.update_mode_delta_;
}
inline uint32_t UncompressedHeader_LoopFilterParams::update_mode_delta() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.update_mode_delta)
  return _internal_update_mode_delta();
}
inline void UncompressedHeader_LoopFilterParams::_internal_set_update_mode_delta(uint32_t value) {

  _impl_.update_mode_delta_ = value;
}
inline void UncompressedHeader_LoopFilterParams::set_update_mode_delta(uint32_t value) {
  _internal_set_update_mode_delta(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.LoopFilterParams.update_mode_delta)
}

// .VP9SignedInteger loop_filter_mode_deltas = 8;
inline bool UncompressedHeader_LoopFilterParams::_internal_has_loop_filter_mode_deltas() const {
  return this != internal_default_instance() && _impl_.loop_filter_mode_deltas_ != nullptr;
}
inline bool UncompressedHeader_LoopFilterParams::has_loop_filter_mode_deltas() const {
  return _internal_has_loop_filter_mode_deltas();
}
inline void UncompressedHeader_LoopFilterParams::clear_loop_filter_mode_deltas() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_mode_deltas_ != nullptr) {
    delete _impl_.loop_filter_mode_deltas_;
  }
  _impl_.loop_filter_mode_deltas_ = nullptr;
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams::_internal_loop_filter_mode_deltas() const {
  const ::VP9SignedInteger* p = _impl_.loop_filter_mode_deltas_;
  return p != nullptr ? *p : reinterpret_cast<const ::VP9SignedInteger&>(
      ::_VP9SignedInteger_default_instance_);
}
inline const ::VP9SignedInteger& UncompressedHeader_LoopFilterParams::loop_filter_mode_deltas() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.LoopFilterParams.loop_filter_mode_deltas)
  return _internal_loop_filter_mode_deltas();
}
inline void UncompressedHeader_LoopFilterParams::unsafe_arena_set_allocated_loop_filter_mode_deltas(
    ::VP9SignedInteger* loop_filter_mode_deltas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_filter_mode_deltas_);
  }
  _impl_.loop_filter_mode_deltas_ = loop_filter_mode_deltas;
  if (loop_filter_mode_deltas) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.LoopFilterParams.loop_filter_mode_deltas)
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::release_loop_filter_mode_deltas() {
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_mode_deltas_;
  _impl_.loop_filter_mode_deltas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::unsafe_arena_release_loop_filter_mode_deltas() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.LoopFilterParams.loop_filter_mode_deltas)
  
  ::VP9SignedInteger* temp = _impl_.loop_filter_mode_deltas_;
  _impl_.loop_filter_mode_deltas_ = nullptr;
  return temp;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::_internal_mutable_loop_filter_mode_deltas() {
  
  if (_impl_.loop_filter_mode_deltas_ == nullptr) {
    auto* p = CreateMaybeMessage<::VP9SignedInteger>(GetArenaForAllocation());
    _impl_.loop_filter_mode_deltas_ = p;
  }
  return _impl_.loop_filter_mode_deltas_;
}
inline ::VP9SignedInteger* UncompressedHeader_LoopFilterParams::mutable_loop_filter_mode_deltas() {
  ::VP9SignedInteger* _msg = _internal_mutable_loop_filter_mode_deltas();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.LoopFilterParams.loop_filter_mode_deltas)
  return _msg;
}
inline void UncompressedHeader_LoopFilterParams::set_allocated_loop_filter_mode_deltas(::VP9SignedInteger* loop_filter_mode_deltas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_filter_mode_deltas_;
  }
  if (loop_filter_mode_deltas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_filter_mode_deltas);
    if (message_arena != submessage_arena) {
      loop_filter_mode_deltas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_filter_mode_deltas, submessage_arena);
    }

  } else {

  }
  _impl_.loop_filter_mode_deltas_ = loop_filter_mode_deltas;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.LoopFilterParams.loop_filter_mode_deltas)
}

// -------------------------------------------------------------------

// UncompressedHeader_QuantizationParams

// uint32 base_q_idx = 1;
inline void UncompressedHeader_QuantizationParams::clear_base_q_idx() {
  _impl_.base_q_idx_ = 0u;
}
inline uint32_t UncompressedHeader_QuantizationParams::_internal_base_q_idx() const {
  return _impl_.base_q_idx_;
}
inline uint32_t UncompressedHeader_QuantizationParams::base_q_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.QuantizationParams.base_q_idx)
  return _internal_base_q_idx();
}
inline void UncompressedHeader_QuantizationParams::_internal_set_base_q_idx(uint32_t value) {

  _impl_.base_q_idx_ = value;
}
inline void UncompressedHeader_QuantizationParams::set_base_q_idx(uint32_t value) {
  _internal_set_base_q_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.QuantizationParams.base_q_idx)
}

// -------------------------------------------------------------------

// UncompressedHeader_SegmentationParams

// uint32 segmentation_enabled = 1;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_enabled() {
  _impl_.segmentation_enabled_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_segmentation_enabled() const {
  return _impl_.segmentation_enabled_;
}
inline uint32_t UncompressedHeader_SegmentationParams::segmentation_enabled() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_enabled)
  return _internal_segmentation_enabled();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_enabled(uint32_t value) {

  _impl_.segmentation_enabled_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_enabled(uint32_t value) {
  _internal_set_segmentation_enabled(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_enabled)
}

// uint32 segmentation_update_map = 2;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_update_map() {
  _impl_.segmentation_update_map_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_segmentation_update_map() const {
  return _impl_.segmentation_update_map_;
}
inline uint32_t UncompressedHeader_SegmentationParams::segmentation_update_map() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_update_map)
  return _internal_segmentation_update_map();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_update_map(uint32_t value) {

  _impl_.segmentation_update_map_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_update_map(uint32_t value) {
  _internal_set_segmentation_update_map(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_update_map)
}

// uint32 segmentation_temporal_update = 3;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_temporal_update() {
  _impl_.segmentation_temporal_update_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_segmentation_temporal_update() const {
  return _impl_.segmentation_temporal_update_;
}
inline uint32_t UncompressedHeader_SegmentationParams::segmentation_temporal_update() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_temporal_update)
  return _internal_segmentation_temporal_update();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_temporal_update(uint32_t value) {

  _impl_.segmentation_temporal_update_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_temporal_update(uint32_t value) {
  _internal_set_segmentation_temporal_update(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_temporal_update)
}

// uint32 segmentation_update_data = 4;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_update_data() {
  _impl_.segmentation_update_data_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_segmentation_update_data() const {
  return _impl_.segmentation_update_data_;
}
inline uint32_t UncompressedHeader_SegmentationParams::segmentation_update_data() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_update_data)
  return _internal_segmentation_update_data();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_update_data(uint32_t value) {

  _impl_.segmentation_update_data_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_update_data(uint32_t value) {
  _internal_set_segmentation_update_data(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_update_data)
}

// uint32 segmentation_abs_or_delta_update = 5;
inline void UncompressedHeader_SegmentationParams::clear_segmentation_abs_or_delta_update() {
  _impl_.segmentation_abs_or_delta_update_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_segmentation_abs_or_delta_update() const {
  return _impl_.segmentation_abs_or_delta_update_;
}
inline uint32_t UncompressedHeader_SegmentationParams::segmentation_abs_or_delta_update() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.segmentation_abs_or_delta_update)
  return _internal_segmentation_abs_or_delta_update();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_segmentation_abs_or_delta_update(uint32_t value) {

  _impl_.segmentation_abs_or_delta_update_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_segmentation_abs_or_delta_update(uint32_t value) {
  _internal_set_segmentation_abs_or_delta_update(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.segmentation_abs_or_delta_update)
}

// uint32 feature_enabled = 6;
inline void UncompressedHeader_SegmentationParams::clear_feature_enabled() {
  _impl_.feature_enabled_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_feature_enabled() const {
  return _impl_.feature_enabled_;
}
inline uint32_t UncompressedHeader_SegmentationParams::feature_enabled() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.feature_enabled)
  return _internal_feature_enabled();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_feature_enabled(uint32_t value) {

  _impl_.feature_enabled_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_feature_enabled(uint32_t value) {
  _internal_set_feature_enabled(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.feature_enabled)
}

// bytes feature_value = 7;
inline void UncompressedHeader_SegmentationParams::clear_feature_value() {
  _impl_.feature_value_.ClearToEmpty();
}
inline const std::string& UncompressedHeader_SegmentationParams::feature_value() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.feature_value)
  return _internal_feature_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UncompressedHeader_SegmentationParams::set_feature_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.feature_value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.feature_value)
}
inline std::string* UncompressedHeader_SegmentationParams::mutable_feature_value() {
  std::string* _s = _internal_mutable_feature_value();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.SegmentationParams.feature_value)
  return _s;
}
inline const std::string& UncompressedHeader_SegmentationParams::_internal_feature_value() const {
  return _impl_.feature_value_.Get();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_feature_value(const std::string& value) {

  _impl_.feature_value_.Set(value, GetArenaForAllocation());
}
inline std::string* UncompressedHeader_SegmentationParams::_internal_mutable_feature_value() {

  return _impl_.feature_value_.Mutable(GetArenaForAllocation());
}
inline std::string* UncompressedHeader_SegmentationParams::release_feature_value() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.SegmentationParams.feature_value)
  return _impl_.feature_value_.Release();
}
inline void UncompressedHeader_SegmentationParams::set_allocated_feature_value(std::string* feature_value) {
  if (feature_value != nullptr) {

  } else {

  }
  _impl_.feature_value_.SetAllocated(feature_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feature_value_.IsDefault()) {
    _impl_.feature_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.SegmentationParams.feature_value)
}

// uint32 feature_sign = 8;
inline void UncompressedHeader_SegmentationParams::clear_feature_sign() {
  _impl_.feature_sign_ = 0u;
}
inline uint32_t UncompressedHeader_SegmentationParams::_internal_feature_sign() const {
  return _impl_.feature_sign_;
}
inline uint32_t UncompressedHeader_SegmentationParams::feature_sign() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.SegmentationParams.feature_sign)
  return _internal_feature_sign();
}
inline void UncompressedHeader_SegmentationParams::_internal_set_feature_sign(uint32_t value) {

  _impl_.feature_sign_ = value;
}
inline void UncompressedHeader_SegmentationParams::set_feature_sign(uint32_t value) {
  _internal_set_feature_sign(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.SegmentationParams.feature_sign)
}

// -------------------------------------------------------------------

// UncompressedHeader_TileInfo

// uint32 increment_tile_cols_log2 = 1;
inline void UncompressedHeader_TileInfo::clear_increment_tile_cols_log2() {
  _impl_.increment_tile_cols_log2_ = 0u;
}
inline uint32_t UncompressedHeader_TileInfo::_internal_increment_tile_cols_log2() const {
  return _impl_.increment_tile_cols_log2_;
}
inline uint32_t UncompressedHeader_TileInfo::increment_tile_cols_log2() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.TileInfo.increment_tile_cols_log2)
  return _internal_increment_tile_cols_log2();
}
inline void UncompressedHeader_TileInfo::_internal_set_increment_tile_cols_log2(uint32_t value) {

  _impl_.increment_tile_cols_log2_ = value;
}
inline void UncompressedHeader_TileInfo::set_increment_tile_cols_log2(uint32_t value) {
  _internal_set_increment_tile_cols_log2(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.TileInfo.increment_tile_cols_log2)
}

// uint32 tile_rows_log2 = 2;
inline void UncompressedHeader_TileInfo::clear_tile_rows_log2() {
  _impl_.tile_rows_log2_ = 0u;
}
inline uint32_t UncompressedHeader_TileInfo::_internal_tile_rows_log2() const {
  return _impl_.tile_rows_log2_;
}
inline uint32_t UncompressedHeader_TileInfo::tile_rows_log2() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.TileInfo.tile_rows_log2)
  return _internal_tile_rows_log2();
}
inline void UncompressedHeader_TileInfo::_internal_set_tile_rows_log2(uint32_t value) {

  _impl_.tile_rows_log2_ = value;
}
inline void UncompressedHeader_TileInfo::set_tile_rows_log2(uint32_t value) {
  _internal_set_tile_rows_log2(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.TileInfo.tile_rows_log2)
}

// uint32 increment_tile_rows_Log2 = 3;
inline void UncompressedHeader_TileInfo::clear_increment_tile_rows_log2() {
  _impl_.increment_tile_rows_log2_ = 0u;
}
inline uint32_t UncompressedHeader_TileInfo::_internal_increment_tile_rows_log2() const {
  return _impl_.increment_tile_rows_log2_;
}
inline uint32_t UncompressedHeader_TileInfo::increment_tile_rows_log2() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.TileInfo.increment_tile_rows_Log2)
  return _internal_increment_tile_rows_log2();
}
inline void UncompressedHeader_TileInfo::_internal_set_increment_tile_rows_log2(uint32_t value) {

  _impl_.increment_tile_rows_log2_ = value;
}
inline void UncompressedHeader_TileInfo::set_increment_tile_rows_log2(uint32_t value) {
  _internal_set_increment_tile_rows_log2(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.TileInfo.increment_tile_rows_Log2)
}

// -------------------------------------------------------------------

// UncompressedHeader

// uint32 marker = 1;
inline void UncompressedHeader::clear_marker() {
  _impl_.marker_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_marker() const {
  return _impl_.marker_;
}
inline uint32_t UncompressedHeader::marker() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.marker)
  return _internal_marker();
}
inline void UncompressedHeader::_internal_set_marker(uint32_t value) {

  _impl_.marker_ = value;
}
inline void UncompressedHeader::set_marker(uint32_t value) {
  _internal_set_marker(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.marker)
}

// uint32 profile = 2;
inline void UncompressedHeader::clear_profile() {
  _impl_.profile_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_profile() const {
  return _impl_.profile_;
}
inline uint32_t UncompressedHeader::profile() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.profile)
  return _internal_profile();
}
inline void UncompressedHeader::_internal_set_profile(uint32_t value) {

  _impl_.profile_ = value;
}
inline void UncompressedHeader::set_profile(uint32_t value) {
  _internal_set_profile(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.profile)
}

// uint32 reserved_zero = 3;
inline void UncompressedHeader::clear_reserved_zero() {
  _impl_.reserved_zero_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_reserved_zero() const {
  return _impl_.reserved_zero_;
}
inline uint32_t UncompressedHeader::reserved_zero() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.reserved_zero)
  return _internal_reserved_zero();
}
inline void UncompressedHeader::_internal_set_reserved_zero(uint32_t value) {

  _impl_.reserved_zero_ = value;
}
inline void UncompressedHeader::set_reserved_zero(uint32_t value) {
  _internal_set_reserved_zero(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.reserved_zero)
}

// uint32 show_existing_frame = 4;
inline void UncompressedHeader::clear_show_existing_frame() {
  _impl_.show_existing_frame_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_show_existing_frame() const {
  return _impl_.show_existing_frame_;
}
inline uint32_t UncompressedHeader::show_existing_frame() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.show_existing_frame)
  return _internal_show_existing_frame();
}
inline void UncompressedHeader::_internal_set_show_existing_frame(uint32_t value) {

  _impl_.show_existing_frame_ = value;
}
inline void UncompressedHeader::set_show_existing_frame(uint32_t value) {
  _internal_set_show_existing_frame(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.show_existing_frame)
}

// uint32 frame_to_show_map_idx = 5;
inline void UncompressedHeader::clear_frame_to_show_map_idx() {
  _impl_.frame_to_show_map_idx_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_to_show_map_idx() const {
  return _impl_.frame_to_show_map_idx_;
}
inline uint32_t UncompressedHeader::frame_to_show_map_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_to_show_map_idx)
  return _internal_frame_to_show_map_idx();
}
inline void UncompressedHeader::_internal_set_frame_to_show_map_idx(uint32_t value) {

  _impl_.frame_to_show_map_idx_ = value;
}
inline void UncompressedHeader::set_frame_to_show_map_idx(uint32_t value) {
  _internal_set_frame_to_show_map_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_to_show_map_idx)
}

// uint32 frame_type = 6;
inline void UncompressedHeader::clear_frame_type() {
  _impl_.frame_type_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_type() const {
  return _impl_.frame_type_;
}
inline uint32_t UncompressedHeader::frame_type() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_type)
  return _internal_frame_type();
}
inline void UncompressedHeader::_internal_set_frame_type(uint32_t value) {

  _impl_.frame_type_ = value;
}
inline void UncompressedHeader::set_frame_type(uint32_t value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_type)
}

// uint32 show_frame = 7;
inline void UncompressedHeader::clear_show_frame() {
  _impl_.show_frame_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_show_frame() const {
  return _impl_.show_frame_;
}
inline uint32_t UncompressedHeader::show_frame() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.show_frame)
  return _internal_show_frame();
}
inline void UncompressedHeader::_internal_set_show_frame(uint32_t value) {

  _impl_.show_frame_ = value;
}
inline void UncompressedHeader::set_show_frame(uint32_t value) {
  _internal_set_show_frame(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.show_frame)
}

// uint32 error_resilient_mode = 8;
inline void UncompressedHeader::clear_error_resilient_mode() {
  _impl_.error_resilient_mode_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_error_resilient_mode() const {
  return _impl_.error_resilient_mode_;
}
inline uint32_t UncompressedHeader::error_resilient_mode() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.error_resilient_mode)
  return _internal_error_resilient_mode();
}
inline void UncompressedHeader::_internal_set_error_resilient_mode(uint32_t value) {

  _impl_.error_resilient_mode_ = value;
}
inline void UncompressedHeader::set_error_resilient_mode(uint32_t value) {
  _internal_set_error_resilient_mode(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.error_resilient_mode)
}

// uint32 frame_sync_code = 9;
inline void UncompressedHeader::clear_frame_sync_code() {
  _impl_.frame_sync_code_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_sync_code() const {
  return _impl_.frame_sync_code_;
}
inline uint32_t UncompressedHeader::frame_sync_code() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_sync_code)
  return _internal_frame_sync_code();
}
inline void UncompressedHeader::_internal_set_frame_sync_code(uint32_t value) {

  _impl_.frame_sync_code_ = value;
}
inline void UncompressedHeader::set_frame_sync_code(uint32_t value) {
  _internal_set_frame_sync_code(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_sync_code)
}

// .UncompressedHeader.ColorConfig color_config = 10;
inline bool UncompressedHeader::_internal_has_color_config() const {
  return this != internal_default_instance() && _impl_.color_config_ != nullptr;
}
inline bool UncompressedHeader::has_color_config() const {
  return _internal_has_color_config();
}
inline void UncompressedHeader::clear_color_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.color_config_ != nullptr) {
    delete _impl_.color_config_;
  }
  _impl_.color_config_ = nullptr;
}
inline const ::UncompressedHeader_ColorConfig& UncompressedHeader::_internal_color_config() const {
  const ::UncompressedHeader_ColorConfig* p = _impl_.color_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_ColorConfig&>(
      ::_UncompressedHeader_ColorConfig_default_instance_);
}
inline const ::UncompressedHeader_ColorConfig& UncompressedHeader::color_config() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.color_config)
  return _internal_color_config();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_color_config(
    ::UncompressedHeader_ColorConfig* color_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_config_);
  }
  _impl_.color_config_ = color_config;
  if (color_config) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.color_config)
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::release_color_config() {
  
  ::UncompressedHeader_ColorConfig* temp = _impl_.color_config_;
  _impl_.color_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::unsafe_arena_release_color_config() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.color_config)
  
  ::UncompressedHeader_ColorConfig* temp = _impl_.color_config_;
  _impl_.color_config_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::_internal_mutable_color_config() {
  
  if (_impl_.color_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_ColorConfig>(GetArenaForAllocation());
    _impl_.color_config_ = p;
  }
  return _impl_.color_config_;
}
inline ::UncompressedHeader_ColorConfig* UncompressedHeader::mutable_color_config() {
  ::UncompressedHeader_ColorConfig* _msg = _internal_mutable_color_config();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.color_config)
  return _msg;
}
inline void UncompressedHeader::set_allocated_color_config(::UncompressedHeader_ColorConfig* color_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.color_config_;
  }
  if (color_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(color_config);
    if (message_arena != submessage_arena) {
      color_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color_config, submessage_arena);
    }

  } else {

  }
  _impl_.color_config_ = color_config;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.color_config)
}

// uint32 frame_size_found_ref = 11;
inline void UncompressedHeader::clear_frame_size_found_ref() {
  _impl_.frame_size_found_ref_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_size_found_ref() const {
  return _impl_.frame_size_found_ref_;
}
inline uint32_t UncompressedHeader::frame_size_found_ref() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_size_found_ref)
  return _internal_frame_size_found_ref();
}
inline void UncompressedHeader::_internal_set_frame_size_found_ref(uint32_t value) {

  _impl_.frame_size_found_ref_ = value;
}
inline void UncompressedHeader::set_frame_size_found_ref(uint32_t value) {
  _internal_set_frame_size_found_ref(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_size_found_ref)
}

// .UncompressedHeader.FrameSize frame_size = 12;
inline bool UncompressedHeader::_internal_has_frame_size() const {
  return this != internal_default_instance() && _impl_.frame_size_ != nullptr;
}
inline bool UncompressedHeader::has_frame_size() const {
  return _internal_has_frame_size();
}
inline void UncompressedHeader::clear_frame_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.frame_size_ != nullptr) {
    delete _impl_.frame_size_;
  }
  _impl_.frame_size_ = nullptr;
}
inline const ::UncompressedHeader_FrameSize& UncompressedHeader::_internal_frame_size() const {
  const ::UncompressedHeader_FrameSize* p = _impl_.frame_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_FrameSize&>(
      ::_UncompressedHeader_FrameSize_default_instance_);
}
inline const ::UncompressedHeader_FrameSize& UncompressedHeader::frame_size() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_size)
  return _internal_frame_size();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_frame_size(
    ::UncompressedHeader_FrameSize* frame_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_size_);
  }
  _impl_.frame_size_ = frame_size;
  if (frame_size) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.frame_size)
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::release_frame_size() {
  
  ::UncompressedHeader_FrameSize* temp = _impl_.frame_size_;
  _impl_.frame_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::unsafe_arena_release_frame_size() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.frame_size)
  
  ::UncompressedHeader_FrameSize* temp = _impl_.frame_size_;
  _impl_.frame_size_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::_internal_mutable_frame_size() {
  
  if (_impl_.frame_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_FrameSize>(GetArenaForAllocation());
    _impl_.frame_size_ = p;
  }
  return _impl_.frame_size_;
}
inline ::UncompressedHeader_FrameSize* UncompressedHeader::mutable_frame_size() {
  ::UncompressedHeader_FrameSize* _msg = _internal_mutable_frame_size();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.frame_size)
  return _msg;
}
inline void UncompressedHeader::set_allocated_frame_size(::UncompressedHeader_FrameSize* frame_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_size_;
  }
  if (frame_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_size);
    if (message_arena != submessage_arena) {
      frame_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_size, submessage_arena);
    }

  } else {

  }
  _impl_.frame_size_ = frame_size;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.frame_size)
}

// .UncompressedHeader.RenderSize render_size = 13;
inline bool UncompressedHeader::_internal_has_render_size() const {
  return this != internal_default_instance() && _impl_.render_size_ != nullptr;
}
inline bool UncompressedHeader::has_render_size() const {
  return _internal_has_render_size();
}
inline void UncompressedHeader::clear_render_size() {
  if (GetArenaForAllocation() == nullptr && _impl_.render_size_ != nullptr) {
    delete _impl_.render_size_;
  }
  _impl_.render_size_ = nullptr;
}
inline const ::UncompressedHeader_RenderSize& UncompressedHeader::_internal_render_size() const {
  const ::UncompressedHeader_RenderSize* p = _impl_.render_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_RenderSize&>(
      ::_UncompressedHeader_RenderSize_default_instance_);
}
inline const ::UncompressedHeader_RenderSize& UncompressedHeader::render_size() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.render_size)
  return _internal_render_size();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_render_size(
    ::UncompressedHeader_RenderSize* render_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.render_size_);
  }
  _impl_.render_size_ = render_size;
  if (render_size) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.render_size)
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::release_render_size() {
  
  ::UncompressedHeader_RenderSize* temp = _impl_.render_size_;
  _impl_.render_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::unsafe_arena_release_render_size() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.render_size)
  
  ::UncompressedHeader_RenderSize* temp = _impl_.render_size_;
  _impl_.render_size_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::_internal_mutable_render_size() {
  
  if (_impl_.render_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_RenderSize>(GetArenaForAllocation());
    _impl_.render_size_ = p;
  }
  return _impl_.render_size_;
}
inline ::UncompressedHeader_RenderSize* UncompressedHeader::mutable_render_size() {
  ::UncompressedHeader_RenderSize* _msg = _internal_mutable_render_size();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.render_size)
  return _msg;
}
inline void UncompressedHeader::set_allocated_render_size(::UncompressedHeader_RenderSize* render_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.render_size_;
  }
  if (render_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(render_size);
    if (message_arena != submessage_arena) {
      render_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, render_size, submessage_arena);
    }

  } else {

  }
  _impl_.render_size_ = render_size;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.render_size)
}

// uint32 intra_only = 14;
inline void UncompressedHeader::clear_intra_only() {
  _impl_.intra_only_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_intra_only() const {
  return _impl_.intra_only_;
}
inline uint32_t UncompressedHeader::intra_only() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.intra_only)
  return _internal_intra_only();
}
inline void UncompressedHeader::_internal_set_intra_only(uint32_t value) {

  _impl_.intra_only_ = value;
}
inline void UncompressedHeader::set_intra_only(uint32_t value) {
  _internal_set_intra_only(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.intra_only)
}

// uint32 reset_frame_context = 15;
inline void UncompressedHeader::clear_reset_frame_context() {
  _impl_.reset_frame_context_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_reset_frame_context() const {
  return _impl_.reset_frame_context_;
}
inline uint32_t UncompressedHeader::reset_frame_context() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.reset_frame_context)
  return _internal_reset_frame_context();
}
inline void UncompressedHeader::_internal_set_reset_frame_context(uint32_t value) {

  _impl_.reset_frame_context_ = value;
}
inline void UncompressedHeader::set_reset_frame_context(uint32_t value) {
  _internal_set_reset_frame_context(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.reset_frame_context)
}

// uint32 refresh_frame_flags = 16;
inline void UncompressedHeader::clear_refresh_frame_flags() {
  _impl_.refresh_frame_flags_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_refresh_frame_flags() const {
  return _impl_.refresh_frame_flags_;
}
inline uint32_t UncompressedHeader::refresh_frame_flags() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.refresh_frame_flags)
  return _internal_refresh_frame_flags();
}
inline void UncompressedHeader::_internal_set_refresh_frame_flags(uint32_t value) {

  _impl_.refresh_frame_flags_ = value;
}
inline void UncompressedHeader::set_refresh_frame_flags(uint32_t value) {
  _internal_set_refresh_frame_flags(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.refresh_frame_flags)
}

// uint32 ref_frame_idx = 17;
inline void UncompressedHeader::clear_ref_frame_idx() {
  _impl_.ref_frame_idx_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_ref_frame_idx() const {
  return _impl_.ref_frame_idx_;
}
inline uint32_t UncompressedHeader::ref_frame_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ref_frame_idx)
  return _internal_ref_frame_idx();
}
inline void UncompressedHeader::_internal_set_ref_frame_idx(uint32_t value) {

  _impl_.ref_frame_idx_ = value;
}
inline void UncompressedHeader::set_ref_frame_idx(uint32_t value) {
  _internal_set_ref_frame_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ref_frame_idx)
}

// uint32 ref_frame_sign_bias = 18;
inline void UncompressedHeader::clear_ref_frame_sign_bias() {
  _impl_.ref_frame_sign_bias_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_ref_frame_sign_bias() const {
  return _impl_.ref_frame_sign_bias_;
}
inline uint32_t UncompressedHeader::ref_frame_sign_bias() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.ref_frame_sign_bias)
  return _internal_ref_frame_sign_bias();
}
inline void UncompressedHeader::_internal_set_ref_frame_sign_bias(uint32_t value) {

  _impl_.ref_frame_sign_bias_ = value;
}
inline void UncompressedHeader::set_ref_frame_sign_bias(uint32_t value) {
  _internal_set_ref_frame_sign_bias(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.ref_frame_sign_bias)
}

// uint32 allow_high_precision_mv = 19;
inline void UncompressedHeader::clear_allow_high_precision_mv() {
  _impl_.allow_high_precision_mv_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_allow_high_precision_mv() const {
  return _impl_.allow_high_precision_mv_;
}
inline uint32_t UncompressedHeader::allow_high_precision_mv() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.allow_high_precision_mv)
  return _internal_allow_high_precision_mv();
}
inline void UncompressedHeader::_internal_set_allow_high_precision_mv(uint32_t value) {

  _impl_.allow_high_precision_mv_ = value;
}
inline void UncompressedHeader::set_allow_high_precision_mv(uint32_t value) {
  _internal_set_allow_high_precision_mv(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.allow_high_precision_mv)
}

// .UncompressedHeader.ReadInterpolationFilter read_interpolation_filter = 20;
inline bool UncompressedHeader::_internal_has_read_interpolation_filter() const {
  return this != internal_default_instance() && _impl_.read_interpolation_filter_ != nullptr;
}
inline bool UncompressedHeader::has_read_interpolation_filter() const {
  return _internal_has_read_interpolation_filter();
}
inline void UncompressedHeader::clear_read_interpolation_filter() {
  if (GetArenaForAllocation() == nullptr && _impl_.read_interpolation_filter_ != nullptr) {
    delete _impl_.read_interpolation_filter_;
  }
  _impl_.read_interpolation_filter_ = nullptr;
}
inline const ::UncompressedHeader_ReadInterpolationFilter& UncompressedHeader::_internal_read_interpolation_filter() const {
  const ::UncompressedHeader_ReadInterpolationFilter* p = _impl_.read_interpolation_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_ReadInterpolationFilter&>(
      ::_UncompressedHeader_ReadInterpolationFilter_default_instance_);
}
inline const ::UncompressedHeader_ReadInterpolationFilter& UncompressedHeader::read_interpolation_filter() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.read_interpolation_filter)
  return _internal_read_interpolation_filter();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_read_interpolation_filter(
    ::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_interpolation_filter_);
  }
  _impl_.read_interpolation_filter_ = read_interpolation_filter;
  if (read_interpolation_filter) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.read_interpolation_filter)
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::release_read_interpolation_filter() {
  
  ::UncompressedHeader_ReadInterpolationFilter* temp = _impl_.read_interpolation_filter_;
  _impl_.read_interpolation_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::unsafe_arena_release_read_interpolation_filter() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.read_interpolation_filter)
  
  ::UncompressedHeader_ReadInterpolationFilter* temp = _impl_.read_interpolation_filter_;
  _impl_.read_interpolation_filter_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::_internal_mutable_read_interpolation_filter() {
  
  if (_impl_.read_interpolation_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_ReadInterpolationFilter>(GetArenaForAllocation());
    _impl_.read_interpolation_filter_ = p;
  }
  return _impl_.read_interpolation_filter_;
}
inline ::UncompressedHeader_ReadInterpolationFilter* UncompressedHeader::mutable_read_interpolation_filter() {
  ::UncompressedHeader_ReadInterpolationFilter* _msg = _internal_mutable_read_interpolation_filter();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.read_interpolation_filter)
  return _msg;
}
inline void UncompressedHeader::set_allocated_read_interpolation_filter(::UncompressedHeader_ReadInterpolationFilter* read_interpolation_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.read_interpolation_filter_;
  }
  if (read_interpolation_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_interpolation_filter);
    if (message_arena != submessage_arena) {
      read_interpolation_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_interpolation_filter, submessage_arena);
    }

  } else {

  }
  _impl_.read_interpolation_filter_ = read_interpolation_filter;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.read_interpolation_filter)
}

// uint32 frame_parallel_decoding_mode = 21;
inline void UncompressedHeader::clear_frame_parallel_decoding_mode() {
  _impl_.frame_parallel_decoding_mode_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_parallel_decoding_mode() const {
  return _impl_.frame_parallel_decoding_mode_;
}
inline uint32_t UncompressedHeader::frame_parallel_decoding_mode() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_parallel_decoding_mode)
  return _internal_frame_parallel_decoding_mode();
}
inline void UncompressedHeader::_internal_set_frame_parallel_decoding_mode(uint32_t value) {

  _impl_.frame_parallel_decoding_mode_ = value;
}
inline void UncompressedHeader::set_frame_parallel_decoding_mode(uint32_t value) {
  _internal_set_frame_parallel_decoding_mode(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_parallel_decoding_mode)
}

// uint32 frame_context_idx = 22;
inline void UncompressedHeader::clear_frame_context_idx() {
  _impl_.frame_context_idx_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_frame_context_idx() const {
  return _impl_.frame_context_idx_;
}
inline uint32_t UncompressedHeader::frame_context_idx() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.frame_context_idx)
  return _internal_frame_context_idx();
}
inline void UncompressedHeader::_internal_set_frame_context_idx(uint32_t value) {

  _impl_.frame_context_idx_ = value;
}
inline void UncompressedHeader::set_frame_context_idx(uint32_t value) {
  _internal_set_frame_context_idx(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.frame_context_idx)
}

// .UncompressedHeader.LoopFilterParams loop_filter_params = 23;
inline bool UncompressedHeader::_internal_has_loop_filter_params() const {
  return this != internal_default_instance() && _impl_.loop_filter_params_ != nullptr;
}
inline bool UncompressedHeader::has_loop_filter_params() const {
  return _internal_has_loop_filter_params();
}
inline void UncompressedHeader::clear_loop_filter_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.loop_filter_params_ != nullptr) {
    delete _impl_.loop_filter_params_;
  }
  _impl_.loop_filter_params_ = nullptr;
}
inline const ::UncompressedHeader_LoopFilterParams& UncompressedHeader::_internal_loop_filter_params() const {
  const ::UncompressedHeader_LoopFilterParams* p = _impl_.loop_filter_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_LoopFilterParams&>(
      ::_UncompressedHeader_LoopFilterParams_default_instance_);
}
inline const ::UncompressedHeader_LoopFilterParams& UncompressedHeader::loop_filter_params() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.loop_filter_params)
  return _internal_loop_filter_params();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_loop_filter_params(
    ::UncompressedHeader_LoopFilterParams* loop_filter_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loop_filter_params_);
  }
  _impl_.loop_filter_params_ = loop_filter_params;
  if (loop_filter_params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.loop_filter_params)
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::release_loop_filter_params() {
  
  ::UncompressedHeader_LoopFilterParams* temp = _impl_.loop_filter_params_;
  _impl_.loop_filter_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::unsafe_arena_release_loop_filter_params() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.loop_filter_params)
  
  ::UncompressedHeader_LoopFilterParams* temp = _impl_.loop_filter_params_;
  _impl_.loop_filter_params_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::_internal_mutable_loop_filter_params() {
  
  if (_impl_.loop_filter_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_LoopFilterParams>(GetArenaForAllocation());
    _impl_.loop_filter_params_ = p;
  }
  return _impl_.loop_filter_params_;
}
inline ::UncompressedHeader_LoopFilterParams* UncompressedHeader::mutable_loop_filter_params() {
  ::UncompressedHeader_LoopFilterParams* _msg = _internal_mutable_loop_filter_params();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.loop_filter_params)
  return _msg;
}
inline void UncompressedHeader::set_allocated_loop_filter_params(::UncompressedHeader_LoopFilterParams* loop_filter_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loop_filter_params_;
  }
  if (loop_filter_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loop_filter_params);
    if (message_arena != submessage_arena) {
      loop_filter_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loop_filter_params, submessage_arena);
    }

  } else {

  }
  _impl_.loop_filter_params_ = loop_filter_params;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.loop_filter_params)
}

// .UncompressedHeader.QuantizationParams quantization_params = 24;
inline bool UncompressedHeader::_internal_has_quantization_params() const {
  return this != internal_default_instance() && _impl_.quantization_params_ != nullptr;
}
inline bool UncompressedHeader::has_quantization_params() const {
  return _internal_has_quantization_params();
}
inline void UncompressedHeader::clear_quantization_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.quantization_params_ != nullptr) {
    delete _impl_.quantization_params_;
  }
  _impl_.quantization_params_ = nullptr;
}
inline const ::UncompressedHeader_QuantizationParams& UncompressedHeader::_internal_quantization_params() const {
  const ::UncompressedHeader_QuantizationParams* p = _impl_.quantization_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_QuantizationParams&>(
      ::_UncompressedHeader_QuantizationParams_default_instance_);
}
inline const ::UncompressedHeader_QuantizationParams& UncompressedHeader::quantization_params() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.quantization_params)
  return _internal_quantization_params();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_quantization_params(
    ::UncompressedHeader_QuantizationParams* quantization_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quantization_params_);
  }
  _impl_.quantization_params_ = quantization_params;
  if (quantization_params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.quantization_params)
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::release_quantization_params() {
  
  ::UncompressedHeader_QuantizationParams* temp = _impl_.quantization_params_;
  _impl_.quantization_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::unsafe_arena_release_quantization_params() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.quantization_params)
  
  ::UncompressedHeader_QuantizationParams* temp = _impl_.quantization_params_;
  _impl_.quantization_params_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::_internal_mutable_quantization_params() {
  
  if (_impl_.quantization_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_QuantizationParams>(GetArenaForAllocation());
    _impl_.quantization_params_ = p;
  }
  return _impl_.quantization_params_;
}
inline ::UncompressedHeader_QuantizationParams* UncompressedHeader::mutable_quantization_params() {
  ::UncompressedHeader_QuantizationParams* _msg = _internal_mutable_quantization_params();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.quantization_params)
  return _msg;
}
inline void UncompressedHeader::set_allocated_quantization_params(::UncompressedHeader_QuantizationParams* quantization_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.quantization_params_;
  }
  if (quantization_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(quantization_params);
    if (message_arena != submessage_arena) {
      quantization_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quantization_params, submessage_arena);
    }

  } else {

  }
  _impl_.quantization_params_ = quantization_params;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.quantization_params)
}

// .UncompressedHeader.SegmentationParams segmentation_params = 25;
inline bool UncompressedHeader::_internal_has_segmentation_params() const {
  return this != internal_default_instance() && _impl_.segmentation_params_ != nullptr;
}
inline bool UncompressedHeader::has_segmentation_params() const {
  return _internal_has_segmentation_params();
}
inline void UncompressedHeader::clear_segmentation_params() {
  if (GetArenaForAllocation() == nullptr && _impl_.segmentation_params_ != nullptr) {
    delete _impl_.segmentation_params_;
  }
  _impl_.segmentation_params_ = nullptr;
}
inline const ::UncompressedHeader_SegmentationParams& UncompressedHeader::_internal_segmentation_params() const {
  const ::UncompressedHeader_SegmentationParams* p = _impl_.segmentation_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_SegmentationParams&>(
      ::_UncompressedHeader_SegmentationParams_default_instance_);
}
inline const ::UncompressedHeader_SegmentationParams& UncompressedHeader::segmentation_params() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.segmentation_params)
  return _internal_segmentation_params();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_segmentation_params(
    ::UncompressedHeader_SegmentationParams* segmentation_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.segmentation_params_);
  }
  _impl_.segmentation_params_ = segmentation_params;
  if (segmentation_params) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.segmentation_params)
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::release_segmentation_params() {
  
  ::UncompressedHeader_SegmentationParams* temp = _impl_.segmentation_params_;
  _impl_.segmentation_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::unsafe_arena_release_segmentation_params() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.segmentation_params)
  
  ::UncompressedHeader_SegmentationParams* temp = _impl_.segmentation_params_;
  _impl_.segmentation_params_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::_internal_mutable_segmentation_params() {
  
  if (_impl_.segmentation_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_SegmentationParams>(GetArenaForAllocation());
    _impl_.segmentation_params_ = p;
  }
  return _impl_.segmentation_params_;
}
inline ::UncompressedHeader_SegmentationParams* UncompressedHeader::mutable_segmentation_params() {
  ::UncompressedHeader_SegmentationParams* _msg = _internal_mutable_segmentation_params();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.segmentation_params)
  return _msg;
}
inline void UncompressedHeader::set_allocated_segmentation_params(::UncompressedHeader_SegmentationParams* segmentation_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.segmentation_params_;
  }
  if (segmentation_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(segmentation_params);
    if (message_arena != submessage_arena) {
      segmentation_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segmentation_params, submessage_arena);
    }

  } else {

  }
  _impl_.segmentation_params_ = segmentation_params;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.segmentation_params)
}

// .UncompressedHeader.TileInfo tile_info = 26;
inline bool UncompressedHeader::_internal_has_tile_info() const {
  return this != internal_default_instance() && _impl_.tile_info_ != nullptr;
}
inline bool UncompressedHeader::has_tile_info() const {
  return _internal_has_tile_info();
}
inline void UncompressedHeader::clear_tile_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.tile_info_ != nullptr) {
    delete _impl_.tile_info_;
  }
  _impl_.tile_info_ = nullptr;
}
inline const ::UncompressedHeader_TileInfo& UncompressedHeader::_internal_tile_info() const {
  const ::UncompressedHeader_TileInfo* p = _impl_.tile_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader_TileInfo&>(
      ::_UncompressedHeader_TileInfo_default_instance_);
}
inline const ::UncompressedHeader_TileInfo& UncompressedHeader::tile_info() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.tile_info)
  return _internal_tile_info();
}
inline void UncompressedHeader::unsafe_arena_set_allocated_tile_info(
    ::UncompressedHeader_TileInfo* tile_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tile_info_);
  }
  _impl_.tile_info_ = tile_info;
  if (tile_info) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UncompressedHeader.tile_info)
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::release_tile_info() {
  
  ::UncompressedHeader_TileInfo* temp = _impl_.tile_info_;
  _impl_.tile_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::unsafe_arena_release_tile_info() {
  // @@protoc_insertion_point(field_release:UncompressedHeader.tile_info)
  
  ::UncompressedHeader_TileInfo* temp = _impl_.tile_info_;
  _impl_.tile_info_ = nullptr;
  return temp;
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::_internal_mutable_tile_info() {
  
  if (_impl_.tile_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader_TileInfo>(GetArenaForAllocation());
    _impl_.tile_info_ = p;
  }
  return _impl_.tile_info_;
}
inline ::UncompressedHeader_TileInfo* UncompressedHeader::mutable_tile_info() {
  ::UncompressedHeader_TileInfo* _msg = _internal_mutable_tile_info();
  // @@protoc_insertion_point(field_mutable:UncompressedHeader.tile_info)
  return _msg;
}
inline void UncompressedHeader::set_allocated_tile_info(::UncompressedHeader_TileInfo* tile_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tile_info_;
  }
  if (tile_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tile_info);
    if (message_arena != submessage_arena) {
      tile_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tile_info, submessage_arena);
    }

  } else {

  }
  _impl_.tile_info_ = tile_info;
  // @@protoc_insertion_point(field_set_allocated:UncompressedHeader.tile_info)
}

// uint32 header_size_in_bytes = 27;
inline void UncompressedHeader::clear_header_size_in_bytes() {
  _impl_.header_size_in_bytes_ = 0u;
}
inline uint32_t UncompressedHeader::_internal_header_size_in_bytes() const {
  return _impl_.header_size_in_bytes_;
}
inline uint32_t UncompressedHeader::header_size_in_bytes() const {
  // @@protoc_insertion_point(field_get:UncompressedHeader.header_size_in_bytes)
  return _internal_header_size_in_bytes();
}
inline void UncompressedHeader::_internal_set_header_size_in_bytes(uint32_t value) {

  _impl_.header_size_in_bytes_ = value;
}
inline void UncompressedHeader::set_header_size_in_bytes(uint32_t value) {
  _internal_set_header_size_in_bytes(value);
  // @@protoc_insertion_point(field_set:UncompressedHeader.header_size_in_bytes)
}

// -------------------------------------------------------------------

// CompressedHeader

// bytes read_tx_mode = 1;
inline void CompressedHeader::clear_read_tx_mode() {
  _impl_.read_tx_mode_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_tx_mode() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_tx_mode)
  return _internal_read_tx_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_tx_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_tx_mode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_tx_mode)
}
inline std::string* CompressedHeader::mutable_read_tx_mode() {
  std::string* _s = _internal_mutable_read_tx_mode();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_tx_mode)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_tx_mode() const {
  return _impl_.read_tx_mode_.Get();
}
inline void CompressedHeader::_internal_set_read_tx_mode(const std::string& value) {

  _impl_.read_tx_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_tx_mode() {

  return _impl_.read_tx_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_tx_mode() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_tx_mode)
  return _impl_.read_tx_mode_.Release();
}
inline void CompressedHeader::set_allocated_read_tx_mode(std::string* read_tx_mode) {
  if (read_tx_mode != nullptr) {

  } else {

  }
  _impl_.read_tx_mode_.SetAllocated(read_tx_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_tx_mode_.IsDefault()) {
    _impl_.read_tx_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_tx_mode)
}

// bytes tx_mode_probs = 2;
inline void CompressedHeader::clear_tx_mode_probs() {
  _impl_.tx_mode_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::tx_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.tx_mode_probs)
  return _internal_tx_mode_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_tx_mode_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_mode_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.tx_mode_probs)
}
inline std::string* CompressedHeader::mutable_tx_mode_probs() {
  std::string* _s = _internal_mutable_tx_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.tx_mode_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_tx_mode_probs() const {
  return _impl_.tx_mode_probs_.Get();
}
inline void CompressedHeader::_internal_set_tx_mode_probs(const std::string& value) {

  _impl_.tx_mode_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_tx_mode_probs() {

  return _impl_.tx_mode_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_tx_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.tx_mode_probs)
  return _impl_.tx_mode_probs_.Release();
}
inline void CompressedHeader::set_allocated_tx_mode_probs(std::string* tx_mode_probs) {
  if (tx_mode_probs != nullptr) {

  } else {

  }
  _impl_.tx_mode_probs_.SetAllocated(tx_mode_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_mode_probs_.IsDefault()) {
    _impl_.tx_mode_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.tx_mode_probs)
}

// bytes read_coef_probs = 3;
inline void CompressedHeader::clear_read_coef_probs() {
  _impl_.read_coef_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_coef_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_coef_probs)
  return _internal_read_coef_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_coef_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_coef_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_coef_probs)
}
inline std::string* CompressedHeader::mutable_read_coef_probs() {
  std::string* _s = _internal_mutable_read_coef_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_coef_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_coef_probs() const {
  return _impl_.read_coef_probs_.Get();
}
inline void CompressedHeader::_internal_set_read_coef_probs(const std::string& value) {

  _impl_.read_coef_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_coef_probs() {

  return _impl_.read_coef_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_coef_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_coef_probs)
  return _impl_.read_coef_probs_.Release();
}
inline void CompressedHeader::set_allocated_read_coef_probs(std::string* read_coef_probs) {
  if (read_coef_probs != nullptr) {

  } else {

  }
  _impl_.read_coef_probs_.SetAllocated(read_coef_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_coef_probs_.IsDefault()) {
    _impl_.read_coef_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_coef_probs)
}

// bytes read_skip_prob = 4;
inline void CompressedHeader::clear_read_skip_prob() {
  _impl_.read_skip_prob_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_skip_prob() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_skip_prob)
  return _internal_read_skip_prob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_skip_prob(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_skip_prob_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_skip_prob)
}
inline std::string* CompressedHeader::mutable_read_skip_prob() {
  std::string* _s = _internal_mutable_read_skip_prob();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_skip_prob)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_skip_prob() const {
  return _impl_.read_skip_prob_.Get();
}
inline void CompressedHeader::_internal_set_read_skip_prob(const std::string& value) {

  _impl_.read_skip_prob_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_skip_prob() {

  return _impl_.read_skip_prob_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_skip_prob() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_skip_prob)
  return _impl_.read_skip_prob_.Release();
}
inline void CompressedHeader::set_allocated_read_skip_prob(std::string* read_skip_prob) {
  if (read_skip_prob != nullptr) {

  } else {

  }
  _impl_.read_skip_prob_.SetAllocated(read_skip_prob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_skip_prob_.IsDefault()) {
    _impl_.read_skip_prob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_skip_prob)
}

// bytes read_inter_mode_probs = 5;
inline void CompressedHeader::clear_read_inter_mode_probs() {
  _impl_.read_inter_mode_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_inter_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_inter_mode_probs)
  return _internal_read_inter_mode_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_inter_mode_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_inter_mode_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_inter_mode_probs)
}
inline std::string* CompressedHeader::mutable_read_inter_mode_probs() {
  std::string* _s = _internal_mutable_read_inter_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_inter_mode_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_inter_mode_probs() const {
  return _impl_.read_inter_mode_probs_.Get();
}
inline void CompressedHeader::_internal_set_read_inter_mode_probs(const std::string& value) {

  _impl_.read_inter_mode_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_inter_mode_probs() {

  return _impl_.read_inter_mode_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_inter_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_inter_mode_probs)
  return _impl_.read_inter_mode_probs_.Release();
}
inline void CompressedHeader::set_allocated_read_inter_mode_probs(std::string* read_inter_mode_probs) {
  if (read_inter_mode_probs != nullptr) {

  } else {

  }
  _impl_.read_inter_mode_probs_.SetAllocated(read_inter_mode_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_inter_mode_probs_.IsDefault()) {
    _impl_.read_inter_mode_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_inter_mode_probs)
}

// bytes read_interp_filter_probs = 6;
inline void CompressedHeader::clear_read_interp_filter_probs() {
  _impl_.read_interp_filter_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_interp_filter_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_interp_filter_probs)
  return _internal_read_interp_filter_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_interp_filter_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_interp_filter_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_interp_filter_probs)
}
inline std::string* CompressedHeader::mutable_read_interp_filter_probs() {
  std::string* _s = _internal_mutable_read_interp_filter_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_interp_filter_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_interp_filter_probs() const {
  return _impl_.read_interp_filter_probs_.Get();
}
inline void CompressedHeader::_internal_set_read_interp_filter_probs(const std::string& value) {

  _impl_.read_interp_filter_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_interp_filter_probs() {

  return _impl_.read_interp_filter_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_interp_filter_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_interp_filter_probs)
  return _impl_.read_interp_filter_probs_.Release();
}
inline void CompressedHeader::set_allocated_read_interp_filter_probs(std::string* read_interp_filter_probs) {
  if (read_interp_filter_probs != nullptr) {

  } else {

  }
  _impl_.read_interp_filter_probs_.SetAllocated(read_interp_filter_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_interp_filter_probs_.IsDefault()) {
    _impl_.read_interp_filter_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_interp_filter_probs)
}

// bytes read_is_inter_probs = 7;
inline void CompressedHeader::clear_read_is_inter_probs() {
  _impl_.read_is_inter_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_is_inter_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_is_inter_probs)
  return _internal_read_is_inter_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_is_inter_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_is_inter_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_is_inter_probs)
}
inline std::string* CompressedHeader::mutable_read_is_inter_probs() {
  std::string* _s = _internal_mutable_read_is_inter_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_is_inter_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_is_inter_probs() const {
  return _impl_.read_is_inter_probs_.Get();
}
inline void CompressedHeader::_internal_set_read_is_inter_probs(const std::string& value) {

  _impl_.read_is_inter_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_is_inter_probs() {

  return _impl_.read_is_inter_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_is_inter_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_is_inter_probs)
  return _impl_.read_is_inter_probs_.Release();
}
inline void CompressedHeader::set_allocated_read_is_inter_probs(std::string* read_is_inter_probs) {
  if (read_is_inter_probs != nullptr) {

  } else {

  }
  _impl_.read_is_inter_probs_.SetAllocated(read_is_inter_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_is_inter_probs_.IsDefault()) {
    _impl_.read_is_inter_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_is_inter_probs)
}

// bytes frame_reference_mode = 8;
inline void CompressedHeader::clear_frame_reference_mode() {
  _impl_.frame_reference_mode_.ClearToEmpty();
}
inline const std::string& CompressedHeader::frame_reference_mode() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.frame_reference_mode)
  return _internal_frame_reference_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_frame_reference_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_reference_mode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.frame_reference_mode)
}
inline std::string* CompressedHeader::mutable_frame_reference_mode() {
  std::string* _s = _internal_mutable_frame_reference_mode();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.frame_reference_mode)
  return _s;
}
inline const std::string& CompressedHeader::_internal_frame_reference_mode() const {
  return _impl_.frame_reference_mode_.Get();
}
inline void CompressedHeader::_internal_set_frame_reference_mode(const std::string& value) {

  _impl_.frame_reference_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_frame_reference_mode() {

  return _impl_.frame_reference_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_frame_reference_mode() {
  // @@protoc_insertion_point(field_release:CompressedHeader.frame_reference_mode)
  return _impl_.frame_reference_mode_.Release();
}
inline void CompressedHeader::set_allocated_frame_reference_mode(std::string* frame_reference_mode) {
  if (frame_reference_mode != nullptr) {

  } else {

  }
  _impl_.frame_reference_mode_.SetAllocated(frame_reference_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_reference_mode_.IsDefault()) {
    _impl_.frame_reference_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.frame_reference_mode)
}

// bytes frame_reference_mode_probs = 9;
inline void CompressedHeader::clear_frame_reference_mode_probs() {
  _impl_.frame_reference_mode_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::frame_reference_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.frame_reference_mode_probs)
  return _internal_frame_reference_mode_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_frame_reference_mode_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_reference_mode_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.frame_reference_mode_probs)
}
inline std::string* CompressedHeader::mutable_frame_reference_mode_probs() {
  std::string* _s = _internal_mutable_frame_reference_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.frame_reference_mode_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_frame_reference_mode_probs() const {
  return _impl_.frame_reference_mode_probs_.Get();
}
inline void CompressedHeader::_internal_set_frame_reference_mode_probs(const std::string& value) {

  _impl_.frame_reference_mode_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_frame_reference_mode_probs() {

  return _impl_.frame_reference_mode_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_frame_reference_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.frame_reference_mode_probs)
  return _impl_.frame_reference_mode_probs_.Release();
}
inline void CompressedHeader::set_allocated_frame_reference_mode_probs(std::string* frame_reference_mode_probs) {
  if (frame_reference_mode_probs != nullptr) {

  } else {

  }
  _impl_.frame_reference_mode_probs_.SetAllocated(frame_reference_mode_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_reference_mode_probs_.IsDefault()) {
    _impl_.frame_reference_mode_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.frame_reference_mode_probs)
}

// bytes read_y_mode_probs = 10;
inline void CompressedHeader::clear_read_y_mode_probs() {
  _impl_.read_y_mode_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_y_mode_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_y_mode_probs)
  return _internal_read_y_mode_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_y_mode_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_y_mode_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_y_mode_probs)
}
inline std::string* CompressedHeader::mutable_read_y_mode_probs() {
  std::string* _s = _internal_mutable_read_y_mode_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_y_mode_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_y_mode_probs() const {
  return _impl_.read_y_mode_probs_.Get();
}
inline void CompressedHeader::_internal_set_read_y_mode_probs(const std::string& value) {

  _impl_.read_y_mode_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_y_mode_probs() {

  return _impl_.read_y_mode_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_y_mode_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_y_mode_probs)
  return _impl_.read_y_mode_probs_.Release();
}
inline void CompressedHeader::set_allocated_read_y_mode_probs(std::string* read_y_mode_probs) {
  if (read_y_mode_probs != nullptr) {

  } else {

  }
  _impl_.read_y_mode_probs_.SetAllocated(read_y_mode_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_y_mode_probs_.IsDefault()) {
    _impl_.read_y_mode_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_y_mode_probs)
}

// bytes read_partition_probs = 11;
inline void CompressedHeader::clear_read_partition_probs() {
  _impl_.read_partition_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::read_partition_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.read_partition_probs)
  return _internal_read_partition_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_read_partition_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_partition_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.read_partition_probs)
}
inline std::string* CompressedHeader::mutable_read_partition_probs() {
  std::string* _s = _internal_mutable_read_partition_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.read_partition_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_read_partition_probs() const {
  return _impl_.read_partition_probs_.Get();
}
inline void CompressedHeader::_internal_set_read_partition_probs(const std::string& value) {

  _impl_.read_partition_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_read_partition_probs() {

  return _impl_.read_partition_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_read_partition_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.read_partition_probs)
  return _impl_.read_partition_probs_.Release();
}
inline void CompressedHeader::set_allocated_read_partition_probs(std::string* read_partition_probs) {
  if (read_partition_probs != nullptr) {

  } else {

  }
  _impl_.read_partition_probs_.SetAllocated(read_partition_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_partition_probs_.IsDefault()) {
    _impl_.read_partition_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.read_partition_probs)
}

// bytes mv_probs = 12;
inline void CompressedHeader::clear_mv_probs() {
  _impl_.mv_probs_.ClearToEmpty();
}
inline const std::string& CompressedHeader::mv_probs() const {
  // @@protoc_insertion_point(field_get:CompressedHeader.mv_probs)
  return _internal_mv_probs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompressedHeader::set_mv_probs(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mv_probs_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CompressedHeader.mv_probs)
}
inline std::string* CompressedHeader::mutable_mv_probs() {
  std::string* _s = _internal_mutable_mv_probs();
  // @@protoc_insertion_point(field_mutable:CompressedHeader.mv_probs)
  return _s;
}
inline const std::string& CompressedHeader::_internal_mv_probs() const {
  return _impl_.mv_probs_.Get();
}
inline void CompressedHeader::_internal_set_mv_probs(const std::string& value) {

  _impl_.mv_probs_.Set(value, GetArenaForAllocation());
}
inline std::string* CompressedHeader::_internal_mutable_mv_probs() {

  return _impl_.mv_probs_.Mutable(GetArenaForAllocation());
}
inline std::string* CompressedHeader::release_mv_probs() {
  // @@protoc_insertion_point(field_release:CompressedHeader.mv_probs)
  return _impl_.mv_probs_.Release();
}
inline void CompressedHeader::set_allocated_mv_probs(std::string* mv_probs) {
  if (mv_probs != nullptr) {

  } else {

  }
  _impl_.mv_probs_.SetAllocated(mv_probs, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mv_probs_.IsDefault()) {
    _impl_.mv_probs_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CompressedHeader.mv_probs)
}

// -------------------------------------------------------------------

// Block_IntraFrameModeInfo

// bytes segment_id = 1;
inline void Block_IntraFrameModeInfo::clear_segment_id() {
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& Block_IntraFrameModeInfo::segment_id() const {
  // @@protoc_insertion_point(field_get:Block.IntraFrameModeInfo.segment_id)
  return _internal_segment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_IntraFrameModeInfo::set_segment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segment_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.IntraFrameModeInfo.segment_id)
}
inline std::string* Block_IntraFrameModeInfo::mutable_segment_id() {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:Block.IntraFrameModeInfo.segment_id)
  return _s;
}
inline const std::string& Block_IntraFrameModeInfo::_internal_segment_id() const {
  return _impl_.segment_id_.Get();
}
inline void Block_IntraFrameModeInfo::_internal_set_segment_id(const std::string& value) {

  _impl_.segment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::_internal_mutable_segment_id() {

  return _impl_.segment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::release_segment_id() {
  // @@protoc_insertion_point(field_release:Block.IntraFrameModeInfo.segment_id)
  return _impl_.segment_id_.Release();
}
inline void Block_IntraFrameModeInfo::set_allocated_segment_id(std::string* segment_id) {
  if (segment_id != nullptr) {

  } else {

  }
  _impl_.segment_id_.SetAllocated(segment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.IntraFrameModeInfo.segment_id)
}

// bytes skip = 2;
inline void Block_IntraFrameModeInfo::clear_skip() {
  _impl_.skip_.ClearToEmpty();
}
inline const std::string& Block_IntraFrameModeInfo::skip() const {
  // @@protoc_insertion_point(field_get:Block.IntraFrameModeInfo.skip)
  return _internal_skip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_IntraFrameModeInfo::set_skip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.skip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.IntraFrameModeInfo.skip)
}
inline std::string* Block_IntraFrameModeInfo::mutable_skip() {
  std::string* _s = _internal_mutable_skip();
  // @@protoc_insertion_point(field_mutable:Block.IntraFrameModeInfo.skip)
  return _s;
}
inline const std::string& Block_IntraFrameModeInfo::_internal_skip() const {
  return _impl_.skip_.Get();
}
inline void Block_IntraFrameModeInfo::_internal_set_skip(const std::string& value) {

  _impl_.skip_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::_internal_mutable_skip() {

  return _impl_.skip_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::release_skip() {
  // @@protoc_insertion_point(field_release:Block.IntraFrameModeInfo.skip)
  return _impl_.skip_.Release();
}
inline void Block_IntraFrameModeInfo::set_allocated_skip(std::string* skip) {
  if (skip != nullptr) {

  } else {

  }
  _impl_.skip_.SetAllocated(skip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.skip_.IsDefault()) {
    _impl_.skip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.IntraFrameModeInfo.skip)
}

// bytes tx_size = 3;
inline void Block_IntraFrameModeInfo::clear_tx_size() {
  _impl_.tx_size_.ClearToEmpty();
}
inline const std::string& Block_IntraFrameModeInfo::tx_size() const {
  // @@protoc_insertion_point(field_get:Block.IntraFrameModeInfo.tx_size)
  return _internal_tx_size();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_IntraFrameModeInfo::set_tx_size(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_size_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.IntraFrameModeInfo.tx_size)
}
inline std::string* Block_IntraFrameModeInfo::mutable_tx_size() {
  std::string* _s = _internal_mutable_tx_size();
  // @@protoc_insertion_point(field_mutable:Block.IntraFrameModeInfo.tx_size)
  return _s;
}
inline const std::string& Block_IntraFrameModeInfo::_internal_tx_size() const {
  return _impl_.tx_size_.Get();
}
inline void Block_IntraFrameModeInfo::_internal_set_tx_size(const std::string& value) {

  _impl_.tx_size_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::_internal_mutable_tx_size() {

  return _impl_.tx_size_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::release_tx_size() {
  // @@protoc_insertion_point(field_release:Block.IntraFrameModeInfo.tx_size)
  return _impl_.tx_size_.Release();
}
inline void Block_IntraFrameModeInfo::set_allocated_tx_size(std::string* tx_size) {
  if (tx_size != nullptr) {

  } else {

  }
  _impl_.tx_size_.SetAllocated(tx_size, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_size_.IsDefault()) {
    _impl_.tx_size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.IntraFrameModeInfo.tx_size)
}

// bytes default_intra_mode = 4;
inline void Block_IntraFrameModeInfo::clear_default_intra_mode() {
  _impl_.default_intra_mode_.ClearToEmpty();
}
inline const std::string& Block_IntraFrameModeInfo::default_intra_mode() const {
  // @@protoc_insertion_point(field_get:Block.IntraFrameModeInfo.default_intra_mode)
  return _internal_default_intra_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_IntraFrameModeInfo::set_default_intra_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_intra_mode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.IntraFrameModeInfo.default_intra_mode)
}
inline std::string* Block_IntraFrameModeInfo::mutable_default_intra_mode() {
  std::string* _s = _internal_mutable_default_intra_mode();
  // @@protoc_insertion_point(field_mutable:Block.IntraFrameModeInfo.default_intra_mode)
  return _s;
}
inline const std::string& Block_IntraFrameModeInfo::_internal_default_intra_mode() const {
  return _impl_.default_intra_mode_.Get();
}
inline void Block_IntraFrameModeInfo::_internal_set_default_intra_mode(const std::string& value) {

  _impl_.default_intra_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::_internal_mutable_default_intra_mode() {

  return _impl_.default_intra_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::release_default_intra_mode() {
  // @@protoc_insertion_point(field_release:Block.IntraFrameModeInfo.default_intra_mode)
  return _impl_.default_intra_mode_.Release();
}
inline void Block_IntraFrameModeInfo::set_allocated_default_intra_mode(std::string* default_intra_mode) {
  if (default_intra_mode != nullptr) {

  } else {

  }
  _impl_.default_intra_mode_.SetAllocated(default_intra_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_intra_mode_.IsDefault()) {
    _impl_.default_intra_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.IntraFrameModeInfo.default_intra_mode)
}

// bytes default_uv_mode = 5;
inline void Block_IntraFrameModeInfo::clear_default_uv_mode() {
  _impl_.default_uv_mode_.ClearToEmpty();
}
inline const std::string& Block_IntraFrameModeInfo::default_uv_mode() const {
  // @@protoc_insertion_point(field_get:Block.IntraFrameModeInfo.default_uv_mode)
  return _internal_default_uv_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_IntraFrameModeInfo::set_default_uv_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_uv_mode_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.IntraFrameModeInfo.default_uv_mode)
}
inline std::string* Block_IntraFrameModeInfo::mutable_default_uv_mode() {
  std::string* _s = _internal_mutable_default_uv_mode();
  // @@protoc_insertion_point(field_mutable:Block.IntraFrameModeInfo.default_uv_mode)
  return _s;
}
inline const std::string& Block_IntraFrameModeInfo::_internal_default_uv_mode() const {
  return _impl_.default_uv_mode_.Get();
}
inline void Block_IntraFrameModeInfo::_internal_set_default_uv_mode(const std::string& value) {

  _impl_.default_uv_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::_internal_mutable_default_uv_mode() {

  return _impl_.default_uv_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_IntraFrameModeInfo::release_default_uv_mode() {
  // @@protoc_insertion_point(field_release:Block.IntraFrameModeInfo.default_uv_mode)
  return _impl_.default_uv_mode_.Release();
}
inline void Block_IntraFrameModeInfo::set_allocated_default_uv_mode(std::string* default_uv_mode) {
  if (default_uv_mode != nullptr) {

  } else {

  }
  _impl_.default_uv_mode_.SetAllocated(default_uv_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_uv_mode_.IsDefault()) {
    _impl_.default_uv_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.IntraFrameModeInfo.default_uv_mode)
}

// -------------------------------------------------------------------

// Block_InterFrameModeInfo

// bytes segment_id = 1;
inline void Block_InterFrameModeInfo::clear_segment_id() {
  _impl_.segment_id_.ClearToEmpty();
}
inline const std::string& Block_InterFrameModeInfo::segment_id() const {
  // @@protoc_insertion_point(field_get:Block.InterFrameModeInfo.segment_id)
  return _internal_segment_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_InterFrameModeInfo::set_segment_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.segment_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.InterFrameModeInfo.segment_id)
}
inline std::string* Block_InterFrameModeInfo::mutable_segment_id() {
  std::string* _s = _internal_mutable_segment_id();
  // @@protoc_insertion_point(field_mutable:Block.InterFrameModeInfo.segment_id)
  return _s;
}
inline const std::string& Block_InterFrameModeInfo::_internal_segment_id() const {
  return _impl_.segment_id_.Get();
}
inline void Block_InterFrameModeInfo::_internal_set_segment_id(const std::string& value) {

  _impl_.segment_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::_internal_mutable_segment_id() {

  return _impl_.segment_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::release_segment_id() {
  // @@protoc_insertion_point(field_release:Block.InterFrameModeInfo.segment_id)
  return _impl_.segment_id_.Release();
}
inline void Block_InterFrameModeInfo::set_allocated_segment_id(std::string* segment_id) {
  if (segment_id != nullptr) {

  } else {

  }
  _impl_.segment_id_.SetAllocated(segment_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.segment_id_.IsDefault()) {
    _impl_.segment_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.InterFrameModeInfo.segment_id)
}

// bytes skip = 2;
inline void Block_InterFrameModeInfo::clear_skip() {
  _impl_.skip_.ClearToEmpty();
}
inline const std::string& Block_InterFrameModeInfo::skip() const {
  // @@protoc_insertion_point(field_get:Block.InterFrameModeInfo.skip)
  return _internal_skip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_InterFrameModeInfo::set_skip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.skip_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.InterFrameModeInfo.skip)
}
inline std::string* Block_InterFrameModeInfo::mutable_skip() {
  std::string* _s = _internal_mutable_skip();
  // @@protoc_insertion_point(field_mutable:Block.InterFrameModeInfo.skip)
  return _s;
}
inline const std::string& Block_InterFrameModeInfo::_internal_skip() const {
  return _impl_.skip_.Get();
}
inline void Block_InterFrameModeInfo::_internal_set_skip(const std::string& value) {

  _impl_.skip_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::_internal_mutable_skip() {

  return _impl_.skip_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::release_skip() {
  // @@protoc_insertion_point(field_release:Block.InterFrameModeInfo.skip)
  return _impl_.skip_.Release();
}
inline void Block_InterFrameModeInfo::set_allocated_skip(std::string* skip) {
  if (skip != nullptr) {

  } else {

  }
  _impl_.skip_.SetAllocated(skip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.skip_.IsDefault()) {
    _impl_.skip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.InterFrameModeInfo.skip)
}

// bytes is_inter = 3;
inline void Block_InterFrameModeInfo::clear_is_inter() {
  _impl_.is_inter_.ClearToEmpty();
}
inline const std::string& Block_InterFrameModeInfo::is_inter() const {
  // @@protoc_insertion_point(field_get:Block.InterFrameModeInfo.is_inter)
  return _internal_is_inter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_InterFrameModeInfo::set_is_inter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.is_inter_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.InterFrameModeInfo.is_inter)
}
inline std::string* Block_InterFrameModeInfo::mutable_is_inter() {
  std::string* _s = _internal_mutable_is_inter();
  // @@protoc_insertion_point(field_mutable:Block.InterFrameModeInfo.is_inter)
  return _s;
}
inline const std::string& Block_InterFrameModeInfo::_internal_is_inter() const {
  return _impl_.is_inter_.Get();
}
inline void Block_InterFrameModeInfo::_internal_set_is_inter(const std::string& value) {

  _impl_.is_inter_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::_internal_mutable_is_inter() {

  return _impl_.is_inter_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::release_is_inter() {
  // @@protoc_insertion_point(field_release:Block.InterFrameModeInfo.is_inter)
  return _impl_.is_inter_.Release();
}
inline void Block_InterFrameModeInfo::set_allocated_is_inter(std::string* is_inter) {
  if (is_inter != nullptr) {

  } else {

  }
  _impl_.is_inter_.SetAllocated(is_inter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.is_inter_.IsDefault()) {
    _impl_.is_inter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.InterFrameModeInfo.is_inter)
}

// bytes tx_size = 4;
inline void Block_InterFrameModeInfo::clear_tx_size() {
  _impl_.tx_size_.ClearToEmpty();
}
inline const std::string& Block_InterFrameModeInfo::tx_size() const {
  // @@protoc_insertion_point(field_get:Block.InterFrameModeInfo.tx_size)
  return _internal_tx_size();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block_InterFrameModeInfo::set_tx_size(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_size_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.InterFrameModeInfo.tx_size)
}
inline std::string* Block_InterFrameModeInfo::mutable_tx_size() {
  std::string* _s = _internal_mutable_tx_size();
  // @@protoc_insertion_point(field_mutable:Block.InterFrameModeInfo.tx_size)
  return _s;
}
inline const std::string& Block_InterFrameModeInfo::_internal_tx_size() const {
  return _impl_.tx_size_.Get();
}
inline void Block_InterFrameModeInfo::_internal_set_tx_size(const std::string& value) {

  _impl_.tx_size_.Set(value, GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::_internal_mutable_tx_size() {

  return _impl_.tx_size_.Mutable(GetArenaForAllocation());
}
inline std::string* Block_InterFrameModeInfo::release_tx_size() {
  // @@protoc_insertion_point(field_release:Block.InterFrameModeInfo.tx_size)
  return _impl_.tx_size_.Release();
}
inline void Block_InterFrameModeInfo::set_allocated_tx_size(std::string* tx_size) {
  if (tx_size != nullptr) {

  } else {

  }
  _impl_.tx_size_.SetAllocated(tx_size, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_size_.IsDefault()) {
    _impl_.tx_size_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.InterFrameModeInfo.tx_size)
}

// .Block.IntraFrameModeInfo intra_frame = 5;
inline bool Block_InterFrameModeInfo::_internal_has_intra_frame() const {
  return next_frame_case() == kIntraFrame;
}
inline bool Block_InterFrameModeInfo::has_intra_frame() const {
  return _internal_has_intra_frame();
}
inline void Block_InterFrameModeInfo::set_has_intra_frame() {
  _impl_._oneof_case_[0] = kIntraFrame;
}
inline void Block_InterFrameModeInfo::clear_intra_frame() {
  if (_internal_has_intra_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.next_frame_.intra_frame_;
    }
    clear_has_next_frame();
  }
}
inline ::Block_IntraFrameModeInfo* Block_InterFrameModeInfo::release_intra_frame() {
  // @@protoc_insertion_point(field_release:Block.InterFrameModeInfo.intra_frame)
  if (_internal_has_intra_frame()) {
    clear_has_next_frame();
    ::Block_IntraFrameModeInfo* temp = _impl_.next_frame_.intra_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.next_frame_.intra_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Block_IntraFrameModeInfo& Block_InterFrameModeInfo::_internal_intra_frame() const {
  return _internal_has_intra_frame()
      ? *_impl_.next_frame_.intra_frame_
      : reinterpret_cast< ::Block_IntraFrameModeInfo&>(::_Block_IntraFrameModeInfo_default_instance_);
}
inline const ::Block_IntraFrameModeInfo& Block_InterFrameModeInfo::intra_frame() const {
  // @@protoc_insertion_point(field_get:Block.InterFrameModeInfo.intra_frame)
  return _internal_intra_frame();
}
inline ::Block_IntraFrameModeInfo* Block_InterFrameModeInfo::unsafe_arena_release_intra_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Block.InterFrameModeInfo.intra_frame)
  if (_internal_has_intra_frame()) {
    clear_has_next_frame();
    ::Block_IntraFrameModeInfo* temp = _impl_.next_frame_.intra_frame_;
    _impl_.next_frame_.intra_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Block_InterFrameModeInfo::unsafe_arena_set_allocated_intra_frame(::Block_IntraFrameModeInfo* intra_frame) {
  clear_next_frame();
  if (intra_frame) {
    set_has_intra_frame();
    _impl_.next_frame_.intra_frame_ = intra_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Block.InterFrameModeInfo.intra_frame)
}
inline ::Block_IntraFrameModeInfo* Block_InterFrameModeInfo::_internal_mutable_intra_frame() {
  if (!_internal_has_intra_frame()) {
    clear_next_frame();
    set_has_intra_frame();
    _impl_.next_frame_.intra_frame_ = CreateMaybeMessage< ::Block_IntraFrameModeInfo >(GetArenaForAllocation());
  }
  return _impl_.next_frame_.intra_frame_;
}
inline ::Block_IntraFrameModeInfo* Block_InterFrameModeInfo::mutable_intra_frame() {
  ::Block_IntraFrameModeInfo* _msg = _internal_mutable_intra_frame();
  // @@protoc_insertion_point(field_mutable:Block.InterFrameModeInfo.intra_frame)
  return _msg;
}

// .Block.InterFrameModeInfo inter_frame = 6;
inline bool Block_InterFrameModeInfo::_internal_has_inter_frame() const {
  return next_frame_case() == kInterFrame;
}
inline bool Block_InterFrameModeInfo::has_inter_frame() const {
  return _internal_has_inter_frame();
}
inline void Block_InterFrameModeInfo::set_has_inter_frame() {
  _impl_._oneof_case_[0] = kInterFrame;
}
inline void Block_InterFrameModeInfo::clear_inter_frame() {
  if (_internal_has_inter_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.next_frame_.inter_frame_;
    }
    clear_has_next_frame();
  }
}
inline ::Block_InterFrameModeInfo* Block_InterFrameModeInfo::release_inter_frame() {
  // @@protoc_insertion_point(field_release:Block.InterFrameModeInfo.inter_frame)
  if (_internal_has_inter_frame()) {
    clear_has_next_frame();
    ::Block_InterFrameModeInfo* temp = _impl_.next_frame_.inter_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.next_frame_.inter_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Block_InterFrameModeInfo& Block_InterFrameModeInfo::_internal_inter_frame() const {
  return _internal_has_inter_frame()
      ? *_impl_.next_frame_.inter_frame_
      : reinterpret_cast< ::Block_InterFrameModeInfo&>(::_Block_InterFrameModeInfo_default_instance_);
}
inline const ::Block_InterFrameModeInfo& Block_InterFrameModeInfo::inter_frame() const {
  // @@protoc_insertion_point(field_get:Block.InterFrameModeInfo.inter_frame)
  return _internal_inter_frame();
}
inline ::Block_InterFrameModeInfo* Block_InterFrameModeInfo::unsafe_arena_release_inter_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Block.InterFrameModeInfo.inter_frame)
  if (_internal_has_inter_frame()) {
    clear_has_next_frame();
    ::Block_InterFrameModeInfo* temp = _impl_.next_frame_.inter_frame_;
    _impl_.next_frame_.inter_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Block_InterFrameModeInfo::unsafe_arena_set_allocated_inter_frame(::Block_InterFrameModeInfo* inter_frame) {
  clear_next_frame();
  if (inter_frame) {
    set_has_inter_frame();
    _impl_.next_frame_.inter_frame_ = inter_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Block.InterFrameModeInfo.inter_frame)
}
inline ::Block_InterFrameModeInfo* Block_InterFrameModeInfo::_internal_mutable_inter_frame() {
  if (!_internal_has_inter_frame()) {
    clear_next_frame();
    set_has_inter_frame();
    _impl_.next_frame_.inter_frame_ = CreateMaybeMessage< ::Block_InterFrameModeInfo >(GetArenaForAllocation());
  }
  return _impl_.next_frame_.inter_frame_;
}
inline ::Block_InterFrameModeInfo* Block_InterFrameModeInfo::mutable_inter_frame() {
  ::Block_InterFrameModeInfo* _msg = _internal_mutable_inter_frame();
  // @@protoc_insertion_point(field_mutable:Block.InterFrameModeInfo.inter_frame)
  return _msg;
}

inline bool Block_InterFrameModeInfo::has_next_frame() const {
  return next_frame_case() != NEXT_FRAME_NOT_SET;
}
inline void Block_InterFrameModeInfo::clear_has_next_frame() {
  _impl_._oneof_case_[0] = NEXT_FRAME_NOT_SET;
}
inline Block_InterFrameModeInfo::NextFrameCase Block_InterFrameModeInfo::next_frame_case() const {
  return Block_InterFrameModeInfo::NextFrameCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Block

// .Block.IntraFrameModeInfo intra_frame = 1;
inline bool Block::_internal_has_intra_frame() const {
  return mode_info_case() == kIntraFrame;
}
inline bool Block::has_intra_frame() const {
  return _internal_has_intra_frame();
}
inline void Block::set_has_intra_frame() {
  _impl_._oneof_case_[0] = kIntraFrame;
}
inline void Block::clear_intra_frame() {
  if (_internal_has_intra_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mode_info_.intra_frame_;
    }
    clear_has_mode_info();
  }
}
inline ::Block_IntraFrameModeInfo* Block::release_intra_frame() {
  // @@protoc_insertion_point(field_release:Block.intra_frame)
  if (_internal_has_intra_frame()) {
    clear_has_mode_info();
    ::Block_IntraFrameModeInfo* temp = _impl_.mode_info_.intra_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_info_.intra_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Block_IntraFrameModeInfo& Block::_internal_intra_frame() const {
  return _internal_has_intra_frame()
      ? *_impl_.mode_info_.intra_frame_
      : reinterpret_cast< ::Block_IntraFrameModeInfo&>(::_Block_IntraFrameModeInfo_default_instance_);
}
inline const ::Block_IntraFrameModeInfo& Block::intra_frame() const {
  // @@protoc_insertion_point(field_get:Block.intra_frame)
  return _internal_intra_frame();
}
inline ::Block_IntraFrameModeInfo* Block::unsafe_arena_release_intra_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Block.intra_frame)
  if (_internal_has_intra_frame()) {
    clear_has_mode_info();
    ::Block_IntraFrameModeInfo* temp = _impl_.mode_info_.intra_frame_;
    _impl_.mode_info_.intra_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Block::unsafe_arena_set_allocated_intra_frame(::Block_IntraFrameModeInfo* intra_frame) {
  clear_mode_info();
  if (intra_frame) {
    set_has_intra_frame();
    _impl_.mode_info_.intra_frame_ = intra_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Block.intra_frame)
}
inline ::Block_IntraFrameModeInfo* Block::_internal_mutable_intra_frame() {
  if (!_internal_has_intra_frame()) {
    clear_mode_info();
    set_has_intra_frame();
    _impl_.mode_info_.intra_frame_ = CreateMaybeMessage< ::Block_IntraFrameModeInfo >(GetArenaForAllocation());
  }
  return _impl_.mode_info_.intra_frame_;
}
inline ::Block_IntraFrameModeInfo* Block::mutable_intra_frame() {
  ::Block_IntraFrameModeInfo* _msg = _internal_mutable_intra_frame();
  // @@protoc_insertion_point(field_mutable:Block.intra_frame)
  return _msg;
}

// .Block.InterFrameModeInfo inter_frame = 2;
inline bool Block::_internal_has_inter_frame() const {
  return mode_info_case() == kInterFrame;
}
inline bool Block::has_inter_frame() const {
  return _internal_has_inter_frame();
}
inline void Block::set_has_inter_frame() {
  _impl_._oneof_case_[0] = kInterFrame;
}
inline void Block::clear_inter_frame() {
  if (_internal_has_inter_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.mode_info_.inter_frame_;
    }
    clear_has_mode_info();
  }
}
inline ::Block_InterFrameModeInfo* Block::release_inter_frame() {
  // @@protoc_insertion_point(field_release:Block.inter_frame)
  if (_internal_has_inter_frame()) {
    clear_has_mode_info();
    ::Block_InterFrameModeInfo* temp = _impl_.mode_info_.inter_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mode_info_.inter_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Block_InterFrameModeInfo& Block::_internal_inter_frame() const {
  return _internal_has_inter_frame()
      ? *_impl_.mode_info_.inter_frame_
      : reinterpret_cast< ::Block_InterFrameModeInfo&>(::_Block_InterFrameModeInfo_default_instance_);
}
inline const ::Block_InterFrameModeInfo& Block::inter_frame() const {
  // @@protoc_insertion_point(field_get:Block.inter_frame)
  return _internal_inter_frame();
}
inline ::Block_InterFrameModeInfo* Block::unsafe_arena_release_inter_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Block.inter_frame)
  if (_internal_has_inter_frame()) {
    clear_has_mode_info();
    ::Block_InterFrameModeInfo* temp = _impl_.mode_info_.inter_frame_;
    _impl_.mode_info_.inter_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Block::unsafe_arena_set_allocated_inter_frame(::Block_InterFrameModeInfo* inter_frame) {
  clear_mode_info();
  if (inter_frame) {
    set_has_inter_frame();
    _impl_.mode_info_.inter_frame_ = inter_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Block.inter_frame)
}
inline ::Block_InterFrameModeInfo* Block::_internal_mutable_inter_frame() {
  if (!_internal_has_inter_frame()) {
    clear_mode_info();
    set_has_inter_frame();
    _impl_.mode_info_.inter_frame_ = CreateMaybeMessage< ::Block_InterFrameModeInfo >(GetArenaForAllocation());
  }
  return _impl_.mode_info_.inter_frame_;
}
inline ::Block_InterFrameModeInfo* Block::mutable_inter_frame() {
  ::Block_InterFrameModeInfo* _msg = _internal_mutable_inter_frame();
  // @@protoc_insertion_point(field_mutable:Block.inter_frame)
  return _msg;
}

// bytes residual = 3;
inline void Block::clear_residual() {
  _impl_.residual_.ClearToEmpty();
}
inline const std::string& Block::residual() const {
  // @@protoc_insertion_point(field_get:Block.residual)
  return _internal_residual();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_residual(ArgT0&& arg0, ArgT... args) {
 
 _impl_.residual_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Block.residual)
}
inline std::string* Block::mutable_residual() {
  std::string* _s = _internal_mutable_residual();
  // @@protoc_insertion_point(field_mutable:Block.residual)
  return _s;
}
inline const std::string& Block::_internal_residual() const {
  return _impl_.residual_.Get();
}
inline void Block::_internal_set_residual(const std::string& value) {

  _impl_.residual_.Set(value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_residual() {

  return _impl_.residual_.Mutable(GetArenaForAllocation());
}
inline std::string* Block::release_residual() {
  // @@protoc_insertion_point(field_release:Block.residual)
  return _impl_.residual_.Release();
}
inline void Block::set_allocated_residual(std::string* residual) {
  if (residual != nullptr) {

  } else {

  }
  _impl_.residual_.SetAllocated(residual, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.residual_.IsDefault()) {
    _impl_.residual_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Block.residual)
}

inline bool Block::has_mode_info() const {
  return mode_info_case() != MODE_INFO_NOT_SET;
}
inline void Block::clear_has_mode_info() {
  _impl_._oneof_case_[0] = MODE_INFO_NOT_SET;
}
inline Block::ModeInfoCase Block::mode_info_case() const {
  return Block::ModeInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Partition

// bytes partition = 1;
inline void Partition::clear_partition() {
  _impl_.partition_.ClearToEmpty();
}
inline const std::string& Partition::partition() const {
  // @@protoc_insertion_point(field_get:Partition.partition)
  return _internal_partition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Partition::set_partition(ArgT0&& arg0, ArgT... args) {
 
 _impl_.partition_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Partition.partition)
}
inline std::string* Partition::mutable_partition() {
  std::string* _s = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:Partition.partition)
  return _s;
}
inline const std::string& Partition::_internal_partition() const {
  return _impl_.partition_.Get();
}
inline void Partition::_internal_set_partition(const std::string& value) {

  _impl_.partition_.Set(value, GetArenaForAllocation());
}
inline std::string* Partition::_internal_mutable_partition() {

  return _impl_.partition_.Mutable(GetArenaForAllocation());
}
inline std::string* Partition::release_partition() {
  // @@protoc_insertion_point(field_release:Partition.partition)
  return _impl_.partition_.Release();
}
inline void Partition::set_allocated_partition(std::string* partition) {
  if (partition != nullptr) {

  } else {

  }
  _impl_.partition_.SetAllocated(partition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partition_.IsDefault()) {
    _impl_.partition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Partition.partition)
}

// .Block block = 2;
inline bool Partition::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool Partition::has_block() const {
  return _internal_has_block();
}
inline void Partition::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
inline const ::Block& Partition::_internal_block() const {
  const ::Block* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::Block&>(
      ::_Block_default_instance_);
}
inline const ::Block& Partition::block() const {
  // @@protoc_insertion_point(field_get:Partition.block)
  return _internal_block();
}
inline void Partition::unsafe_arena_set_allocated_block(
    ::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Partition.block)
}
inline ::Block* Partition::release_block() {
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Block* Partition::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:Partition.block)
  
  ::Block* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::Block* Partition::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::Block>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::Block* Partition::mutable_block() {
  ::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:Partition.block)
  return _msg;
}
inline void Partition::set_allocated_block(::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }

  } else {

  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Partition.block)
}

// -------------------------------------------------------------------

// Tile

// uint32 tile_size = 1;
inline void Tile::clear_tile_size() {
  _impl_.tile_size_ = 0u;
}
inline uint32_t Tile::_internal_tile_size() const {
  return _impl_.tile_size_;
}
inline uint32_t Tile::tile_size() const {
  // @@protoc_insertion_point(field_get:Tile.tile_size)
  return _internal_tile_size();
}
inline void Tile::_internal_set_tile_size(uint32_t value) {

  _impl_.tile_size_ = value;
}
inline void Tile::set_tile_size(uint32_t value) {
  _internal_set_tile_size(value);
  // @@protoc_insertion_point(field_set:Tile.tile_size)
}

// .Partition partition = 2;
inline bool Tile::_internal_has_partition() const {
  return this != internal_default_instance() && _impl_.partition_ != nullptr;
}
inline bool Tile::has_partition() const {
  return _internal_has_partition();
}
inline void Tile::clear_partition() {
  if (GetArenaForAllocation() == nullptr && _impl_.partition_ != nullptr) {
    delete _impl_.partition_;
  }
  _impl_.partition_ = nullptr;
}
inline const ::Partition& Tile::_internal_partition() const {
  const ::Partition* p = _impl_.partition_;
  return p != nullptr ? *p : reinterpret_cast<const ::Partition&>(
      ::_Partition_default_instance_);
}
inline const ::Partition& Tile::partition() const {
  // @@protoc_insertion_point(field_get:Tile.partition)
  return _internal_partition();
}
inline void Tile::unsafe_arena_set_allocated_partition(
    ::Partition* partition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partition_);
  }
  _impl_.partition_ = partition;
  if (partition) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Tile.partition)
}
inline ::Partition* Tile::release_partition() {
  
  ::Partition* temp = _impl_.partition_;
  _impl_.partition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Partition* Tile::unsafe_arena_release_partition() {
  // @@protoc_insertion_point(field_release:Tile.partition)
  
  ::Partition* temp = _impl_.partition_;
  _impl_.partition_ = nullptr;
  return temp;
}
inline ::Partition* Tile::_internal_mutable_partition() {
  
  if (_impl_.partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::Partition>(GetArenaForAllocation());
    _impl_.partition_ = p;
  }
  return _impl_.partition_;
}
inline ::Partition* Tile::mutable_partition() {
  ::Partition* _msg = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:Tile.partition)
  return _msg;
}
inline void Tile::set_allocated_partition(::Partition* partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partition_;
  }
  if (partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partition);
    if (message_arena != submessage_arena) {
      partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition, submessage_arena);
    }

  } else {

  }
  _impl_.partition_ = partition;
  // @@protoc_insertion_point(field_set_allocated:Tile.partition)
}

// -------------------------------------------------------------------

// VP9Frame

// .UncompressedHeader uncompressed_header = 1;
inline bool VP9Frame::_internal_has_uncompressed_header() const {
  return this != internal_default_instance() && _impl_.uncompressed_header_ != nullptr;
}
inline bool VP9Frame::has_uncompressed_header() const {
  return _internal_has_uncompressed_header();
}
inline void VP9Frame::clear_uncompressed_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.uncompressed_header_ != nullptr) {
    delete _impl_.uncompressed_header_;
  }
  _impl_.uncompressed_header_ = nullptr;
}
inline const ::UncompressedHeader& VP9Frame::_internal_uncompressed_header() const {
  const ::UncompressedHeader* p = _impl_.uncompressed_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::UncompressedHeader&>(
      ::_UncompressedHeader_default_instance_);
}
inline const ::UncompressedHeader& VP9Frame::uncompressed_header() const {
  // @@protoc_insertion_point(field_get:VP9Frame.uncompressed_header)
  return _internal_uncompressed_header();
}
inline void VP9Frame::unsafe_arena_set_allocated_uncompressed_header(
    ::UncompressedHeader* uncompressed_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uncompressed_header_);
  }
  _impl_.uncompressed_header_ = uncompressed_header;
  if (uncompressed_header) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VP9Frame.uncompressed_header)
}
inline ::UncompressedHeader* VP9Frame::release_uncompressed_header() {
  
  ::UncompressedHeader* temp = _impl_.uncompressed_header_;
  _impl_.uncompressed_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UncompressedHeader* VP9Frame::unsafe_arena_release_uncompressed_header() {
  // @@protoc_insertion_point(field_release:VP9Frame.uncompressed_header)
  
  ::UncompressedHeader* temp = _impl_.uncompressed_header_;
  _impl_.uncompressed_header_ = nullptr;
  return temp;
}
inline ::UncompressedHeader* VP9Frame::_internal_mutable_uncompressed_header() {
  
  if (_impl_.uncompressed_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::UncompressedHeader>(GetArenaForAllocation());
    _impl_.uncompressed_header_ = p;
  }
  return _impl_.uncompressed_header_;
}
inline ::UncompressedHeader* VP9Frame::mutable_uncompressed_header() {
  ::UncompressedHeader* _msg = _internal_mutable_uncompressed_header();
  // @@protoc_insertion_point(field_mutable:VP9Frame.uncompressed_header)
  return _msg;
}
inline void VP9Frame::set_allocated_uncompressed_header(::UncompressedHeader* uncompressed_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uncompressed_header_;
  }
  if (uncompressed_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uncompressed_header);
    if (message_arena != submessage_arena) {
      uncompressed_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uncompressed_header, submessage_arena);
    }

  } else {

  }
  _impl_.uncompressed_header_ = uncompressed_header;
  // @@protoc_insertion_point(field_set_allocated:VP9Frame.uncompressed_header)
}

// uint32 trailing_bits = 2;
inline void VP9Frame::clear_trailing_bits() {
  _impl_.trailing_bits_ = 0u;
}
inline uint32_t VP9Frame::_internal_trailing_bits() const {
  return _impl_.trailing_bits_;
}
inline uint32_t VP9Frame::trailing_bits() const {
  // @@protoc_insertion_point(field_get:VP9Frame.trailing_bits)
  return _internal_trailing_bits();
}
inline void VP9Frame::_internal_set_trailing_bits(uint32_t value) {

  _impl_.trailing_bits_ = value;
}
inline void VP9Frame::set_trailing_bits(uint32_t value) {
  _internal_set_trailing_bits(value);
  // @@protoc_insertion_point(field_set:VP9Frame.trailing_bits)
}

// uint32 padding_bit = 3;
inline void VP9Frame::clear_padding_bit() {
  _impl_.padding_bit_ = 0u;
}
inline uint32_t VP9Frame::_internal_padding_bit() const {
  return _impl_.padding_bit_;
}
inline uint32_t VP9Frame::padding_bit() const {
  // @@protoc_insertion_point(field_get:VP9Frame.padding_bit)
  return _internal_padding_bit();
}
inline void VP9Frame::_internal_set_padding_bit(uint32_t value) {

  _impl_.padding_bit_ = value;
}
inline void VP9Frame::set_padding_bit(uint32_t value) {
  _internal_set_padding_bit(value);
  // @@protoc_insertion_point(field_set:VP9Frame.padding_bit)
}

// .CompressedHeader compressed_header = 4;
inline bool VP9Frame::_internal_has_compressed_header() const {
  return this != internal_default_instance() && _impl_.compressed_header_ != nullptr;
}
inline bool VP9Frame::has_compressed_header() const {
  return _internal_has_compressed_header();
}
inline void VP9Frame::clear_compressed_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.compressed_header_ != nullptr) {
    delete _impl_.compressed_header_;
  }
  _impl_.compressed_header_ = nullptr;
}
inline const ::CompressedHeader& VP9Frame::_internal_compressed_header() const {
  const ::CompressedHeader* p = _impl_.compressed_header_;
  return p != nullptr ? *p : reinterpret_cast<const ::CompressedHeader&>(
      ::_CompressedHeader_default_instance_);
}
inline const ::CompressedHeader& VP9Frame::compressed_header() const {
  // @@protoc_insertion_point(field_get:VP9Frame.compressed_header)
  return _internal_compressed_header();
}
inline void VP9Frame::unsafe_arena_set_allocated_compressed_header(
    ::CompressedHeader* compressed_header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.compressed_header_);
  }
  _impl_.compressed_header_ = compressed_header;
  if (compressed_header) {

  } else {

  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VP9Frame.compressed_header)
}
inline ::CompressedHeader* VP9Frame::release_compressed_header() {
  
  ::CompressedHeader* temp = _impl_.compressed_header_;
  _impl_.compressed_header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CompressedHeader* VP9Frame::unsafe_arena_release_compressed_header() {
  // @@protoc_insertion_point(field_release:VP9Frame.compressed_header)
  
  ::CompressedHeader* temp = _impl_.compressed_header_;
  _impl_.compressed_header_ = nullptr;
  return temp;
}
inline ::CompressedHeader* VP9Frame::_internal_mutable_compressed_header() {
  
  if (_impl_.compressed_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::CompressedHeader>(GetArenaForAllocation());
    _impl_.compressed_header_ = p;
  }
  return _impl_.compressed_header_;
}
inline ::CompressedHeader* VP9Frame::mutable_compressed_header() {
  ::CompressedHeader* _msg = _internal_mutable_compressed_header();
  // @@protoc_insertion_point(field_mutable:VP9Frame.compressed_header)
  return _msg;
}
inline void VP9Frame::set_allocated_compressed_header(::CompressedHeader* compressed_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.compressed_header_;
  }
  if (compressed_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compressed_header);
    if (message_arena != submessage_arena) {
      compressed_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compressed_header, submessage_arena);
    }

  } else {

  }
  _impl_.compressed_header_ = compressed_header;
  // @@protoc_insertion_point(field_set_allocated:VP9Frame.compressed_header)
}

// repeated .Tile tiles = 5;
inline int VP9Frame::_internal_tiles_size() const {
  return _impl_.tiles_.size();
}
inline int VP9Frame::tiles_size() const {
  return _internal_tiles_size();
}
inline void VP9Frame::clear_tiles() {
  _impl_.tiles_.Clear();
}
inline ::Tile* VP9Frame::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:VP9Frame.tiles)
  return _impl_.tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >*
VP9Frame::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:VP9Frame.tiles)
  return &_impl_.tiles_;
}
inline const ::Tile& VP9Frame::_internal_tiles(int index) const {
  return _impl_.tiles_.Get(index);
}
inline const ::Tile& VP9Frame::tiles(int index) const {
  // @@protoc_insertion_point(field_get:VP9Frame.tiles)
  return _internal_tiles(index);
}
inline ::Tile* VP9Frame::_internal_add_tiles() {
  return _impl_.tiles_.Add();
}
inline ::Tile* VP9Frame::add_tiles() {
  ::Tile* _add = _internal_add_tiles();
  // @@protoc_insertion_point(field_add:VP9Frame.tiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tile >&
VP9Frame::tiles() const {
  // @@protoc_insertion_point(field_list:VP9Frame.tiles)
  return _impl_.tiles_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_vp9_2eproto_2epb_2eh
